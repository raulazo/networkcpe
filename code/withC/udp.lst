CCS PCH C Compiler, Version 4.100, 46564               08-Á.¤.-10 19:04

               Filename: C:\Users\dorakengi\Desktop\HW\udp.lst

               ROM used: 23706 bytes (72%)
                         Largest free fragment is 9058
               RAM used: 288 (19%) at main() level
                         424 (28%) worst case
               Stack:    11 worst case (10 in main + 1 for interrupts)

*
0000:  GOTO   5AF2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00B4
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include "C:\Users\dorakengi\Desktop\HW\udp.h" 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES RC_IO                 	//Resistor/Capacitor Osc 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NOOSCSEN              	//Oscillator switching is disabled, main oscillator is source 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES BORV20                	//Brownout reset at 2.0V 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES STVREN                	//Stack full/underflow will cause reset 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NOWRTD                	//Data EEPROM not write protected 
.................... #FUSES NOWRTB                	//Boot block not write protected 
.................... #FUSES NOCPB                 	//No Boot Block code protection 
.................... #FUSES NOWRTC                	//configuration not registers write protected 
.................... #FUSES NOEBTR                	//Memory not protected from table reads 
.................... #FUSES NOEBTRB               	//Boot block not protected from table reads 
....................  
.................... #use delay(clock=20000000) 
*
0632:  MOVLW  01
0634:  MOVWF  FEA
0636:  MOVLW  24
0638:  MOVWF  FE9
063A:  MOVF   FEF,W
063C:  BZ    0658
063E:  MOVLW  06
0640:  MOVWF  01
0642:  CLRF   00
0644:  DECFSZ 00,F
0646:  BRA    0644
0648:  DECFSZ 01,F
064A:  BRA    0642
064C:  MOVLW  7B
064E:  MOVWF  00
0650:  DECFSZ 00,F
0652:  BRA    0650
0654:  DECFSZ FEF,F
0656:  BRA    063E
0658:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          EX_ST_UDP.C                              //// 
.................... ////                                                                   //// 
.................... //// An example program demonstrating using Microchip's TCP/IP stack   //// 
.................... //// with CCS's PCH C Compiler.                                        //// 
.................... ////                                                                   //// 
.................... //// Communication between two Ethernet development boards is          //// 
.................... //// demonstrated by using UDP.  Configuration of each board is        //// 
.................... //// accomplished over the serial link.                                //// 
.................... ////                                                                   //// 
.................... //// Use the serial interface to configure the destination UDP IP      //// 
.................... //// address and UDP destination port.  You can also configure what    //// 
.................... //// UDP port to listen to for incoming packets.                       //// 
.................... ////                                                                   //// 
.................... //// The transmitted packet contains two bytes.  The first byte        //// 
.................... //// contains the ADC value, the second byte is the current button     //// 
.................... //// state (inverted).                                                 //// 
.................... ////                                                                   //// 
.................... //// If it receives a packet, it assumes that the first byte is an ADC //// 
.................... //// value from another unit, and the second byte is a button state    //// 
.................... //// from another unit.  The received ADC value will be displayed on   //// 
.................... //// the first line of the LCD.  The second LED will show the last     //// 
.................... //// received state of the other unit's button state (so if you press  //// 
.................... //// the button on UNITA, the LED on UNITB will go on and vice versa). //// 
.................... ////                                                                   //// 
.................... //// The first line of the LCD will display Ethernet/PPP status.  If   //// 
.................... //// the unit is listening for packets, it will display it's IP        //// 
.................... //// adress on the first line of the LCD.  Once it receives 1 packet   //// 
.................... //// it will display the first byte received (the ADC value) on the    //// 
.................... //// first line of the LCD.                                            //// 
.................... ////                                                                   //// 
.................... //// The second line of the LCD shows the current TX status, whether   //// 
.................... //// or not a UDP socket has been opened.  It will either say          //// 
.................... //// 'CONNECTING' or 'CONNECTED'.  Remember that UDP is a              //// 
.................... //// connectionless transfer protocol, there really is no              //// 
.................... //// 'CONNECTED' state with UDP.  When it says 'CONNECTED' this        //// 
.................... //// simply means that ARP has been resolved, and a valid UDP          //// 
.................... //// socket has been opened from the TCP/IP stack.  Even though        //// 
.................... //// it is 'CONNECTED' you may be sending packets to nowhere.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// ABOUT CCS TCP/IP EXAMPLES:                                        //// 
.................... ////                                                                   //// 
.................... //// Connect your prototype board to serial cable, and open a serial   //// 
.................... //// connection at 9600bps.  With this link you can change all the     //// 
.................... //// ethernet and PPP settings.  You can also see the current status   //// 
.................... //// of the TCP/IP link.  Pressing any key will bring up the menu.     //// 
.................... ////                                                                   //// 
.................... //// If you are using PPP, you will need to initiate and disconnect a  //// 
.................... //// PPP connection using this serial link.  Until PPP is connected    //// 
.................... //// the board will not be connected to TCP/IP.                        //// 
.................... ////                                                                   //// 
.................... //// If the LCD is enabled in the code (it is enabled by default), the //// 
.................... //// last line displayed will be IP address of the unit.  If your      //// 
.................... //// ISP / Network doesn't filter ICMP/PING you can use the PING       //// 
.................... //// utility to test your connection.  If the last line doesn't        //// 
.................... //// display the IP address then the unit is connected (PPP not        //// 
.................... //// connected, ethernet cable not connected, a problem with ethernet  //// 
.................... //// DHCP, etc).                                                       //// 
.................... ////                                                                   //// 
.................... //// CAUTION: All settings are saved to the external EEPROM.  If you   //// 
.................... //// are using the Microchip PICDEM.net board that has an example      //// 
.................... //// file-system with webpages it will be deleted/corrupted by these   //// 
.................... //// examples.                                                         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Initial Release.                                               //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //quick auto configure for different tcp/ip demo boards 
.................... #define STACK_USE_CCS_PICNET        0  //PICNET rev 0-2 board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F6620 
.................... #define STACK_USE_CCS_PICNET3       0  //PICNET rv 3 and up board sold by CCS.  Has a 56K modem and a 10BaseT Network IC and 18F8622 
.................... #define STACK_USE_CCS_PICENS        1  //CCS PICENS (Embedded Ethernet) development kit.  18F4620 + ENC28J60 
.................... #define STACK_USE_CCS_PICEEC        0  //CCS PICEEC (Embedded Ethernet) development kit.  18F67J60 
.................... #define STACK_USE_CCS_EWL5V         0  //CCS 5V EZ Web Lynx Device 
.................... #define STACK_USE_CCS_EWL3V         0  //CCS 3.3V EZ Web Lynx Device 
....................  
.................... //You must set one (and only) one of these to TRUE to tell the stack what hardware layer you are using 
.................... #define STACK_USE_MAC   1      //use the nic card 
.................... #define STACK_USE_PPP   0     //use PPP on modem 
.................... #define STACK_USE_SLIP  0    //use slip (NOT TESTED) 
....................  
.................... //if you are using MPFS, you can either store the image on the EEPROM or  
.................... //in the program memory 
.................... #define MPFS_USE_EEPROM 
.................... //#define MPFS_USE_PGRM 
....................  
....................  
.................... /// *** END USER CONFIGURABLE DEFINITIONS 
....................  
.................... #if STACK_USE_CCS_EWL5V || STACK_USE_CCS_EWL3V 
....................    #define STACK_USE_CCS_EWL  1 
.................... #else 
....................    #define STACK_USE_CCS_EWL  0 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL5V+STACK_USE_CCS_EWL3V >1) 
....................  #error You can only use one hardware definition 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS+STACK_USE_CCS_PICNET3+STACK_USE_CCS_PICNET+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL5V+STACK_USE_CCS_EWL3V==0) 
....................  #error You must define one hardware definition 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET3 
....................  #undef STACK_USE_CCS_PICNET 
....................  #define STACK_USE_CCS_PICNET 1 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_CCS_PICNET3 
....................  #include <18f6722.h> 
....................  #use delay(clock=40000000) 
....................  #fuses H4 
....................  #fuses CCP2C1 
....................  #fuses MCLR 
.................... #elif STACK_USE_CCS_PICNET 
....................  #include <18f6720.h> 
....................  #use delay(clock=20000000) //CCS picnet is 20Mhz 
....................  #fuses HS 
....................  #fuses CCP2C1 
.................... #elif STACK_USE_CCS_PICENS 
....................  //#include <18f4458.h> 
....................  //#use delay(clock=20000000) 
....................  //#fuses H4 
.................... //! #fuses NOFCMEN 
.................... //! #fuses NOXINST 
.................... //! #fuses NOIESO 
.................... //! #fuses NOPBADEN 
.................... //! #fuses MCLR 
....................     
....................     
.................... #elif STACK_USE_CCS_PICEEC|| STACK_USE_CCS_EWL3V 
....................  #include <18F67J60.H> 
....................  #use delay(clock=25M) 
....................  #fuses HS 
....................  #fuses NOIESO 
....................  #fuses NOFCMEN 
....................  #fuses PRIMARY 
....................  #fuses ETHLED 
.................... #elif STACK_USE_CCS_EWL5V 
....................  #include <18F2685.H> 
....................  #use delay(clock=25M) 
....................  #fuses HS 
....................  #fuses NOPBADEN 
....................  #fuses MCLR 
.................... #endif 
.................... */ 
....................  
....................  
.................... #fuses NOWDT 
.................... #fuses NOPROTECT 
.................... #fuses NODEBUG 
.................... #fuses NOSTVREN 
....................  
.................... #if !(STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V) 
....................  #fuses PUT 
....................  #fuses NOLVP 
....................  #fuses NOBROWNOUT 
....................  #fuses NOCPD 
....................  #fuses WRT 
....................  #fuses NOWRTD 
....................  #fuses NOEBTR 
....................  #fuses NOCPB 
....................  #fuses NOEBTRB 
....................  #fuses WRTB 
.................... #endif 
....................  
.................... //set to true to put out information on the LCD screen 
.................... #if STACK_USE_CCS_EWL 
....................  //due to limited IO space on the ezweblynx, we will not use LCD 
....................  #define STACK_USE_PICDEM_LCD     FALSE      
.................... #else 
....................  #define STACK_USE_PICDEM_LCD     TRUE 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_MAC 
....................  #define STACK_USE_DHCP  TRUE  //for auto resolution of IP address 
....................  #define STACK_USE_ARP   TRUE  //needed to resolve MAC addresses of IP addresses 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICENS||STACK_USE_CCS_EWL5V) && STACK_USE_MAC 
....................  #define STACK_USE_MCPENC  TRUE     //tell the stack to use the ENC28J60 driver 
.................... #else 
....................  #define STACK_USE_MCPENC  FALSE    //tell the stack to use the Realtek driver 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V) && STACK_USE_MAC 
....................  #define STACK_USE_MCPINC  TRUE 
.................... #else 
....................  #define STACK_USE_MCPINC  FALSE 
.................... #endif 
....................  
.................... #define STACK_USE_ICMP        TRUE   //for ping 
.................... #define STACK_USE_UDP         TRUE 
.................... #define STACK_USE_IP_GLEANING FALSE 
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, STREAM=USER) 
.................... #define debug_printf   printf 
....................  
.................... #include "tcpip/stacktsk.c"    //include Microchip's TCP/IP stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_CCS_PICENS 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #elif STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V 
....................       //no hardware definitions - everything is internal 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
....................  
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1BB4:  MOVLB  1
1BB6:  CLRF   x3B
....................    sign = 0; 
1BB8:  CLRF   x39
....................    base = 10; 
1BBA:  MOVLW  0A
1BBC:  MOVWF  x3A
....................    result = 0; 
1BBE:  CLRF   x38
1BC0:  CLRF   x37
....................  
....................    if (!s) 
1BC2:  MOVF   x35,W
1BC4:  IORWF  x36,W
1BC6:  BNZ   1BD0
....................       return 0; 
1BC8:  MOVLW  00
1BCA:  MOVWF  01
1BCC:  MOVWF  02
1BCE:  BRA    1DA0
....................    c = s[index++]; 
1BD0:  MOVF   x3B,W
1BD2:  INCF   x3B,F
1BD4:  CLRF   03
1BD6:  ADDWF  x35,W
1BD8:  MOVWF  FE9
1BDA:  MOVF   x36,W
1BDC:  ADDWFC 03,W
1BDE:  MOVWF  FEA
1BE0:  MOVFF  FEF,13C
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1BE4:  MOVF   x3C,W
1BE6:  SUBLW  2D
1BE8:  BNZ   1C04
....................    { 
....................       sign = 1;         // Set the sign to negative 
1BEA:  MOVLW  01
1BEC:  MOVWF  x39
....................       c = s[index++]; 
1BEE:  MOVF   x3B,W
1BF0:  INCF   x3B,F
1BF2:  CLRF   03
1BF4:  ADDWF  x35,W
1BF6:  MOVWF  FE9
1BF8:  MOVF   x36,W
1BFA:  ADDWFC 03,W
1BFC:  MOVWF  FEA
1BFE:  MOVFF  FEF,13C
....................    } 
....................    else if (c == '+') 
1C02:  BRA    1C1E
1C04:  MOVF   x3C,W
1C06:  SUBLW  2B
1C08:  BNZ   1C1E
....................    { 
....................       c = s[index++]; 
1C0A:  MOVF   x3B,W
1C0C:  INCF   x3B,F
1C0E:  CLRF   03
1C10:  ADDWF  x35,W
1C12:  MOVWF  FE9
1C14:  MOVF   x36,W
1C16:  ADDWFC 03,W
1C18:  MOVWF  FEA
1C1A:  MOVFF  FEF,13C
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1C1E:  MOVF   x3C,W
1C20:  SUBLW  2F
1C22:  BTFSC  FD8.0
1C24:  BRA    1D84
1C26:  MOVF   x3C,W
1C28:  SUBLW  39
1C2A:  BTFSS  FD8.0
1C2C:  BRA    1D84
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1C2E:  MOVF   x3C,W
1C30:  SUBLW  30
1C32:  BNZ   1C76
1C34:  CLRF   03
1C36:  MOVF   x3B,W
1C38:  ADDWF  x35,W
1C3A:  MOVWF  FE9
1C3C:  MOVF   x36,W
1C3E:  ADDWFC 03,W
1C40:  MOVWF  FEA
1C42:  MOVF   FEF,W
1C44:  SUBLW  78
1C46:  BZ    1C5C
1C48:  CLRF   03
1C4A:  MOVF   x3B,W
1C4C:  ADDWF  x35,W
1C4E:  MOVWF  FE9
1C50:  MOVF   x36,W
1C52:  ADDWFC 03,W
1C54:  MOVWF  FEA
1C56:  MOVF   FEF,W
1C58:  SUBLW  58
1C5A:  BNZ   1C76
....................       { 
....................          base = 16; 
1C5C:  MOVLW  10
1C5E:  MOVWF  x3A
....................          index++; 
1C60:  INCF   x3B,F
....................          c = s[index++]; 
1C62:  MOVF   x3B,W
1C64:  INCF   x3B,F
1C66:  CLRF   03
1C68:  ADDWF  x35,W
1C6A:  MOVWF  FE9
1C6C:  MOVF   x36,W
1C6E:  ADDWFC 03,W
1C70:  MOVWF  FEA
1C72:  MOVFF  FEF,13C
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1C76:  MOVF   x3A,W
1C78:  SUBLW  0A
1C7A:  BNZ   1CC2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1C7C:  MOVF   x3C,W
1C7E:  SUBLW  2F
1C80:  BC    1CC0
1C82:  MOVF   x3C,W
1C84:  SUBLW  39
1C86:  BNC   1CC0
....................             result = 10*result + (c - '0'); 
1C88:  CLRF   x3E
1C8A:  MOVLW  0A
1C8C:  MOVWF  x3D
1C8E:  MOVFF  138,140
1C92:  MOVFF  137,13F
1C96:  MOVLB  0
1C98:  BRA    1B5E
1C9A:  MOVLW  30
1C9C:  MOVLB  1
1C9E:  SUBWF  x3C,W
1CA0:  ADDWF  01,W
1CA2:  MOVWF  x37
1CA4:  MOVLW  00
1CA6:  ADDWFC 02,W
1CA8:  MOVWF  x38
....................             c = s[index++]; 
1CAA:  MOVF   x3B,W
1CAC:  INCF   x3B,F
1CAE:  CLRF   03
1CB0:  ADDWF  x35,W
1CB2:  MOVWF  FE9
1CB4:  MOVF   x36,W
1CB6:  ADDWFC 03,W
1CB8:  MOVWF  FEA
1CBA:  MOVFF  FEF,13C
....................          } 
1CBE:  BRA    1C7C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1CC0:  BRA    1D84
1CC2:  MOVF   x3A,W
1CC4:  SUBLW  10
1CC6:  BNZ   1D84
....................       { 
....................          c = toupper(c); 
1CC8:  MOVF   x3C,W
1CCA:  SUBLW  60
1CCC:  BC    1CDA
1CCE:  MOVF   x3C,W
1CD0:  SUBLW  7A
1CD2:  BNC   1CDA
1CD4:  MOVF   x3C,W
1CD6:  ANDLW  DF
1CD8:  BRA    1CDC
1CDA:  MOVF   x3C,W
1CDC:  MOVWF  x3C
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
1CDE:  MOVF   x3C,W
1CE0:  SUBLW  2F
1CE2:  BC    1CEA
1CE4:  MOVF   x3C,W
1CE6:  SUBLW  39
1CE8:  BC    1CF6
1CEA:  MOVF   x3C,W
1CEC:  SUBLW  40
1CEE:  BC    1D84
1CF0:  MOVF   x3C,W
1CF2:  SUBLW  46
1CF4:  BNC   1D84
....................             if (c >= '0' && c <= '9') 
1CF6:  MOVF   x3C,W
1CF8:  SUBLW  2F
1CFA:  BC    1D2E
1CFC:  MOVF   x3C,W
1CFE:  SUBLW  39
1D00:  BNC   1D2E
....................                result = (result << 4) + (c - '0'); 
1D02:  RLCF   x37,W
1D04:  MOVWF  x3D
1D06:  RLCF   x38,W
1D08:  MOVWF  x3E
1D0A:  RLCF   x3D,F
1D0C:  RLCF   x3E,F
1D0E:  RLCF   x3D,F
1D10:  RLCF   x3E,F
1D12:  RLCF   x3D,F
1D14:  RLCF   x3E,F
1D16:  MOVLW  F0
1D18:  ANDWF  x3D,F
1D1A:  MOVLW  30
1D1C:  SUBWF  x3C,W
1D1E:  ADDWF  x3D,W
1D20:  MOVWF  01
1D22:  MOVLW  00
1D24:  ADDWFC x3E,W
1D26:  MOVFF  01,137
1D2A:  MOVWF  x38
....................             else 
1D2C:  BRA    1D5A
....................                result = (result << 4) + (c - 'A' + 10); 
1D2E:  RLCF   x37,W
1D30:  MOVWF  x3D
1D32:  RLCF   x38,W
1D34:  MOVWF  x3E
1D36:  RLCF   x3D,F
1D38:  RLCF   x3E,F
1D3A:  RLCF   x3D,F
1D3C:  RLCF   x3E,F
1D3E:  RLCF   x3D,F
1D40:  RLCF   x3E,F
1D42:  MOVLW  F0
1D44:  ANDWF  x3D,F
1D46:  MOVLW  41
1D48:  SUBWF  x3C,W
1D4A:  ADDLW  0A
1D4C:  ADDWF  x3D,W
1D4E:  MOVWF  01
1D50:  MOVLW  00
1D52:  ADDWFC x3E,W
1D54:  MOVFF  01,137
1D58:  MOVWF  x38
....................  
....................             c = s[index++];c = toupper(c); 
1D5A:  MOVF   x3B,W
1D5C:  INCF   x3B,F
1D5E:  CLRF   03
1D60:  ADDWF  x35,W
1D62:  MOVWF  FE9
1D64:  MOVF   x36,W
1D66:  ADDWFC 03,W
1D68:  MOVWF  FEA
1D6A:  MOVF   FEF,W
1D6C:  MOVWF  x3C
1D6E:  SUBLW  60
1D70:  BC    1D7E
1D72:  MOVF   x3C,W
1D74:  SUBLW  7A
1D76:  BNC   1D7E
1D78:  MOVF   x3C,W
1D7A:  ANDLW  DF
1D7C:  BRA    1D80
1D7E:  MOVF   x3C,W
1D80:  MOVWF  x3C
....................          } 
1D82:  BRA    1CDE
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1D84:  MOVF   x3A,W
1D86:  SUBLW  0A
1D88:  BNZ   1D98
1D8A:  DECFSZ x39,W
1D8C:  BRA    1D98
....................       result = -result; 
1D8E:  COMF   x37,F
1D90:  COMF   x38,F
1D92:  INCF   x37,F
1D94:  BTFSC  FD8.2
1D96:  INCF   x38,F
....................  
....................    return(result); 
1D98:  MOVFF  137,01
1D9C:  MOVFF  138,02
.................... } 
1DA0:  MOVLB  0
1DA2:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
2DC4:  MOVFF  19D,19E
....................     new.v[1]=v.v[0]; 
2DC8:  MOVFF  19C,19F
....................  
....................     return(new.Val); 
2DCC:  MOVLB  1
2DCE:  MOVFF  19E,01
2DD2:  MOVFF  19F,02
.................... } 
2DD6:  MOVLB  0
2DD8:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
....................     new.v[1]=v.v[2]; 
....................     new.v[2]=v.v[1]; 
....................     new.v[3]=v.v[0]; 
....................  
....................     return(new.Val); 
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
3A64:  MOVLB  1
3A66:  CLRF   x52
3A68:  CLRF   x51
3A6A:  CLRF   x50
3A6C:  CLRF   x4F
....................  
.................... 	i = count >> 1; 
3A6E:  BCF    FD8.0
3A70:  RRCF   x46,W
3A72:  MOVWF  x48
3A74:  RRCF   x45,W
3A76:  MOVWF  x47
.................... 	val = (WORD *)buffer; 
3A78:  MOVFF  144,14A
3A7C:  MOVFF  143,149
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
3A80:  MOVFF  148,03
3A84:  MOVF   x47,W
3A86:  BTFSC  FD8.2
3A88:  DECF   x48,F
3A8A:  DECF   x47,F
3A8C:  IORWF  03,W
3A8E:  BZ    3ABE
3A90:  MOVFF  14A,03
3A94:  MOVFF  149,00
3A98:  MOVLW  02
3A9A:  ADDWF  x49,F
3A9C:  BTFSC  FD8.0
3A9E:  INCF   x4A,F
3AA0:  MOVFF  00,FE9
3AA4:  MOVFF  03,FEA
3AA8:  MOVFF  FEC,03
3AAC:  MOVF   FED,F
3AAE:  MOVF   FEF,W
3AB0:  ADDWF  x4F,F
3AB2:  MOVF   03,W
3AB4:  ADDWFC x50,F
3AB6:  MOVLW  00
3AB8:  ADDWFC x51,F
3ABA:  ADDWFC x52,F
3ABC:  BRA    3A80
....................  
.................... 	if ( count & 1 ) 
3ABE:  MOVF   x45,W
3AC0:  ANDLW  01
3AC2:  MOVWF  00
3AC4:  CLRF   03
3AC6:  MOVF   00,W
3AC8:  IORWF  03,W
3ACA:  BZ    3AE0
.................... 		sum.Val += *(BYTE *)val; 
3ACC:  MOVFF  149,FE9
3AD0:  MOVFF  14A,FEA
3AD4:  MOVF   FEF,W
3AD6:  ADDWF  x4F,F
3AD8:  MOVLW  00
3ADA:  ADDWFC x50,F
3ADC:  ADDWFC x51,F
3ADE:  ADDWFC x52,F
....................  
.................... 	tempSum.Val = sum.Val; 
3AE0:  MOVFF  152,14E
3AE4:  MOVFF  151,14D
3AE8:  MOVFF  150,14C
3AEC:  MOVFF  14F,14B
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
3AF0:  MOVFF  14E,148
3AF4:  MOVFF  14D,147
3AF8:  MOVF   x47,F
3AFA:  BNZ   3B00
3AFC:  MOVF   x48,F
3AFE:  BZ    3B3E
.................... 		sum.words.MSB.Val = 0; 
3B00:  CLRF   x52
3B02:  CLRF   x51
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
3B04:  CLRF   x56
3B06:  CLRF   x55
3B08:  MOVFF  150,154
3B0C:  MOVFF  14F,153
3B10:  CLRF   02
3B12:  CLRF   03
3B14:  MOVF   x47,W
3B16:  ADDWF  x4F,W
3B18:  MOVWF  x4F
3B1A:  MOVF   x48,W
3B1C:  ADDWFC x50,W
3B1E:  MOVWF  x50
3B20:  MOVF   02,W
3B22:  ADDWFC x55,W
3B24:  MOVWF  x51
3B26:  MOVF   03,W
3B28:  ADDWFC x56,W
3B2A:  MOVWF  x52
.................... 		tempSum.Val = sum.Val; 
3B2C:  MOVFF  152,14E
3B30:  MOVFF  151,14D
3B34:  MOVFF  150,14C
3B38:  MOVFF  14F,14B
.................... 	} 
3B3C:  BRA    3AF0
....................  
.................... 	return (~sum.words.LSB.Val); 
3B3E:  MOVFF  150,03
3B42:  COMF   03,F
3B44:  MOVF   x4F,W
3B46:  XORLW  FF
3B48:  MOVWF  01
3B4A:  MOVFF  03,02
.................... } 
3B4E:  MOVLB  0
3B50:  GOTO   3FB0 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
0BBA:  MOVLW  83
0BBC:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
0BBE:  MOVLW  85
0BC0:  MOVWF  FD7
0BC2:  MOVLW  ED
0BC4:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
0BC6:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
0BC8:  MOVLW  C0
0BCA:  IORWF  FF2,F
.................... } 
0BCC:  GOTO   1158 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
1730:  BCF    FF2.5
....................     ret=TickCount; 
1732:  MOVFF  4F,136
1736:  MOVFF  4E,135
....................     enable_interrupts(INT_TIMER0); 
173A:  BSF    FF2.5
....................     return ret; 
173C:  MOVLB  1
173E:  MOVFF  135,01
1742:  MOVFF  136,02
.................... } 
1746:  MOVLB  0
1748:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00B4:  INCF   4E,F
00B6:  BTFSC  FD8.2
00B8:  INCF   4F,F
....................  
....................         second_counter_intermediate++; 
00BA:  INCF   51,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00BC:  MOVF   51,W
00BE:  SUBLW  09
00C0:  BC    00C6
....................             second_counter++; //increment this ever 1s 
00C2:  INCF   50,F
....................             second_counter_intermediate=0; 
00C4:  CLRF   51
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00C6:  MOVLW  85
00C8:  MOVWF  FD7
00CA:  MOVLW  ED
00CC:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *					     MAC.h 
....................  *					     string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *					     Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date   		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		6/28/04	Original 
....................  * Howard Schlunder		10/8/04	Cleanup 
....................  * Howard Schlunder		10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder		11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder		12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder		1/09/06	Added comments and minor mods 
....................  * Howard Schlunder		1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder		2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE		//due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
....................  
.................... #define SPISelectEthernet()		output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()	output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS	(TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO	(LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS		(TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO		(LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //		flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //		other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //		done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a) 					(a & 0xFF) 
.................... #define HIGH(a) 				((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE	8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART	(0ul)						// Should be an even memory address 
.................... #define	RXSTOP	((TXSTART-2ul) | 0x0001ul)	// Odd for errata workaround 
.................... #define RXSIZE	(RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define	WCR (0b010<<5)			// Write Control Register command 
.................... #define BFS (0b100<<5)			// Bit Field Set command 
.................... #define	BFC (0b101<<5)			// Bit Field Clear command 
.................... #define	RCR (0b000<<5)			// Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)	// Read Buffer Memory command 
.................... #define	WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define	SR  ((0b111<<5) | 0x1F)	// System Reset command does not use an address. 
.................... 								//   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP	(0x00u) 
.................... #define ETHER_ARP	(0x06u) 
....................  
.................... #define MAXFRAMEC	(1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
00CE:  BCF    FF2.2
00D0:  GOTO   0054
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16			NextPacketPointer; 
....................     RXSTATUS		StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
.................... 	WORD_VAL StartAddress; 
.................... 	WORD_VAL EndAddress; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bFree : 1; 
.................... 		unsigned char bTransmitted : 1; 
.................... 	} Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
*
07A4:  MOVLW  03
07A6:  IORWF  F93,F
07A8:  MOVF   F94,W
07AA:  ANDLW  D7
07AC:  IORLW  10
07AE:  MOVWF  F94
07B0:  MOVLW  F4
07B2:  ANDWF  F95,F
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
07B4:  BCF    FC6.5
07B6:  MOVLW  20
07B8:  MOVWF  FC6
07BA:  MOVLW  40
07BC:  MOVWF  FC7
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
.................... 	// 
.................... 	// Set up the SPI module on the PIC for communications with the ENC28J60 
.................... 	// 
.................... 	SPIUnselectEthernet(); 
07BE:  BCF    F95.1
07C0:  BSF    F8C.1
....................  
.................... 	// Deassert the nRESET pin on the ENC28J60.  The internal 
.................... 	// weak pull on the nRESET pin will get the job done anyway, 
.................... 	// so this isn't necessary, but it may provide extra noise immunity, 
.................... 	// should someone put their finger on the pin or otherwise cause a leakage 
.................... 	// path to ground on this pin. 
.................... 	output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
07C2:  BCF    F95.0
07C4:  BSF    F8C.0
.................... } 
07C6:  RETLW  00
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
*
0BD0:  MOVF   FC9,W
0BD2:  MOVFF  1A7,FC9
0BD6:  RRCF   FC7,W
0BD8:  BNC   0BD6
0BDA:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
0BDE:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *					registers in the ENC28J60 so that normal operation can 
....................  *					begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
.................... 	BYTE i; 
....................  
....................    ENCSPIInit(); 
*
0EAA:  RCALL  07A4
....................  
.................... 	// Wait for CLKRDY to become set. 
.................... 	// Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
.................... 	// means the part is in RESET or otherwise our SPI pin is being driven 
.................... 	// incorrectly.  Make sure it is working before proceeding. 
.................... 	do 
.................... 	{ 
.................... 		i = ReadETHReg(ESTAT).Val; 
0EAC:  MOVLW  1D
0EAE:  MOVLB  1
0EB0:  MOVWF  x9C
0EB2:  MOVLB  0
0EB4:  RCALL  0BE0
0EB6:  MOVFF  01,120
.................... 	} while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0EBA:  MOVLB  1
0EBC:  BTFSS  x20.3
0EBE:  BRA    0EC4
0EC0:  MOVLB  0
0EC2:  BRA    0EAC
0EC4:  MOVF   x20,W
0EC6:  XORLW  FF
0EC8:  ANDLW  01
0ECA:  BTFSC  FD8.2
0ECC:  BRA    0ED2
0ECE:  MOVLB  0
0ED0:  BRA    0EAC
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
.................... 	// Do the memory test and enter a while always trap if a hardware error 
.................... 	// occured.  The LEDA and LEDB pins will be configured to blink 
.................... 	// periodically in an abnormal manner to indicate to the user that the 
.................... 	// error occured. 
.................... 	if( !TestMemory() ) 
.................... 	{ 
.................... 		SetLEDConfig(0x0AA2);		// Set LEDs to blink periodically 
.................... 		while(1); 
.................... 	} 
.................... #endif 
....................  
.................... 	// RESET the entire ENC28J60, clearing all registers 
.................... 	SendSystemReset(); 
0ED2:  MOVLB  0
0ED4:  BRA    0C0A
....................     delay_ms(1); 
0ED6:  MOVLW  01
0ED8:  MOVLB  1
0EDA:  MOVWF  x24
0EDC:  MOVLB  0
0EDE:  CALL   0632
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0EE2:  CLRF   4D
....................  
.................... 	// Start up in Bank 0 and configure the receive buffer boundary pointers 
.................... 	// and the buffer write protect pointer (receive buffer read pointer) 
.................... 	WasDiscarded = TRUE; 
0EE4:  BSF    56.0
.................... 	NextPacketLocation.Val = RXSTART; 
0EE6:  CLRF   53
0EE8:  CLRF   52
.................... 	WriteReg(ERXSTL, LOW(RXSTART)); 
0EEA:  MOVLW  08
0EEC:  MOVLB  1
0EEE:  MOVWF  xA2
0EF0:  CLRF   xA3
0EF2:  MOVLB  0
0EF4:  RCALL  0C20
.................... 	WriteReg(ERXSTH, HIGH(RXSTART)); 
0EF6:  MOVLW  09
0EF8:  MOVLB  1
0EFA:  MOVWF  xA2
0EFC:  CLRF   xA3
0EFE:  MOVLB  0
0F00:  RCALL  0C20
.................... 	WriteReg(ERXRDPTL, LOW(RXSTOP));	// Write low byte first 
0F02:  MOVLW  0C
0F04:  MOVLB  1
0F06:  MOVWF  xA2
0F08:  MOVLW  F7
0F0A:  MOVWF  xA3
0F0C:  MOVLB  0
0F0E:  RCALL  0C20
.................... 	WriteReg(ERXRDPTH, HIGH(RXSTOP));	// Write high byte last 
0F10:  MOVLW  0D
0F12:  MOVLB  1
0F14:  MOVWF  xA2
0F16:  MOVLW  1B
0F18:  MOVWF  xA3
0F1A:  MOVLB  0
0F1C:  RCALL  0C20
.................... #if RXSTOP != 0x1FFF	// The RESET default ERXND is 0x1FFF 
.................... 	WriteReg(ERXNDL, LOW(RXSTOP)); 
0F1E:  MOVLW  0A
0F20:  MOVLB  1
0F22:  MOVWF  xA2
0F24:  MOVLW  F7
0F26:  MOVWF  xA3
0F28:  MOVLB  0
0F2A:  RCALL  0C20
.................... 	WriteReg(ERXNDH, HIGH(RXSTOP)); 
0F2C:  MOVLW  0B
0F2E:  MOVLB  1
0F30:  MOVWF  xA2
0F32:  MOVLW  1B
0F34:  MOVWF  xA3
0F36:  MOVLB  0
0F38:  RCALL  0C20
.................... #endif 
.................... #if TXSTART != 0		// The RESET default ETXST is 0 
.................... 	WriteReg(ETXSTL, LOW(TXSTART)); 
0F3A:  MOVLW  04
0F3C:  MOVLB  1
0F3E:  MOVWF  xA2
0F40:  MOVLW  F8
0F42:  MOVWF  xA3
0F44:  MOVLB  0
0F46:  RCALL  0C20
.................... 	WriteReg(ETXSTH, HIGH(TXSTART)); 
0F48:  MOVLW  05
0F4A:  MOVLB  1
0F4C:  MOVWF  xA2
0F4E:  MOVLW  1B
0F50:  MOVWF  xA3
0F52:  MOVLB  0
0F54:  RCALL  0C20
.................... #endif 
....................  
.................... 	// Enter Bank 1 and configure Receive Filters 
.................... 	// (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
.................... 	// acceptable) 
.................... 	// Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
.................... 	//BankSel(ERXFCON); 
.................... 	//WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
.................... 	// Enter Bank 2 and configure the MAC 
.................... 	BankSel(MACON1); 
0F56:  MOVLW  02
0F58:  MOVLB  1
0F5A:  MOVWF  xA0
0F5C:  CLRF   x9F
0F5E:  MOVLB  0
0F60:  RCALL  0C7A
....................  
.................... 	// Enable the receive portion of the MAC 
.................... 	WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
0F62:  MOVLB  1
0F64:  CLRF   xA2
0F66:  MOVLW  0D
0F68:  MOVWF  xA3
0F6A:  MOVLB  0
0F6C:  RCALL  0C20
....................  
.................... 	// Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... 	WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
0F6E:  MOVLW  02
0F70:  MOVLB  1
0F72:  MOVWF  xA2
0F74:  MOVLW  32
0F76:  MOVWF  xA3
0F78:  MOVLB  0
0F7A:  RCALL  0C20
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0F7C:  MOVLW  03
0F7E:  MOVLB  1
0F80:  MOVWF  xA2
0F82:  MOVLW  40
0F84:  MOVWF  xA3
0F86:  MOVLB  0
0F88:  RCALL  0C20
....................  
.................... 	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
.................... 	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
.................... 	// collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
0F8A:  MOVLW  09
0F8C:  MOVLB  1
0F8E:  MOVWF  xA2
0F90:  MOVLW  3F
0F92:  MOVWF  xA3
0F94:  MOVLB  0
0F96:  RCALL  0C20
....................  
.................... 	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
.................... 	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
.................... 	// later. 
.................... 	WriteReg((BYTE)MAIPGL, 0x12); 
0F98:  MOVLW  06
0F9A:  MOVLB  1
0F9C:  MOVWF  xA2
0F9E:  MOVLW  12
0FA0:  MOVWF  xA3
0FA2:  MOVLB  0
0FA4:  RCALL  0C20
.................... 	WriteReg((BYTE)MAIPGH, 0x0C); 
0FA6:  MOVLW  07
0FA8:  MOVLB  1
0FAA:  MOVWF  xA2
0FAC:  MOVLW  0C
0FAE:  MOVWF  xA3
0FB0:  MOVLB  0
0FB2:  RCALL  0C20
....................  
.................... 	// Set the maximum packet size which the controller will accept 
.................... 	WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
0FB4:  MOVLW  0A
0FB6:  MOVLB  1
0FB8:  MOVWF  xA2
0FBA:  MOVLW  EE
0FBC:  MOVWF  xA3
0FBE:  MOVLB  0
0FC0:  RCALL  0C20
.................... 	WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
0FC2:  MOVLW  0B
0FC4:  MOVLB  1
0FC6:  MOVWF  xA2
0FC8:  MOVLW  05
0FCA:  MOVWF  xA3
0FCC:  MOVLB  0
0FCE:  RCALL  0C20
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
.................... 	BankSel(MAADR1); 
0FD0:  MOVLW  03
0FD2:  MOVLB  1
0FD4:  MOVWF  xA0
0FD6:  MOVLW  04
0FD8:  MOVWF  x9F
0FDA:  MOVLB  0
0FDC:  RCALL  0C7A
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0FDE:  MOVLW  04
0FE0:  MOVLB  1
0FE2:  MOVWF  xA2
0FE4:  MOVFF  1A,1A3
0FE8:  MOVLB  0
0FEA:  RCALL  0C20
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0FEC:  MOVLW  05
0FEE:  MOVLB  1
0FF0:  MOVWF  xA2
0FF2:  MOVFF  1B,1A3
0FF6:  MOVLB  0
0FF8:  RCALL  0C20
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0FFA:  MOVLW  02
0FFC:  MOVLB  1
0FFE:  MOVWF  xA2
1000:  MOVFF  1C,1A3
1004:  MOVLB  0
1006:  RCALL  0C20
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
1008:  MOVLW  03
100A:  MOVLB  1
100C:  MOVWF  xA2
100E:  MOVFF  1D,1A3
1012:  MOVLB  0
1014:  RCALL  0C20
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
1016:  MOVLB  1
1018:  CLRF   xA2
101A:  MOVFF  1E,1A3
101E:  MOVLB  0
1020:  RCALL  0C20
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
1022:  MOVLW  01
1024:  MOVLB  1
1026:  MOVWF  xA2
1028:  MOVFF  1F,1A3
102C:  MOVLB  0
102E:  RCALL  0C20
....................  
.................... 	// Get the Rev ID so that we can implement the correct errata workarounds 
.................... 	ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
1030:  MOVLW  12
1032:  MOVLB  1
1034:  MOVWF  x9C
1036:  MOVLB  0
1038:  RCALL  0BE0
103A:  MOVFF  01,57
....................  
.................... 	// Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
.................... 	// side effect. 
.................... 	WritePHYReg(PHCON2, PHCON2_HDLDIS); 
103E:  MOVLW  10
1040:  MOVLB  1
1042:  MOVWF  x25
1044:  MOVLW  01
1046:  MOVWF  x27
1048:  CLRF   x26
104A:  MOVLB  0
104C:  RCALL  0CE2
....................  
.................... 	// Configure LEDA to display LINK status, LEDB to display TX/RX activity 
.................... 	SetLEDConfig(0x0472); 
104E:  MOVLW  14
1050:  MOVLB  1
1052:  MOVWF  x25
1054:  MOVLW  04
1056:  MOVWF  x27
1058:  MOVLW  72
105A:  MOVWF  x26
105C:  MOVLB  0
105E:  RCALL  0CE2
....................  
.................... 	// Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
.................... 	MACSetDuplex(FULL);		// Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
.................... 	MACSetDuplex(HALF);		// Function exits with Bank 2 selected 
1060:  MOVLB  1
1062:  CLRF   x21
1064:  MOVLB  0
1066:  BRA    0E0E
.................... #else 
.................... 	// Use the external LEDB polarity to determine weather full or half duplex 
.................... 	// communication mode should be set. 
.................... 	MACSetDuplex(USE_PHY);	// Function exits with Bank 2 selected 
.................... #endif 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
1068:  MOVLW  1F
106A:  MOVLB  1
106C:  MOVWF  xA4
106E:  MOVLW  04
1070:  MOVWF  xA5
1072:  MOVLB  0
1074:  RCALL  0C5C
.................... }//end MACInit 
1076:  GOTO   115A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *						  and the link has been up continuously since the last 
....................  *						  call to MACIsLinked() 
....................  *					FALSE: If the PHY reports no link partner, or the link went 
....................  *						   down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
.................... 	// LLSTAT is a latching low link status bit.  Therefore, if the link 
.................... 	// goes down and comes back up before a higher level stack program calls 
.................... 	// MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
.................... 	// call to MACIsLinked() will return TRUE (unless the link goes down 
.................... 	// again). 
.................... 	return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
174A:  MOVLW  01
174C:  MOVLB  1
174E:  MOVWF  x26
1750:  MOVLB  0
1752:  CALL   0D74
1756:  MOVFF  01,126
175A:  MOVLW  00
175C:  MOVLB  1
175E:  BTFSC  01.2
1760:  MOVLW  01
1762:  MOVWF  01
.................... } 
1764:  MOVLB  0
1766:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *								  FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *					FALSE: If a previous transmission was started, and it has 
....................  *						   not completed yet.  While FALSE, the data in the 
....................  *						   transmit buffer and the TXST/TXND pointers must not 
....................  *						   be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
426A:  MOVLW  1F
426C:  MOVLB  1
426E:  MOVWF  x9C
4270:  MOVLB  0
4272:  CALL   0BE0
4276:  MOVFF  01,147
427A:  MOVLW  00
427C:  MOVLB  1
427E:  BTFSC  01.3
4280:  MOVLW  01
4282:  XORLW  00
4284:  BZ    428A
4286:  MOVLW  00
4288:  BRA    428C
428A:  MOVLW  01
428C:  MOVWF  01
428E:  BRA    4290
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
.................... 	// Check if the current buffer can be modified.  It cannot be modified if 
.................... 	// the TX hardware is currently transmitting it. 
.................... 	if(CurrentTxBuffer == LastTXedBuffer) 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
.................... 	} 
....................  
.................... 	// Check if a buffer is available for a new packet 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			return TRUE; 
.................... 		} 
.................... 	} 
....................  
.................... 	return FALSE; 
.................... #endif 
.................... } 
4290:  MOVLB  0
4292:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 		return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
30C6:  MOVLW  1F
30C8:  MOVLB  1
30CA:  MOVWF  x9C
30CC:  MOVLB  0
30CE:  CALL   0BE0
30D2:  MOVFF  01,17C
30D6:  MOVLW  00
30D8:  MOVLB  1
30DA:  BTFSC  01.3
30DC:  MOVLW  01
30DE:  XORLW  00
30E0:  BNZ   30E6
30E2:  MOVLW  00
30E4:  BRA    30E8
30E6:  MOVLW  FF
30E8:  MOVWF  01
30EA:  BRA    30EC
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Find a free buffer.  Do not use buffer 0, it is reserved for 
.................... 	// high priority messages that don't need to be acknowledged 
.................... 	// before being discarded (TCP control packets, all ICMP 
.................... 	// packets, all UDP packets, etc.) 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		// If this buffer is free, then mark it as used and return with it 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			TxBuffers[i].Flags.bFree = FALSE; 
.................... 			TxBuffers[i].Flags.bTransmitted = FALSE; 
.................... 			return i; 
.................... 		} 
.................... 	} 
....................  
.................... 	return INVALID_BUFFER; 
.................... #endif 
.................... } 
30EC:  MOVLB  0
30EE:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
.................... 	{ 
.................... 	    TxBuffers[buffer].Flags.bFree = TRUE; 
.................... 	    CurrentTxBuffer = buffer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *					MACGetHeader())as being processed and frees the buffer 
....................  *					memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
.................... 	WORD_VAL NewRXRDLocation; 
....................  
.................... 	// Make sure the current packet was not already discarded 
.................... 	if( WasDiscarded ) 
*
2CF4:  BTFSS  56.0
2CF6:  BRA    2CFA
.................... 		return; 
2CF8:  BRA    2D5E
.................... 	WasDiscarded = TRUE; 
2CFA:  BSF    56.0
....................  
.................... 	// Decrement the next packet pointer before writing it into 
.................... 	// the ERXRDPT registers.  This is a silicon errata workaround. 
.................... 	// RX buffer wrapping must be taken into account if the 
.................... 	// NextPacketLocation is precisely RXSTART. 
.................... 	NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
2CFC:  MOVLW  01
2CFE:  SUBWF  52,W
2D00:  MOVLB  1
2D02:  MOVWF  x51
2D04:  MOVLW  00
2D06:  SUBWFB 53,W
2D08:  MOVWF  x52
.................... #if RXSTART == 0 
.................... 	if(NewRXRDLocation.Val > RXSTOP) 
2D0A:  MOVF   x52,W
2D0C:  SUBLW  1A
2D0E:  BC    2D22
2D10:  XORLW  FF
2D12:  BNZ   2D1A
2D14:  MOVF   x51,W
2D16:  SUBLW  F7
2D18:  BC    2D22
.................... #else 
.................... 	if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		NewRXRDLocation.Val = RXSTOP; 
2D1A:  MOVLW  1B
2D1C:  MOVWF  x52
2D1E:  MOVLW  F7
2D20:  MOVWF  x51
.................... 	} 
....................  
.................... 	// Decrement the RX packet counter register, EPKTCNT 
.................... 	BFSReg(ECON2, ECON2_PKTDEC); 
2D22:  MOVLW  1E
2D24:  MOVWF  xA4
2D26:  MOVLW  40
2D28:  MOVWF  xA5
2D2A:  MOVLB  0
2D2C:  CALL   0C5C
....................  
.................... 	// Move the receive read pointer to unwrite-protect the memory used by the 
.................... 	// last packet.  The writing order is important: set the low byte first, 
.................... 	// high byte last. 
.................... 	BankSel(ERXRDPTL); 
2D30:  MOVLB  1
2D32:  CLRF   xA0
2D34:  MOVLW  0C
2D36:  MOVWF  x9F
2D38:  MOVLB  0
2D3A:  CALL   0C7A
.................... 	WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
2D3E:  MOVLW  0C
2D40:  MOVLB  1
2D42:  MOVWF  xA2
2D44:  MOVFF  151,1A3
2D48:  MOVLB  0
2D4A:  CALL   0C20
.................... 	WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
2D4E:  MOVLW  0D
2D50:  MOVLB  1
2D52:  MOVWF  xA2
2D54:  MOVFF  152,1A3
2D58:  MOVLB  0
2D5A:  CALL   0C20
.................... } 
2D5E:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *					the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
.................... 	WORD_VAL ReadPT, WritePT; 
....................  
.................... 	// Read the Ethernet hardware buffer write pointer.  Because packets can be 
.................... 	// received at any time, it can change between reading the low and high 
.................... 	// bytes.  A loop is necessary to make certain a proper low/high byte pair 
.................... 	// is read. 
.................... 	BankSel(EPKTCNT); 
.................... 	do { 
.................... 		// Save EPKTCNT in a temporary location 
.................... 		ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
....................  
.................... 		BankSel(ERXWRPTL); 
.................... 		WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
.................... 		WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
....................  
.................... 		BankSel(EPKTCNT); 
.................... 	} while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
....................  
.................... 	// Determine where the write protection pointer is 
.................... 	BankSel(ERXRDPTL); 
.................... 	ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
.................... 	ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
....................  
.................... 	// Calculate the difference between the pointers, taking care to account 
.................... 	// for buffer wrapping conditions 
.................... 	if ( WritePT.Val > ReadPT.Val ) 
.................... 	{ 
.................... 		return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
.................... 	} 
.................... 	else if ( WritePT.Val == ReadPT.Val ) 
.................... 	{ 
.................... 		return RXSIZE - 1; 
.................... 	} 
.................... 	else 
....................     { 
.................... 		return ReadPT.Val - WritePT.Val - 1; 
.................... 	} 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *							 received frame. 
....................  *					*type: Location of a BYTE to store the constant 
....................  *						   MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *						   the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *						  remote, and type values are updated. 
....................  *					FALSE: If a packet was not pending.  remote and type are 
....................  *						   not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *					been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
.................... 	ENC_PREAMBLE header; 
....................  
.................... 	// Test if at least one packet has been received and is waiting 
.................... 	BankSel(EPKTCNT); 
*
2DDA:  MOVLW  01
2DDC:  MOVLB  1
2DDE:  MOVWF  xA0
2DE0:  MOVLW  19
2DE2:  MOVWF  x9F
2DE4:  MOVLB  0
2DE6:  CALL   0C7A
.................... 	if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
2DEA:  MOVLW  19
2DEC:  MOVLB  1
2DEE:  MOVWF  x9C
2DF0:  MOVLB  0
2DF2:  CALL   0BE0
2DF6:  MOVFF  01,13E
2DFA:  MOVLB  1
2DFC:  MOVF   x3E,F
2DFE:  BNZ   2E06
.................... 		return FALSE; 
2E00:  MOVLW  00
2E02:  MOVWF  01
2E04:  BRA    2F0A
....................  
.................... 	// Make absolutely certain that any previous packet was discarded 
.................... 	if(WasDiscarded == FALSE) 
2E06:  BTFSC  56.0
2E08:  BRA    2E16
.................... 	{ 
.................... 		MACDiscardRx(); 
2E0A:  MOVLB  0
2E0C:  RCALL  2CF4
.................... 		return FALSE; 
2E0E:  MOVLW  00
2E10:  MOVWF  01
2E12:  MOVLB  1
2E14:  BRA    2F0A
.................... 	} 
....................  
.................... 	// Save the location of this packet 
.................... 	CurrentPacketLocation.Val = NextPacketLocation.Val; 
2E16:  MOVFF  53,55
2E1A:  MOVFF  52,54
....................  
.................... 	// Set the SPI read pointer to the beginning of the next unprocessed packet 
.................... 	BankSel(ERDPTL); 
2E1E:  CLRF   xA0
2E20:  CLRF   x9F
2E22:  MOVLB  0
2E24:  CALL   0C7A
.................... 	WriteReg(ERDPTL, NextPacketLocation.v[0]); 
2E28:  MOVLB  1
2E2A:  CLRF   xA2
2E2C:  MOVFF  52,1A3
2E30:  MOVLB  0
2E32:  CALL   0C20
.................... 	WriteReg(ERDPTH, NextPacketLocation.v[1]); 
2E36:  MOVLW  01
2E38:  MOVLB  1
2E3A:  MOVWF  xA2
2E3C:  MOVFF  53,1A3
2E40:  MOVLB  0
2E42:  CALL   0C20
....................  
.................... 	// Obtain the MAC header from the Ethernet buffer 
.................... 	MACGetArray((BYTE*)&header, sizeof(header)); 
2E46:  MOVLW  01
2E48:  MOVLB  1
2E4A:  MOVWF  x3F
2E4C:  MOVLW  2A
2E4E:  MOVFF  13F,18A
2E52:  MOVWF  x89
2E54:  CLRF   x8C
2E56:  MOVLW  14
2E58:  MOVWF  x8B
2E5A:  MOVLB  0
2E5C:  RCALL  2D60
....................  
.................... 	// The EtherType field, like most items transmitted on the Ethernet medium 
.................... 	// are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
2E5E:  MOVFF  13D,19D
2E62:  MOVFF  13C,19C
2E66:  RCALL  2DC4
2E68:  MOVFF  02,13D
2E6C:  MOVFF  01,13C
....................  
.................... 	// Validate the data returned from the ENC28J60.  Random data corruption, 
.................... 	// such as if a single SPI bit error occurs while communicating or a 
.................... 	// momentary power glitch could cause this to occur in rare circumstances. 
.................... 	if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
.................... 	   header.StatusVector.bits.Zero || 
.................... 	   header.StatusVector.bits.CRCError || 
.................... 	   header.StatusVector.bits.ByteCount > 1518 || 
.................... 	   !header.StatusVector.bits.ReceiveOk) 
2E70:  MOVLB  1
2E72:  MOVF   x2B,W
2E74:  SUBLW  1A
2E76:  BC    2E82
2E78:  XORLW  FF
2E7A:  BNZ   2EAE
2E7C:  MOVF   x2A,W
2E7E:  SUBLW  F7
2E80:  BNC   2EAE
2E82:  MOVLW  01
2E84:  MOVWF  x3F
2E86:  MOVLW  2A
2E88:  MOVWF  FE9
2E8A:  MOVFF  13F,FEA
2E8E:  BTFSC  FEF.0
2E90:  BRA    2EAE
2E92:  BTFSC  x2F.7
2E94:  BRA    2EAE
2E96:  BTFSC  x2E.4
2E98:  BRA    2EAE
2E9A:  MOVF   x2D,W
2E9C:  SUBLW  04
2E9E:  BC    2EAA
2EA0:  XORLW  FF
2EA2:  BNZ   2EAE
2EA4:  MOVF   x2C,W
2EA6:  SUBLW  EE
2EA8:  BNC   2EAE
2EAA:  BTFSC  x2E.7
2EAC:  BRA    2EB0
.................... 	{ 
.................... 		//Reset(); 
....................       reset_cpu(); 
2EAE:  RESET
.................... 	} 
....................  
.................... 	// Save the location where the hardware will write the next packet to 
.................... 	NextPacketLocation.Val = header.NextPacketPointer; 
2EB0:  MOVFF  12B,53
2EB4:  MOVFF  12A,52
....................  
.................... 	// Return the Ethernet frame's Source MAC address field to the caller 
.................... 	// This parameter is useful for replying to requests without requiring an 
.................... 	// ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
2EB8:  MOVFF  126,13E
2EBC:  MOVFF  127,13F
2EC0:  MOVFF  127,FEA
2EC4:  MOVFF  126,FE9
2EC8:  MOVLW  01
2ECA:  MOVWF  FE2
2ECC:  MOVLW  36
2ECE:  MOVWF  FE1
2ED0:  MOVLW  06
2ED2:  MOVWF  01
2ED4:  MOVFF  FE6,FEE
2ED8:  DECFSZ 01,F
2EDA:  BRA    2ED4
....................  
.................... 	// Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
2EDC:  MOVFF  128,FE9
2EE0:  MOVFF  129,FEA
2EE4:  MOVLW  FF
2EE6:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................     	((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
2EE8:  MOVF   x3D,W
2EEA:  SUBLW  08
2EEC:  BNZ   2F04
2EEE:  MOVF   x3C,F
2EF0:  BZ    2EF8
2EF2:  MOVF   x3C,W
2EF4:  SUBLW  06
2EF6:  BNZ   2F04
....................     { 
....................     	*type = header.Type.v[0]; 
2EF8:  MOVFF  128,FE9
2EFC:  MOVFF  129,FEA
2F00:  MOVFF  13C,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
2F04:  BCF    56.0
.................... 	return TRUE; 
2F06:  MOVLW  01
2F08:  MOVWF  01
.................... } 
2F0A:  MOVLB  0
2F0C:  GOTO   5564 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *					                     BYTE type, 
....................  *                   					 WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  * 							 MAC address (6 bytes) 
....................  *					type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *						  value to write into the Ethernet header's type field. 
....................  *					dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *					advantagous to call this function immediately before 
....................  *					transmitting a packet rather than initially when the 
....................  *					packet is first created.  The order in which the packet 
....................  *					is constructed (header first or data first) is not 
....................  *					important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
.................... 	BankSel(EWRPTL); 
*
3206:  MOVLB  1
3208:  CLRF   xA0
320A:  MOVLW  02
320C:  MOVWF  x9F
320E:  MOVLB  0
3210:  CALL   0C7A
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
.................... 	TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
3214:  MOVLW  02
3216:  MOVLB  1
3218:  MOVWF  xA2
321A:  MOVLW  F8
321C:  MOVWF  xA3
321E:  MOVLB  0
3220:  CALL   0C20
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
3224:  MOVLW  03
3226:  MOVLB  1
3228:  MOVWF  xA2
322A:  MOVLW  1B
322C:  MOVWF  xA3
322E:  MOVLB  0
3230:  CALL   0C20
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
3234:  MOVLW  06
3236:  MOVLB  1
3238:  ADDWF  x9D,F
323A:  MOVLW  1C
323C:  ADDWFC x9E,F
....................  
.................... 	// Write the TXND pointer into the registers, given the dataLen given 
.................... 	WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
323E:  MOVLW  01
3240:  MOVWF  xA0
3242:  MOVLW  9D
3244:  MOVWF  FE9
3246:  MOVFF  1A0,FEA
324A:  MOVFF  FEF,1A1
324E:  MOVLW  06
3250:  MOVWF  xA2
3252:  MOVFF  1A1,1A3
3256:  MOVLB  0
3258:  CALL   0C20
.................... 	WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
325C:  MOVLW  01
325E:  MOVLB  1
3260:  MOVWF  xA0
3262:  MOVLW  9D
3264:  MOVWF  x9F
3266:  MOVLW  01
3268:  ADDWF  x9F,W
326A:  MOVWF  FE9
326C:  MOVLW  00
326E:  ADDWFC xA0,W
3270:  MOVWF  FEA
3272:  MOVFF  FEF,1A1
3276:  MOVLW  07
3278:  MOVWF  xA2
327A:  MOVFF  1A1,1A3
327E:  MOVLB  0
3280:  CALL   0C20
.................... #endif 
....................  
....................  
.................... 	// Set the per-packet control byte and write the Ethernet destination 
.................... 	// address 
.................... 	MACPut(0x00);	// Use default control configuration 
3284:  MOVLB  1
3286:  CLRF   xA0
3288:  MOVLB  0
328A:  RCALL  319A
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
328C:  MOVFF  19B,1A2
3290:  MOVFF  19A,1A1
3294:  MOVLB  1
3296:  CLRF   xA4
3298:  MOVLW  06
329A:  MOVWF  xA3
329C:  MOVLB  0
329E:  RCALL  31B8
....................  
.................... 	// Write our MAC address in the Ethernet source field 
.................... 	MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
32A0:  MOVLB  1
32A2:  CLRF   xA0
32A4:  MOVLW  1A
32A6:  MOVFF  1A0,1A2
32AA:  MOVWF  xA1
32AC:  CLRF   xA4
32AE:  MOVLW  06
32B0:  MOVWF  xA3
32B2:  MOVLB  0
32B4:  RCALL  31B8
....................  
.................... 	// Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
32B6:  MOVLW  08
32B8:  MOVLB  1
32BA:  MOVWF  xA0
32BC:  MOVLB  0
32BE:  RCALL  319A
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
32C0:  MOVLB  1
32C2:  MOVF   x9C,F
32C4:  BNZ   32CA
32C6:  MOVLW  00
32C8:  BRA    32CC
32CA:  MOVLW  06
32CC:  MOVWF  xA0
32CE:  MOVLB  0
32D0:  RCALL  319A
.................... } 
32D2:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *					MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *					the Ethernet medium.  The hardware MAC will take control 
....................  *					and handle CRC generation, collision retransmission and 
....................  *					other details. 
....................  * 
....................  * Note:			After transmission completes (MACIsTxReady() returns TRUE), 
....................  *					the packet can be modified and transmitted again by calling 
....................  *					MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *					called (in the TX data area), the data in the TX buffer 
....................  *					will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the packet start and end address pointers 
.................... 	BankSel(ETXSTL); 
.................... 	WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
.................... 	WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
.................... 	WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
.................... 	LastTXedBuffer = CurrentTxBuffer; 
.................... 	TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
.................... 	// Reset transmit logic if a TX Error has previously occured 
.................... 	// This is a silicon errata workaround 
.................... 	if(ReadETHReg(EIR).EIRbits.TXERIF) 
32D4:  MOVLW  1C
32D6:  MOVLB  1
32D8:  MOVWF  x9C
32DA:  MOVLB  0
32DC:  CALL   0BE0
32E0:  MOVFF  01,187
32E4:  MOVLW  00
32E6:  MOVLB  1
32E8:  BTFSC  01.1
32EA:  MOVLW  01
32EC:  XORLW  00
32EE:  BZ    3310
.................... 	{ 
.................... 		BFSReg(ECON1, ECON1_TXRST); 
32F0:  MOVLW  1F
32F2:  MOVWF  xA4
32F4:  MOVLW  80
32F6:  MOVWF  xA5
32F8:  MOVLB  0
32FA:  CALL   0C5C
.................... 		BFCReg(ECON1, ECON1_TXRST); 
32FE:  MOVLW  1F
3300:  MOVLB  1
3302:  MOVWF  xA1
3304:  MOVLW  80
3306:  MOVWF  xA2
3308:  MOVLB  0
330A:  CALL   0C3E
330E:  MOVLB  1
.................... 	} 
.................... 	BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
3310:  MOVLW  1C
3312:  MOVWF  xA1
3314:  MOVLW  0A
3316:  MOVWF  xA2
3318:  MOVLB  0
331A:  CALL   0C3E
....................  
.................... 	// Start the transmission 
.................... 	// After transmission completes (MACIsTxReady() returns TRUE), the packet 
.................... 	// can be modified and transmitted again by calling MACFlush() again. 
.................... 	// Until MACPutHeader() is called, the data in the TX buffer will not be 
.................... 	// corrupted. 
.................... 	BFSReg(ECON1, ECON1_TXRTS); 
331E:  MOVLW  1F
3320:  MOVLB  1
3322:  MOVWF  xA4
3324:  MOVLW  08
3326:  MOVWF  xA5
3328:  MOVLB  0
332A:  CALL   0C5C
....................  
.................... 	// Revision B5 silicon errata workaround 
.................... 	if(ENCRevID == 0x05) 
332E:  MOVF   57,W
3330:  SUBLW  05
3332:  BTFSS  FD8.2
3334:  BRA    34F6
.................... 	{ 
.................... 		while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
3336:  MOVLW  1C
3338:  MOVLB  1
333A:  MOVWF  x9C
333C:  MOVLB  0
333E:  CALL   0BE0
3342:  MOVFF  01,187
3346:  MOVLB  1
3348:  MOVF   01,W
334A:  ANDLW  0A
334C:  BTFSS  FD8.2
334E:  BRA    3354
3350:  MOVLB  0
3352:  BRA    3336
.................... 		if(ReadETHReg(EIR).EIRbits.TXERIF) 
3354:  MOVLW  1C
3356:  MOVWF  x9C
3358:  MOVLB  0
335A:  CALL   0BE0
335E:  MOVFF  01,187
3362:  MOVLW  00
3364:  MOVLB  1
3366:  BTFSC  01.1
3368:  MOVLW  01
336A:  XORLW  00
336C:  BTFSC  FD8.2
336E:  BRA    34F8
.................... 		{ 
.................... 			WORD_VAL ReadPtrSave; 
.................... 			WORD_VAL TXEnd; 
.................... 			TXSTATUS TXStatus; 
.................... 			BYTE i; 
....................  
.................... 			// Cancel the previous transmission if it has become stuck set 
.................... 			BFCReg(ECON1, ECON1_TXRTS); 
3370:  MOVLW  1F
3372:  MOVWF  xA1
3374:  MOVLW  08
3376:  MOVWF  xA2
3378:  MOVLB  0
337A:  CALL   0C3E
....................  
.................... 			// Save the current read pointer (controlled by application) 
.................... 			BankSel(ERDPTL); 
337E:  MOVLB  1
3380:  CLRF   xA0
3382:  CLRF   x9F
3384:  MOVLB  0
3386:  CALL   0C7A
.................... 			ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
338A:  MOVLB  1
338C:  CLRF   x9C
338E:  MOVLB  0
3390:  CALL   0BE0
3394:  MOVFF  01,17B
.................... 			ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
3398:  MOVLW  01
339A:  MOVLB  1
339C:  MOVWF  x9C
339E:  MOVLB  0
33A0:  CALL   0BE0
33A4:  MOVFF  01,17C
....................  
.................... 			// Get the location of the transmit status vector 
.................... 			TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
33A8:  MOVLW  06
33AA:  MOVLB  1
33AC:  MOVWF  x9C
33AE:  MOVLB  0
33B0:  CALL   0BE0
33B4:  MOVFF  01,17D
.................... 			TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
33B8:  MOVLW  07
33BA:  MOVLB  1
33BC:  MOVWF  x9C
33BE:  MOVLB  0
33C0:  CALL   0BE0
33C4:  MOVFF  01,17E
.................... 			TXEnd.Val++; 
33C8:  MOVLB  1
33CA:  INCF   x7D,F
33CC:  BTFSC  FD8.2
33CE:  INCF   x7E,F
....................  
.................... 			// Read the transmit status vector 
.................... 			WriteReg(ERDPTL, TXEnd.v[0]); 
33D0:  CLRF   xA2
33D2:  MOVFF  17D,1A3
33D6:  MOVLB  0
33D8:  CALL   0C20
.................... 			WriteReg(ERDPTH, TXEnd.v[1]); 
33DC:  MOVLW  01
33DE:  MOVLB  1
33E0:  MOVWF  xA2
33E2:  MOVFF  17E,1A3
33E6:  MOVLB  0
33E8:  CALL   0C20
.................... 			MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
33EC:  MOVLW  01
33EE:  MOVLB  1
33F0:  MOVWF  x88
33F2:  MOVLW  7F
33F4:  MOVFF  188,18A
33F8:  MOVWF  x89
33FA:  CLRF   x8C
33FC:  MOVLW  07
33FE:  MOVWF  x8B
3400:  MOVLB  0
3402:  RCALL  2D60
....................  
.................... 			// Implement retransmission if a late collision occured (this can 
.................... 			// happen on B5 when certain link pulses arrive at the same time 
.................... 			// as the transmission) 
.................... 			for(i = 0; i < 16; i++) 
3404:  MOVLB  1
3406:  CLRF   x86
3408:  MOVF   x86,W
340A:  SUBLW  0F
340C:  BNC   34DA
.................... 			{ 
.................... 				if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
340E:  MOVLW  1C
3410:  MOVWF  x9C
3412:  MOVLB  0
3414:  CALL   0BE0
3418:  MOVFF  01,187
341C:  MOVLW  00
341E:  MOVLB  1
3420:  BTFSC  01.1
3422:  MOVLW  01
3424:  XORLW  00
3426:  BZ    34D0
3428:  BTFSS  x82.5
342A:  BRA    34D0
.................... 				{ 
.................... 					// Reset the TX logic 
.................... 					BFSReg(ECON1, ECON1_TXRST); 
342C:  MOVLW  1F
342E:  MOVWF  xA4
3430:  MOVLW  80
3432:  MOVWF  xA5
3434:  MOVLB  0
3436:  CALL   0C5C
.................... 					BFCReg(ECON1, ECON1_TXRST); 
343A:  MOVLW  1F
343C:  MOVLB  1
343E:  MOVWF  xA1
3440:  MOVLW  80
3442:  MOVWF  xA2
3444:  MOVLB  0
3446:  CALL   0C3E
.................... 					BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
344A:  MOVLW  1C
344C:  MOVLB  1
344E:  MOVWF  xA1
3450:  MOVLW  0A
3452:  MOVWF  xA2
3454:  MOVLB  0
3456:  CALL   0C3E
....................  
.................... 					// Transmit the packet again 
.................... 					BFSReg(ECON1, ECON1_TXRTS); 
345A:  MOVLW  1F
345C:  MOVLB  1
345E:  MOVWF  xA4
3460:  MOVLW  08
3462:  MOVWF  xA5
3464:  MOVLB  0
3466:  CALL   0C5C
.................... 					while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
346A:  MOVLW  1C
346C:  MOVLB  1
346E:  MOVWF  x9C
3470:  MOVLB  0
3472:  CALL   0BE0
3476:  MOVFF  01,187
347A:  MOVLB  1
347C:  MOVF   01,W
347E:  ANDLW  0A
3480:  BTFSS  FD8.2
3482:  BRA    3488
3484:  MOVLB  0
3486:  BRA    346A
....................  
.................... 					// Cancel the previous transmission if it has become stuck set 
.................... 					BFCReg(ECON1, ECON1_TXRTS); 
3488:  MOVLW  1F
348A:  MOVWF  xA1
348C:  MOVLW  08
348E:  MOVWF  xA2
3490:  MOVLB  0
3492:  CALL   0C3E
....................  
.................... 					// Read transmit status vector 
.................... 					WriteReg(ERDPTL, TXEnd.v[0]); 
3496:  MOVLB  1
3498:  CLRF   xA2
349A:  MOVFF  17D,1A3
349E:  MOVLB  0
34A0:  CALL   0C20
.................... 					WriteReg(ERDPTH, TXEnd.v[1]); 
34A4:  MOVLW  01
34A6:  MOVLB  1
34A8:  MOVWF  xA2
34AA:  MOVFF  17E,1A3
34AE:  MOVLB  0
34B0:  CALL   0C20
.................... 					MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
34B4:  MOVLW  01
34B6:  MOVLB  1
34B8:  MOVWF  x88
34BA:  MOVLW  7F
34BC:  MOVFF  188,18A
34C0:  MOVWF  x89
34C2:  CLRF   x8C
34C4:  MOVLW  07
34C6:  MOVWF  x8B
34C8:  MOVLB  0
34CA:  RCALL  2D60
.................... 				} 
.................... 				else 
34CC:  BRA    34D4
34CE:  MOVLB  1
.................... 				{ 
.................... 					break; 
34D0:  BRA    34DA
34D2:  MOVLB  0
.................... 				} 
.................... 			} 
34D4:  MOVLB  1
34D6:  INCF   x86,F
34D8:  BRA    3408
....................  
.................... 			// Restore the current read pointer 
.................... 			WriteReg(ERDPTL, ReadPtrSave.v[0]); 
34DA:  CLRF   xA2
34DC:  MOVFF  17B,1A3
34E0:  MOVLB  0
34E2:  CALL   0C20
.................... 			WriteReg(ERDPTH, ReadPtrSave.v[1]); 
34E6:  MOVLW  01
34E8:  MOVLB  1
34EA:  MOVWF  xA2
34EC:  MOVFF  17C,1A3
34F0:  MOVLB  0
34F2:  CALL   0C20
34F6:  MOVLB  1
.................... 		} 
.................... 	} 
.................... } 
34F8:  MOVLB  0
34FA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *					getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			RXSTOP must be statically defined as being > RXSTART for 
....................  *					this function to work correctly.  In other words, do not 
....................  *					define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *					boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
.................... 	WORD_VAL ReadPT; 
....................  
.................... 	// Determine the address of the beginning of the entire packet 
.................... 	// and adjust the address to the desired location 
.................... 	ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
3820:  MOVLW  14
3822:  ADDWF  54,W
3824:  MOVLB  1
3826:  MOVWF  x4B
3828:  MOVLW  00
382A:  ADDWFC 55,W
382C:  MOVWF  x4C
382E:  MOVF   x47,W
3830:  ADDWF  x4B,W
3832:  MOVWF  x49
3834:  MOVF   x48,W
3836:  ADDWFC x4C,W
3838:  MOVWF  x4A
....................  
.................... 	// Since the receive buffer is circular, adjust if a wraparound is needed 
.................... 	if ( ReadPT.Val > RXSTOP ) 
383A:  MOVF   x4A,W
383C:  SUBLW  1A
383E:  BC    3852
3840:  XORLW  FF
3842:  BNZ   384A
3844:  MOVF   x49,W
3846:  SUBLW  F7
3848:  BC    3852
.................... 		ReadPT.Val -= RXSIZE; 
384A:  MOVLW  F8
384C:  SUBWF  x49,F
384E:  MOVLW  1B
3850:  SUBWFB x4A,F
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(ERDPTL); 
3852:  CLRF   xA0
3854:  CLRF   x9F
3856:  MOVLB  0
3858:  CALL   0C7A
.................... 	WriteReg(ERDPTL, ReadPT.v[0]); 
385C:  MOVLB  1
385E:  CLRF   xA2
3860:  MOVFF  149,1A3
3864:  MOVLB  0
3866:  CALL   0C20
.................... 	WriteReg(ERDPTH, ReadPT.v[1]); 
386A:  MOVLW  01
386C:  MOVLB  1
386E:  MOVWF  xA2
3870:  MOVFF  14A,1A3
3874:  MOVLB  0
3876:  CALL   0C20
.................... 	WriteReg(EWRPTL, ReadPT.v[0]); 
387A:  MOVLW  02
387C:  MOVLB  1
387E:  MOVWF  xA2
3880:  MOVFF  149,1A3
3884:  MOVLB  0
3886:  CALL   0C20
.................... 	WriteReg(EWRPTH, ReadPT.v[1]); 
388A:  MOVLW  03
388C:  MOVLB  1
388E:  MOVWF  xA2
3890:  MOVFF  14A,1A3
3894:  MOVLB  0
3896:  CALL   0C20
.................... } 
389A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *							within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *							parameter is not used. 
....................  *					offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
30F0:  MOVFF  196,4D
....................  
.................... 	// Calculate the proper address.  Since the TX memory area is not circular, 
.................... 	// no wrapparound checks are necessary. +1 adjustment is needed because of 
.................... 	// the per packet control byte which preceeds the packet in the TX memory 
.................... 	// area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
.................... 	offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
30F4:  MOVLW  07
30F6:  MOVLB  1
30F8:  ADDWF  x97,F
30FA:  MOVLW  1C
30FC:  ADDWFC x98,F
.................... #endif 
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(EWRPTL); 
30FE:  CLRF   xA0
3100:  MOVLW  02
3102:  MOVWF  x9F
3104:  MOVLB  0
3106:  CALL   0C7A
.................... 	WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
310A:  MOVLW  01
310C:  MOVLB  1
310E:  MOVWF  x9A
3110:  MOVLW  97
3112:  MOVWF  FE9
3114:  MOVFF  19A,FEA
3118:  MOVFF  FEF,19B
311C:  CLRF   xA2
311E:  MOVFF  19B,1A3
3122:  MOVLB  0
3124:  CALL   0C20
.................... 	WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
3128:  MOVLW  01
312A:  MOVLB  1
312C:  MOVWF  x9A
312E:  MOVLW  97
3130:  MOVWF  x99
3132:  MOVLW  01
3134:  ADDWF  x99,W
3136:  MOVWF  FE9
3138:  MOVLW  00
313A:  ADDWFC x9A,W
313C:  MOVWF  FEA
313E:  MOVFF  FEF,19B
3142:  MOVLW  01
3144:  MOVWF  xA2
3146:  MOVFF  19B,1A3
314A:  MOVLB  0
314C:  CALL   0C20
.................... 	WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
3150:  MOVLW  01
3152:  MOVLB  1
3154:  MOVWF  x9A
3156:  MOVLW  97
3158:  MOVWF  FE9
315A:  MOVFF  19A,FEA
315E:  MOVFF  FEF,19B
3162:  MOVLW  02
3164:  MOVWF  xA2
3166:  MOVFF  19B,1A3
316A:  MOVLB  0
316C:  CALL   0C20
.................... 	WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
3170:  MOVLW  01
3172:  MOVLB  1
3174:  MOVWF  x9A
3176:  MOVLW  97
3178:  MOVWF  x99
317A:  MOVLW  01
317C:  ADDWF  x99,W
317E:  MOVWF  FE9
3180:  MOVLW  00
3182:  ADDWFC x9A,W
3184:  MOVWF  FEA
3186:  MOVFF  FEF,19B
318A:  MOVLW  03
318C:  MOVWF  xA2
318E:  MOVFF  19B,1A3
3192:  MOVLB  0
3194:  CALL   0C20
.................... } 
3198:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Add the offset requested by firmware plus the Ethernet header 
.................... 	temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
3718:  MOVLW  14
371A:  ADDWF  54,W
371C:  MOVLB  1
371E:  MOVWF  x85
3720:  MOVLW  00
3722:  ADDWFC 55,W
3724:  MOVWF  x86
3726:  MOVF   x7F,W
3728:  ADDWF  x85,W
372A:  MOVWF  x83
372C:  MOVF   x80,W
372E:  ADDWFC x86,W
3730:  MOVWF  x84
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
3732:  MOVF   x84,W
3734:  SUBLW  1A
3736:  BC    374A
3738:  XORLW  FF
373A:  BNZ   3742
373C:  MOVF   x83,W
373E:  SUBLW  F7
3740:  BC    374A
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
3742:  MOVLW  F8
3744:  SUBWF  x83,F
3746:  MOVLW  1B
3748:  SUBWFB x84,F
.................... 	} 
....................  
.................... 	// Program the start address of the DMA 
.................... 	BankSel(EDMASTL); 
374A:  CLRF   xA0
374C:  MOVLW  10
374E:  MOVWF  x9F
3750:  MOVLB  0
3752:  CALL   0C7A
.................... 	WriteReg(EDMASTL, temp.v[0]); 
3756:  MOVLW  10
3758:  MOVLB  1
375A:  MOVWF  xA2
375C:  MOVFF  183,1A3
3760:  MOVLB  0
3762:  CALL   0C20
.................... 	WriteReg(EDMASTH, temp.v[1]); 
3766:  MOVLW  11
3768:  MOVLB  1
376A:  MOVWF  xA2
376C:  MOVFF  184,1A3
3770:  MOVLB  0
3772:  CALL   0C20
....................  
.................... 	// Calculate the end address, given the start address and len 
.................... 	temp.Val += len-1; 
3776:  MOVLW  01
3778:  MOVLB  1
377A:  SUBWF  x81,W
377C:  MOVWF  00
377E:  MOVLW  00
3780:  SUBWFB x82,W
3782:  MOVWF  03
3784:  MOVF   00,W
3786:  ADDWF  x83,F
3788:  MOVF   03,W
378A:  ADDWFC x84,F
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
378C:  MOVF   x84,W
378E:  SUBLW  1A
3790:  BC    37A4
3792:  XORLW  FF
3794:  BNZ   379C
3796:  MOVF   x83,W
3798:  SUBLW  F7
379A:  BC    37A4
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
379C:  MOVLW  F8
379E:  SUBWF  x83,F
37A0:  MOVLW  1B
37A2:  SUBWFB x84,F
.................... 	} 
....................  
.................... 	// Program the end address of the DMA 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
37A4:  MOVLW  12
37A6:  MOVWF  xA2
37A8:  MOVFF  183,1A3
37AC:  MOVLB  0
37AE:  CALL   0C20
.................... 	WriteReg(EDMANDH, temp.v[1]); 
37B2:  MOVLW  13
37B4:  MOVLB  1
37B6:  MOVWF  xA2
37B8:  MOVFF  184,1A3
37BC:  MOVLB  0
37BE:  CALL   0C20
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
37C2:  MOVLW  1F
37C4:  MOVLB  1
37C6:  MOVWF  xA4
37C8:  MOVLW  30
37CA:  MOVWF  xA5
37CC:  MOVLB  0
37CE:  CALL   0C5C
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
37D2:  MOVLW  1F
37D4:  MOVLB  1
37D6:  MOVWF  x9C
37D8:  MOVLB  0
37DA:  CALL   0BE0
37DE:  MOVFF  01,185
37E2:  MOVLW  00
37E4:  MOVLB  1
37E6:  BTFSC  01.5
37E8:  MOVLW  01
37EA:  XORLW  00
37EC:  BTFSC  FD8.2
37EE:  BRA    37F4
37F0:  MOVLB  0
37F2:  BRA    37D2
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
37F4:  MOVLW  16
37F6:  MOVWF  x9C
37F8:  MOVLB  0
37FA:  CALL   0BE0
37FE:  MOVFF  01,184
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
3802:  MOVLW  17
3804:  MOVLB  1
3806:  MOVWF  x9C
3808:  MOVLB  0
380A:  CALL   0BE0
380E:  MOVFF  01,183
.................... 	return temp.Val; 
3812:  MOVLB  1
3814:  MOVFF  183,01
3818:  MOVFF  184,02
.................... } 
381C:  MOVLB  0
381E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Program the start address of the DMA, after adjusting for the Ethernet 
.................... 	// header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
.................... #else 
.................... 	temp.Val = TXSTART + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
*
4294:  MOVLW  06
4296:  MOVLB  1
4298:  ADDWF  x96,W
429A:  MOVWF  x9C
429C:  MOVLW  1C
429E:  ADDWFC x97,W
42A0:  MOVWF  x9D
42A2:  MOVLW  01
42A4:  ADDWF  x9C,W
42A6:  MOVWF  x9A
42A8:  MOVLW  00
42AA:  ADDWFC x9D,W
42AC:  MOVWF  x9B
.................... #endif 
.................... 	BankSel(EDMASTL); 
42AE:  CLRF   xA0
42B0:  MOVLW  10
42B2:  MOVWF  x9F
42B4:  MOVLB  0
42B6:  CALL   0C7A
.................... 	WriteReg(EDMASTL, temp.v[0]); 
42BA:  MOVLW  10
42BC:  MOVLB  1
42BE:  MOVWF  xA2
42C0:  MOVFF  19A,1A3
42C4:  MOVLB  0
42C6:  CALL   0C20
.................... 	WriteReg(EDMASTH, temp.v[1]); 
42CA:  MOVLW  11
42CC:  MOVLB  1
42CE:  MOVWF  xA2
42D0:  MOVFF  19B,1A3
42D4:  MOVLB  0
42D6:  CALL   0C20
....................  
.................... 	// Program the end address of the DMA. 
.................... 	temp.Val += len-1; 
42DA:  MOVLW  01
42DC:  MOVLB  1
42DE:  SUBWF  x98,W
42E0:  MOVWF  00
42E2:  MOVLW  00
42E4:  SUBWFB x99,W
42E6:  MOVWF  03
42E8:  MOVF   00,W
42EA:  ADDWF  x9A,F
42EC:  MOVF   03,W
42EE:  ADDWFC x9B,F
.................... 	WriteReg(EDMANDL, temp.v[0]); 
42F0:  MOVLW  12
42F2:  MOVWF  xA2
42F4:  MOVFF  19A,1A3
42F8:  MOVLB  0
42FA:  CALL   0C20
.................... 	WriteReg(EDMANDH, temp.v[1]); 
42FE:  MOVLW  13
4300:  MOVLB  1
4302:  MOVWF  xA2
4304:  MOVFF  19B,1A3
4308:  MOVLB  0
430A:  CALL   0C20
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
430E:  MOVLW  1F
4310:  MOVLB  1
4312:  MOVWF  xA4
4314:  MOVLW  30
4316:  MOVWF  xA5
4318:  MOVLB  0
431A:  CALL   0C5C
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
431E:  MOVLW  1F
4320:  MOVLB  1
4322:  MOVWF  x9C
4324:  MOVLB  0
4326:  CALL   0BE0
432A:  MOVFF  01,19C
432E:  MOVLW  00
4330:  MOVLB  1
4332:  BTFSC  01.5
4334:  MOVLW  01
4336:  XORLW  00
4338:  BTFSC  FD8.2
433A:  BRA    4340
433C:  MOVLB  0
433E:  BRA    431E
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
4340:  MOVLW  16
4342:  MOVWF  x9C
4344:  MOVLB  0
4346:  CALL   0BE0
434A:  MOVFF  01,19B
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
434E:  MOVLW  17
4350:  MOVLB  1
4352:  MOVWF  x9C
4354:  MOVLB  0
4356:  CALL   0BE0
435A:  MOVFF  01,19A
.................... 	return temp.Val; 
435E:  MOVLB  1
4360:  MOVFF  19A,01
4364:  MOVFF  19B,02
.................... } 
4368:  MOVLB  0
436A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *						 The first byte included in the checksum is the byte 
....................  *						 pointed to by ERDPT, which is updated by calls to 
....................  *						 MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *					which can calculate the checksum faster than software, so 
....................  *					this function replaces the CaclIPBufferChecksum() function 
....................  *					defined in the helpers.c file.  Through the use of 
....................  *					preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *					buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Take care of special cases which the DMA cannot be used for 
.................... 	if(len == 0u) 
*
3B9A:  MOVLB  1
3B9C:  MOVF   x43,F
3B9E:  BNZ   3BAE
3BA0:  MOVF   x44,F
3BA2:  BNZ   3BAE
.................... 	{ 
.................... 		return 0xFFFF; 
3BA4:  MOVLW  FF
3BA6:  MOVWF  01
3BA8:  MOVWF  02
3BAA:  BRA    3CEE
.................... 	} 
.................... 	else if(len == 1u) 
3BAC:  BRA    3BDC
3BAE:  DECFSZ x43,W
3BB0:  BRA    3BDC
3BB2:  MOVF   x44,F
3BB4:  BNZ   3BDC
.................... 	{ 
.................... 		return ~(((WORD)MACGet())<<8); 
3BB6:  MOVLB  0
3BB8:  RCALL  3B6E
3BBA:  MOVLB  1
3BBC:  CLRF   x48
3BBE:  MOVFF  01,147
3BC2:  MOVFF  01,03
3BC6:  MOVLW  00
3BC8:  CLRF   00
3BCA:  DECF   00,F
3BCC:  XORWF  00,F
3BCE:  MOVLW  FF
3BD0:  XORWF  03,F
3BD2:  MOVFF  00,01
3BD6:  MOVFF  03,02
3BDA:  BRA    3CEE
.................... 	} 
....................  
....................  
.................... 	// Set the DMA starting address to the SPI read pointer value 
.................... 	BankSel(ERDPTL); 
3BDC:  CLRF   xA0
3BDE:  CLRF   x9F
3BE0:  MOVLB  0
3BE2:  CALL   0C7A
.................... 	temp.v[0] = ReadETHReg(ERDPTL).Val; 
3BE6:  MOVLB  1
3BE8:  CLRF   x9C
3BEA:  MOVLB  0
3BEC:  CALL   0BE0
3BF0:  MOVFF  01,145
.................... 	temp.v[1] = ReadETHReg(ERDPTH).Val; 
3BF4:  MOVLW  01
3BF6:  MOVLB  1
3BF8:  MOVWF  x9C
3BFA:  MOVLB  0
3BFC:  CALL   0BE0
3C00:  MOVFF  01,146
.................... 	WriteReg(EDMASTL, temp.v[0]); 
3C04:  MOVLW  10
3C06:  MOVLB  1
3C08:  MOVWF  xA2
3C0A:  MOVFF  145,1A3
3C0E:  MOVLB  0
3C10:  CALL   0C20
.................... 	WriteReg(EDMASTH, temp.v[1]); 
3C14:  MOVLW  11
3C16:  MOVLB  1
3C18:  MOVWF  xA2
3C1A:  MOVFF  146,1A3
3C1E:  MOVLB  0
3C20:  CALL   0C20
....................  
.................... 	// See if we are calculating a checksum within the RX buffer (where 
.................... 	// wrapping rules apply) or TX/unused area (where wrapping rules are 
.................... 	// not applied) 
.................... #if RXSTART == 0 
.................... 	if(temp.Val <= RXSTOP) 
3C24:  MOVLB  1
3C26:  MOVF   x46,W
3C28:  SUBLW  1B
3C2A:  BNC   3C62
3C2C:  BNZ   3C34
3C2E:  MOVF   x45,W
3C30:  SUBLW  F7
3C32:  BNC   3C62
.................... #else 
.................... 	if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		// Calculate the DMA ending address given the starting address and len 
.................... 		// parameter.  The DMA will follow the receive buffer wrapping boundary. 
.................... 		temp.Val += len-1; 
3C34:  MOVLW  01
3C36:  SUBWF  x43,W
3C38:  MOVWF  00
3C3A:  MOVLW  00
3C3C:  SUBWFB x44,W
3C3E:  MOVWF  03
3C40:  MOVF   00,W
3C42:  ADDWF  x45,F
3C44:  MOVF   03,W
3C46:  ADDWFC x46,F
.................... 		if(temp.Val > RXSTOP) 
3C48:  MOVF   x46,W
3C4A:  SUBLW  1A
3C4C:  BC    3C60
3C4E:  XORLW  FF
3C50:  BNZ   3C58
3C52:  MOVF   x45,W
3C54:  SUBLW  F7
3C56:  BC    3C60
.................... 		{ 
.................... 			temp.Val -= RXSIZE; 
3C58:  MOVLW  F8
3C5A:  SUBWF  x45,F
3C5C:  MOVLW  1B
3C5E:  SUBWFB x46,F
.................... 		} 
.................... 	} 
.................... 	else 
3C60:  BRA    3C76
.................... 	{ 
.................... 		temp.Val += len-1; 
3C62:  MOVLW  01
3C64:  SUBWF  x43,W
3C66:  MOVWF  00
3C68:  MOVLW  00
3C6A:  SUBWFB x44,W
3C6C:  MOVWF  03
3C6E:  MOVF   00,W
3C70:  ADDWF  x45,F
3C72:  MOVF   03,W
3C74:  ADDWFC x46,F
.................... 	} 
....................  
.................... 	// Write the DMA end address 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
3C76:  MOVLW  12
3C78:  MOVWF  xA2
3C7A:  MOVFF  145,1A3
3C7E:  MOVLB  0
3C80:  CALL   0C20
.................... 	WriteReg(EDMANDH, temp.v[1]); 
3C84:  MOVLW  13
3C86:  MOVLB  1
3C88:  MOVWF  xA2
3C8A:  MOVFF  146,1A3
3C8E:  MOVLB  0
3C90:  CALL   0C20
....................  
.................... 	// Begin the DMA checksum calculation and wait until it is finished 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
3C94:  MOVLW  1F
3C96:  MOVLB  1
3C98:  MOVWF  xA4
3C9A:  MOVLW  30
3C9C:  MOVWF  xA5
3C9E:  MOVLB  0
3CA0:  CALL   0C5C
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
3CA4:  MOVLW  1F
3CA6:  MOVLB  1
3CA8:  MOVWF  x9C
3CAA:  MOVLB  0
3CAC:  CALL   0BE0
3CB0:  MOVFF  01,147
3CB4:  MOVLW  00
3CB6:  MOVLB  1
3CB8:  BTFSC  01.5
3CBA:  MOVLW  01
3CBC:  XORLW  00
3CBE:  BTFSC  FD8.2
3CC0:  BRA    3CC6
3CC2:  MOVLB  0
3CC4:  BRA    3CA4
....................  
.................... 	// Return the resulting good stuff 
.................... 	temp.v[0] = ReadETHReg(EDMACSL).Val; 
3CC6:  MOVLW  16
3CC8:  MOVWF  x9C
3CCA:  MOVLB  0
3CCC:  CALL   0BE0
3CD0:  MOVFF  01,145
.................... 	temp.v[1] = ReadETHReg(EDMACSH).Val; 
3CD4:  MOVLW  17
3CD6:  MOVLB  1
3CD8:  MOVWF  x9C
3CDA:  MOVLB  0
3CDC:  CALL   0BE0
3CE0:  MOVFF  01,146
.................... 	return temp.Val; 
3CE4:  MOVLB  1
3CE6:  MOVFF  145,01
3CEA:  MOVFF  146,02
.................... } 
3CEE:  MOVLB  0
3CF0:  GOTO   3FF8 (RETURN)
.................... #endif	// End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  * 							  destination MAC address) to copy from. 
....................  *					TxOffset: Offset in the TX buffer (0=first byte of 
....................  *							  destination MAC address) to copy to. 
....................  *					len:	  Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *					set), the hardware will wait until it is finished.  Then, 
....................  *					the DMA module will copy the data from the receive buffer 
....................  *					to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	BankSel(EDMASTL); 
.................... 	WriteReg(EDMASTL, temp.v[0]); 
.................... 	WriteReg(EDMASTH, temp.v[1]); 
....................  
.................... 	temp.Val += len-1; 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	WriteReg(EDMANDL, temp.v[0]); 
.................... 	WriteReg(EDMANDH, temp.v[1]); 
....................  
.................... 	TxOffset += TXSTART+1; 
.................... 	WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
.................... 	WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
.................... 	// Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
.................... 	// before starting the copy. 
.................... 	BFCReg(ECON1, ECON1_CSUMEN); 
.................... 	BFSReg(ECON1, ECON1_DMAST); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *										BYTE *PatternMask, 
....................  *										WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *					*PatternMask: Pointer to an 8 byte pattern mask which 
....................  *								  defines which bytes of the pattern are 
....................  *								  important.  At least one bit must be set. 
....................  *					PatternOffset: Offset from the beginning of the Ethernet 
....................  *								   frame (1st byte of destination address), to 
....................  *								   begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *					CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *					subset of the broadcast packets which are normally 
....................  *					received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
.................... 					BYTE *PatternMask, 
.................... 					WORD PatternOffset) 
.................... { 
.................... 	WORD_VAL i; 
.................... 	BYTE *MaskPtr; 
.................... 	BYTE UnmaskedPatternLen; 
....................  
.................... 	// Set the SPI write pointer and DMA startting address to the beginning of 
.................... 	// the transmit buffer 
.................... 	BankSel(EWRPTL); 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
.................... 	WriteReg(EDMASTL, LOW(TXSTART)); 
.................... 	WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
.................... 	// Fill the transmit buffer with the pattern to match against.  Only the 
.................... 	// bytes which have a mask bit of 1 are written into the buffer and will 
.................... 	// subsequently be used for checksum computation. 
.................... 	MaskPtr = PatternMask; 
.................... 	for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
.................... 	{ 
.................... 		if( *MaskPtr & i.v[1] ) 
.................... 		{ 
.................... 			MACPut(*Pattern); 
.................... 			UnmaskedPatternLen++; 
.................... 		} 
.................... 		Pattern++; 
....................  
.................... 		i.v[1] <<= 1; 
.................... 		if( i.v[1] == 0u ) 
.................... 		{ 
.................... 			i.v[1] = 0x01; 
.................... 			MaskPtr++; 
.................... 		} 
.................... 	} 
....................  
.................... 	// Calculate and set the DMA end address 
.................... 	i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
.................... 	WriteReg(EDMANDL, i.v[0]); 
.................... 	WriteReg(EDMANDH, i.v[1]); 
....................  
.................... 	// Calculate the checksum on the given pattern using the DMA module 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Make certain that the PM filter isn't enabled while it is 
.................... 	// being reconfigured. 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
.................... 	// Get the calculated DMA checksum and store it in the PM 
.................... 	// checksum registers 
.................... 	i.v[0] == ReadETHReg(EDMACSL).Val; 
.................... 	i.v[1] == ReadETHReg(EDMACSH).Val; 
.................... 	WriteReg(EPMCSL, i.v[0]); 
.................... 	WriteReg(EPMCSH, i.v[0]); 
....................  
.................... 	// Set the Pattern Match offset and 8 byte mask 
.................... 	WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
.................... 	WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
.................... 	for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
.................... 	{ 
.................... 		WriteReg(i.Val, *PatternMask++); 
.................... 	} 
....................  
.................... 	// Begin using the new Pattern Match filter instead of the 
.................... 	// broadcast filter 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *					filter (if enabled) and returns to the default filter 
....................  *					configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
.................... 	return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *					increments ERDPT so MACGet() can be called again.  The 
....................  *					increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
3B6E:  BCF    F95.1
3B70:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
3B72:  MOVLW  3A
3B74:  MOVLB  1
3B76:  MOVWF  xA7
3B78:  MOVLB  0
3B7A:  CALL   0BD0
....................    c=ENCSPIXfer(0); 
3B7E:  MOVLB  1
3B80:  CLRF   xA7
3B82:  MOVLB  0
3B84:  CALL   0BD0
3B88:  MOVFF  01,147
....................    SPIUnselectEthernet(); 
3B8C:  BCF    F95.1
3B8E:  BSF    F8C.1
....................    return(c); 
3B90:  MOVLB  1
3B92:  MOVFF  147,01
.................... }//end MACGet 
3B96:  MOVLB  0
3B98:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *					len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *					and places them into local memory.  With SPI burst support, 
....................  *					it performs much faster than multiple MACGet() calls. 
....................  *					ERDPT is incremented after each byte, following the same 
....................  *					rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	int16 i; 
....................  
.................... 	// Start the burst operation 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM;			// Send the Read Buffer Memory opcode. 
.................... 	i = 0; 
.................... 	val--; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Read the data 
.................... 	while(i<len) 
.................... 	{ 
.................... 		SSPBUF = 0;			// Send a dummy byte to receive a byte 
.................... 		i++; 
.................... 		val++; 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is received. 
.................... 		PIR1_SSPIF = 0; 
.................... 		*val = SSPBUF; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
2D60:  MOVLB  1
2D62:  CLRF   x8D
2D64:  CLRF   x8E
....................  
....................    SPISelectEthernet(); 
2D66:  BCF    F95.1
2D68:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
2D6A:  MOVLW  3A
2D6C:  MOVWF  xA7
2D6E:  MOVLB  0
2D70:  CALL   0BD0
....................    while(i<len) 
....................    { 
2D74:  MOVLB  1
2D76:  MOVF   x8E,W
2D78:  SUBWF  x8C,W
2D7A:  BNC   2DB4
2D7C:  BNZ   2D84
2D7E:  MOVF   x8B,W
2D80:  SUBWF  x8D,W
2D82:  BC    2DB4
....................       *val=ENCSPIXfer(0); 
2D84:  MOVFF  18A,03
2D88:  MOVFF  189,18F
2D8C:  MOVFF  18A,190
2D90:  CLRF   xA7
2D92:  MOVLB  0
2D94:  CALL   0BD0
2D98:  MOVFF  190,FEA
2D9C:  MOVFF  18F,FE9
2DA0:  MOVFF  01,FEF
....................       val++; 
2DA4:  MOVLB  1
2DA6:  INCF   x89,F
2DA8:  BTFSC  FD8.2
2DAA:  INCF   x8A,F
....................       i++; 
2DAC:  INCF   x8D,F
2DAE:  BTFSC  FD8.2
2DB0:  INCF   x8E,F
....................    } 
2DB2:  BRA    2D76
....................    SPIUnselectEthernet(); 
2DB4:  BCF    F95.1
2DB6:  BSF    F8C.1
....................  
....................    return(i); 
2DB8:  MOVFF  18D,01
2DBC:  MOVFF  18E,02
.................... }//end MACGetArray 
2DC0:  MOVLB  0
2DC2:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *					(8 bits) and data to write (8 bits) over the SPI. 
....................  *					EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the opcode and constant. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = val;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until byte is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
319A:  BCF    F95.1
319C:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
319E:  MOVLW  7A
31A0:  MOVLB  1
31A2:  MOVWF  xA7
31A4:  MOVLB  0
31A6:  CALL   0BD0
....................    ENCSPIXfer(val); 
31AA:  MOVFF  1A0,1A7
31AE:  CALL   0BD0
....................    SPIUnselectEthernet(); 
31B2:  BCF    F95.1
31B4:  BSF    F8C.1
.................... }//end MACPut 
31B6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *					len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *					ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *					calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	// Select the chip and send the proper opcode 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the Write Buffer Memory opcode 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Send the data 
.................... 	while(len) 
.................... 	{ 
.................... 		SSPBUF = *val;		// Start sending the byte 
.................... 		val++;				// Increment after writing to SSPBUF to increase speed 
.................... 		len--;				// Decrement after writing to SSPBUF to increase speed 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is transmitted 
.................... 		PIR1_SSPIF = 0; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
31B8:  BCF    F95.1
31BA:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
31BC:  MOVLW  7A
31BE:  MOVLB  1
31C0:  MOVWF  xA7
31C2:  MOVLB  0
31C4:  CALL   0BD0
....................    while(len--) 
....................    { 
31C8:  MOVLB  1
31CA:  MOVFF  1A4,03
31CE:  MOVF   xA3,W
31D0:  BTFSC  FD8.2
31D2:  DECF   xA4,F
31D4:  DECF   xA3,F
31D6:  IORWF  03,W
31D8:  BZ    31FE
....................       ENCSPIXfer(*val); 
31DA:  MOVFF  1A2,03
31DE:  MOVFF  1A1,FE9
31E2:  MOVFF  1A2,FEA
31E6:  MOVFF  FEF,1A5
31EA:  MOVFF  1A5,1A7
31EE:  MOVLB  0
31F0:  CALL   0BD0
....................       val++; 
31F4:  MOVLB  1
31F6:  INCF   xA1,F
31F8:  BTFSC  FD8.2
31FA:  INCF   xA2,F
....................    } 
31FC:  BRA    31CA
....................    SPIUnselectEthernet(); 
31FE:  BCF    F95.1
3200:  BSF    F8C.1
.................... }//end MACPutArray 
3202:  MOVLB  0
3204:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *					the Ethernet controller.  It resets all register contents 
....................  *					(except for ECOCON) and returns the device to the power 
....................  *					on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = SR; 
.................... 	while(!PIR1_SSPIF);		// Wait until the command is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0C0A:  BCF    F95.1
0C0C:  BCF    F8C.1
....................    ENCSPIXfer(SR); 
0C0E:  MOVLW  FF
0C10:  MOVLB  1
0C12:  MOVWF  xA7
0C14:  MOVLB  0
0C16:  RCALL  0BD0
....................    SPIUnselectEthernet(); 
0C18:  BCF    F95.1
0C1A:  BSF    F8C.1
.................... }//end SendSystemReset 
0C1C:  GOTO   0ED6 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *					the SPI and then retrives the register contents in the 
....................  *					next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *					registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	// Select the chip and send the Read Control Register opcode/address 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RCR | Address; 
....................  
.................... 	while(!PIR1_SSPIF);		// Wait until the opcode/address is transmitted 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents 
.................... 	while(!PIR1_SSPIF);		// Wait until the register is received 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
0BE0:  BCF    F95.1
0BE2:  BCF    F8C.1
....................    ENCSPIXfer(RCR | Address); 
0BE4:  MOVFF  19C,19E
0BE8:  MOVFF  19C,1A7
0BEC:  MOVLB  0
0BEE:  RCALL  0BD0
....................    c=ENCSPIXfer(0); 
0BF0:  MOVLB  1
0BF2:  CLRF   xA7
0BF4:  MOVLB  0
0BF6:  RCALL  0BD0
0BF8:  MOVFF  01,19D
....................    SPIUnselectEthernet(); 
0BFC:  BCF    F95.1
0BFE:  BSF    F8C.1
....................    return(c); 
0C00:  MOVLB  1
0C02:  MOVFF  19D,01
.................... }//end ReadETHReg 
0C06:  MOVLB  0
0C08:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *					as a dummy byte over the SPI and then retrives the 
....................  *					register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *					registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	SPISelectEthernet(); 
....................  
.................... 	SSPBUF = RCR | Address;	// Send the Read Control Register opcode and 
.................... 							//   address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send a dummy byte 
.................... 	while(!PIR1_SSPIF);		// Wait for the dummy byte to be transmitted 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send another dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
0CB0:  BCF    F95.1
0CB2:  BCF    F8C.1
....................  
....................    ENCSPIXfer(RCR | Address); 
0CB4:  MOVFF  129,12B
0CB8:  MOVFF  129,1A7
0CBC:  MOVLB  0
0CBE:  RCALL  0BD0
....................    ENCSPIXfer(0); 
0CC0:  MOVLB  1
0CC2:  CLRF   xA7
0CC4:  MOVLB  0
0CC6:  RCALL  0BD0
....................    c=ENCSPIXfer(0); 
0CC8:  MOVLB  1
0CCA:  CLRF   xA7
0CCC:  MOVLB  0
0CCE:  RCALL  0BD0
0CD0:  MOVFF  01,12A
....................  
....................    SPIUnselectEthernet(); 
0CD4:  BCF    F95.1
0CD6:  BSF    F8C.1
....................  
....................    return(c); 
0CD8:  MOVLB  1
0CDA:  MOVFF  12A,01
.................... }//end ReadMACReg 
0CDE:  MOVLB  0
0CE0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
.................... 	PHYREG Result; 
....................  
.................... 	// Set the right address and start the register read operation 
.................... 	BankSel(MIREGADR); 
*
0D74:  MOVLW  02
0D76:  MOVLB  1
0D78:  MOVWF  xA0
0D7A:  MOVLW  14
0D7C:  MOVWF  x9F
0D7E:  MOVLB  0
0D80:  RCALL  0C7A
.................... 	WriteReg(MIREGADR, Register); 
0D82:  MOVLW  14
0D84:  MOVLB  1
0D86:  MOVWF  xA2
0D88:  MOVFF  126,1A3
0D8C:  MOVLB  0
0D8E:  RCALL  0C20
.................... 	WriteReg(MICMD, MICMD_MIIRD); 
0D90:  MOVLW  12
0D92:  MOVLB  1
0D94:  MOVWF  xA2
0D96:  MOVLW  01
0D98:  MOVWF  xA3
0D9A:  MOVLB  0
0D9C:  RCALL  0C20
....................  
.................... 	// Loop to wait until the PHY register has been read through the MII 
.................... 	// This requires 10.24us 
.................... 	BankSel(MISTAT); 
0D9E:  MOVLW  03
0DA0:  MOVLB  1
0DA2:  MOVWF  xA0
0DA4:  MOVLW  0A
0DA6:  MOVWF  x9F
0DA8:  MOVLB  0
0DAA:  RCALL  0C7A
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0DAC:  MOVLW  0A
0DAE:  MOVLB  1
0DB0:  MOVWF  x29
0DB2:  MOVLB  0
0DB4:  RCALL  0CB0
0DB6:  MOVFF  01,129
0DBA:  MOVLW  00
0DBC:  MOVLB  1
0DBE:  BTFSC  01.0
0DC0:  MOVLW  01
0DC2:  XORLW  00
0DC4:  BTFSC  FD8.2
0DC6:  BRA    0DCC
0DC8:  MOVLB  0
0DCA:  BRA    0DAC
....................  
.................... 	// Stop reading 
.................... 	BankSel(MIREGADR); 
0DCC:  MOVLW  02
0DCE:  MOVWF  xA0
0DD0:  MOVLW  14
0DD2:  MOVWF  x9F
0DD4:  MOVLB  0
0DD6:  RCALL  0C7A
.................... 	WriteReg(MICMD, 0x00); 
0DD8:  MOVLW  12
0DDA:  MOVLB  1
0DDC:  MOVWF  xA2
0DDE:  CLRF   xA3
0DE0:  MOVLB  0
0DE2:  RCALL  0C20
....................  
.................... 	// Obtain results and return 
.................... 	Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
0DE4:  MOVLW  18
0DE6:  MOVLB  1
0DE8:  MOVWF  x29
0DEA:  MOVLB  0
0DEC:  RCALL  0CB0
0DEE:  MOVFF  01,127
.................... 	Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
0DF2:  MOVLW  19
0DF4:  MOVLB  1
0DF6:  MOVWF  x29
0DF8:  MOVLB  0
0DFA:  RCALL  0CB0
0DFC:  MOVFF  01,128
.................... 	return Result; 
0E00:  MOVLB  1
0E02:  MOVFF  127,01
0E06:  MOVFF  128,02
.................... }//end ReadPHYReg 
0E0A:  MOVLB  0
0E0C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *					  The top 3 bits must be 0. 
....................  *					Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *					SPI and then sends the data to write in the next 8 SPI 
....................  *					clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *					BFSReg() functions.  It is seperate to maximize speed. 
....................  *					Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *					can write to any ETH or MAC register.  Writing to PHY 
....................  *					registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WCR | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0C20:  BCF    F95.1
0C22:  BCF    F8C.1
....................    ENCSPIXfer(WCR | Address); 
0C24:  MOVLB  1
0C26:  MOVF   xA2,W
0C28:  IORLW  40
0C2A:  MOVWF  xA4
0C2C:  MOVWF  xA7
0C2E:  MOVLB  0
0C30:  RCALL  0BD0
....................    ENCSPIXfer(Data); 
0C32:  MOVFF  1A3,1A7
0C36:  RCALL  0BD0
....................    SPIUnselectEthernet(); 
0C38:  BCF    F95.1
0C3A:  BSF    F8C.1
.................... }//end WriteReg 
0C3C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFSReg() functions.  It is separate to maximize speed. 
....................  *					BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFC | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0C3E:  BCF    F95.1
0C40:  BCF    F8C.1
....................    ENCSPIXfer(BFC | Address); 
0C42:  MOVLB  1
0C44:  MOVF   xA1,W
0C46:  IORLW  A0
0C48:  MOVWF  xA3
0C4A:  MOVWF  xA7
0C4C:  MOVLB  0
0C4E:  RCALL  0BD0
....................    ENCSPIXfer(Data); 
0C50:  MOVFF  1A2,1A7
0C54:  RCALL  0BD0
....................    SPIUnselectEthernet(); 
0C56:  BCF    F95.1
0C58:  BSF    F8C.1
.................... }//end BFCReg 
0C5A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFCReg() functions.  It is separate to maximize speed. 
....................  *					BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFS | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0C5C:  BCF    F95.1
0C5E:  BCF    F8C.1
....................    ENCSPIXfer(BFS | Address); 
0C60:  MOVLB  1
0C62:  MOVF   xA4,W
0C64:  IORLW  80
0C66:  MOVWF  xA6
0C68:  MOVWF  xA7
0C6A:  MOVLB  0
0C6C:  RCALL  0BD0
....................    ENCSPIXfer(Data); 
0C6E:  MOVFF  1A5,1A7
0C72:  RCALL  0BD0
....................    SPIUnselectEthernet(); 
0C74:  BCF    F95.1
0C76:  BSF    F8C.1
.................... }//end BFSReg 
0C78:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *					16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
.................... 	// Write the register address 
.................... 	BankSel(MIREGADR); 
*
0CE2:  MOVLW  02
0CE4:  MOVLB  1
0CE6:  MOVWF  xA0
0CE8:  MOVLW  14
0CEA:  MOVWF  x9F
0CEC:  MOVLB  0
0CEE:  RCALL  0C7A
.................... 	WriteReg(MIREGADR, Register); 
0CF0:  MOVLW  14
0CF2:  MOVLB  1
0CF4:  MOVWF  xA2
0CF6:  MOVFF  125,1A3
0CFA:  MOVLB  0
0CFC:  RCALL  0C20
....................  
.................... 	// Write the data 
.................... 	// Order is important: write low byte first, high byte last 
.................... 	WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
0CFE:  MOVLW  01
0D00:  MOVLB  1
0D02:  MOVWF  x29
0D04:  MOVLW  26
0D06:  MOVWF  FE9
0D08:  MOVFF  129,FEA
0D0C:  MOVFF  FEF,12A
0D10:  MOVLW  16
0D12:  MOVWF  xA2
0D14:  MOVFF  12A,1A3
0D18:  MOVLB  0
0D1A:  RCALL  0C20
.................... 	WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0D1C:  MOVLW  01
0D1E:  MOVLB  1
0D20:  MOVWF  x29
0D22:  MOVLW  26
0D24:  MOVWF  x28
0D26:  MOVLW  01
0D28:  ADDWF  x28,W
0D2A:  MOVWF  FE9
0D2C:  MOVLW  00
0D2E:  ADDWFC x29,W
0D30:  MOVWF  FEA
0D32:  MOVFF  FEF,12A
0D36:  MOVLW  17
0D38:  MOVWF  xA2
0D3A:  MOVFF  12A,1A3
0D3E:  MOVLB  0
0D40:  RCALL  0C20
....................  
.................... 	// Wait until the PHY register has been written 
.................... 	BankSel(MISTAT); 
0D42:  MOVLW  03
0D44:  MOVLB  1
0D46:  MOVWF  xA0
0D48:  MOVLW  0A
0D4A:  MOVWF  x9F
0D4C:  MOVLB  0
0D4E:  RCALL  0C7A
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0D50:  MOVLW  0A
0D52:  MOVLB  1
0D54:  MOVWF  x29
0D56:  MOVLB  0
0D58:  RCALL  0CB0
0D5A:  MOVFF  01,128
0D5E:  MOVLW  00
0D60:  MOVLB  1
0D62:  BTFSC  01.0
0D64:  MOVLW  01
0D66:  XORLW  00
0D68:  BTFSC  FD8.2
0D6A:  BRA    0D70
0D6C:  MOVLB  0
0D6E:  BRA    0D50
.................... }//end WritePHYReg 
0D70:  MOVLB  0
0D72:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *					  select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *					changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
.................... 	BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0C7A:  MOVLW  1F
0C7C:  MOVLB  1
0C7E:  MOVWF  xA1
0C80:  MOVLW  03
0C82:  MOVWF  xA2
0C84:  MOVLB  0
0C86:  RCALL  0C3E
.................... 	BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
0C88:  MOVLW  01
0C8A:  MOVLB  1
0C8C:  MOVWF  xA2
0C8E:  MOVLW  9F
0C90:  MOVWF  xA1
0C92:  MOVLW  01
0C94:  ADDWF  xA1,W
0C96:  MOVWF  FE9
0C98:  MOVLW  00
0C9A:  ADDWFC xA2,W
0C9C:  MOVWF  FEA
0C9E:  MOVFF  FEF,1A3
0CA2:  MOVLW  1F
0CA4:  MOVWF  xA4
0CA6:  MOVFF  1A3,1A5
0CAA:  MOVLB  0
0CAC:  RCALL  0C5C
.................... }//end BankSel 
0CAE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *					FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *					RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *					entire dual port memory and calculate a checksum of the 
....................  *					data stored within.  Address and Random fill modes are 
....................  *					used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *					seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *					is running, additional confidence that the memory is 
....................  *					working can be obtained by calling TestMemory multiple 
....................  *					times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
.................... 	#define RANDOM_FILL		0b0000 
.................... 	#define ADDRESS_FILL	0b0100 
.................... 	#define PATTERN_SHIFT	0b1000 
....................  
.................... 	WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
.................... 	// Select Bank 0 and disable anything that could have been in progress 
.................... 	WriteReg(ECON1, 0x00); 
....................  
.................... 	// Set up necessary pointers for the DMA to calculate over the entire 
.................... 	// memory 
.................... 	WriteReg(EDMASTL, 0x00); 
.................... 	WriteReg(EDMASTH, 0x00); 
.................... 	WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
.................... 	// Enable Test Mode and do an Address Fill 
.................... 	BankSel(EBSTCON); 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 						 EBSTCON_BISTST | 
.................... 						 ADDRESS_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode before 
.................... 	// starting any DMA operations. 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
.................... 	// Compare the results 
.................... 	// 0xF807 should always be generated in Address fill mode 
.................... 	if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
.................... 		return FALSE; 
....................  
.................... 	// Seed the random number generator and begin another Random Fill test 
.................... 	// with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
.................... 	WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
.................... 	WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 					  EBSTCON_PSEL | 
.................... 					  EBSTCON_BISTST | 
.................... 					  RANDOM_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode since 
.................... 	// we won't be needing it anymore 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
.................... 	return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *						FULL: Set full duplex mode 
....................  *						HALF: Set half duplex mode 
....................  *						USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *								 PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *					operation, sets PHY up for full duplex operation, and 
....................  *					reenables RX logic.  The back-to-back inter-packet gap 
....................  *					register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *					function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
.................... 	REG Register; 
.................... 	PHYREG PhyReg; 
....................  
.................... 	// Disable receive logic and abort any packets currently being transmitted 
.................... 	BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0E0E:  MOVLW  1F
0E10:  MOVLB  1
0E12:  MOVWF  xA1
0E14:  MOVLW  0C
0E16:  MOVWF  xA2
0E18:  MOVLB  0
0E1A:  RCALL  0C3E
....................  
.................... 	// Set the PHY to the proper duplex mode 
.................... 	PhyReg = ReadPHYReg(PHCON1); 
0E1C:  MOVLB  1
0E1E:  CLRF   x26
0E20:  MOVLB  0
0E22:  RCALL  0D74
0E24:  MOVFF  02,124
0E28:  MOVFF  01,123
.................... 	if(DuplexState == USE_PHY) 
0E2C:  MOVLB  1
0E2E:  MOVF   x21,W
0E30:  SUBLW  02
0E32:  BNZ   0E3C
.................... 	{ 
.................... 		DuplexState = PhyReg.PHCON1bits.PDPXMD; 
0E34:  CLRF   x21
0E36:  BTFSC  x24.0
0E38:  INCF   x21,F
.................... 	} 
.................... 	else 
0E3A:  BRA    0E52
.................... 	{ 
.................... 		PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0E3C:  BCF    x24.0
0E3E:  BTFSC  x21.0
0E40:  BSF    x24.0
.................... 		WritePHYReg(PHCON1, PhyReg.Val); 
0E42:  CLRF   x25
0E44:  MOVFF  124,127
0E48:  MOVFF  123,126
0E4C:  MOVLB  0
0E4E:  RCALL  0CE2
0E50:  MOVLB  1
.................... 	} 
....................  
.................... 	// Set the MAC to the proper duplex mode 
.................... 	BankSel(MACON3); 
0E52:  MOVLW  02
0E54:  MOVWF  xA0
0E56:  MOVWF  x9F
0E58:  MOVLB  0
0E5A:  RCALL  0C7A
.................... 	Register = ReadMACReg(MACON3); 
0E5C:  MOVLW  02
0E5E:  MOVLB  1
0E60:  MOVWF  x29
0E62:  MOVLB  0
0E64:  RCALL  0CB0
0E66:  MOVFF  01,122
.................... 	Register.MACON3bits.FULDPX = DuplexState; 
0E6A:  MOVLB  1
0E6C:  BCF    x22.0
0E6E:  BTFSC  x21.0
0E70:  BSF    x22.0
.................... 	WriteReg(MACON3, Register.Val); 
0E72:  MOVLW  02
0E74:  MOVWF  xA2
0E76:  MOVFF  122,1A3
0E7A:  MOVLB  0
0E7C:  RCALL  0C20
....................  
.................... 	// Set the back-to-back inter-packet gap time to IEEE specified 
.................... 	// requirements.  The meaning of the MABBIPG value changes with the duplex 
.................... 	// state, so it must be updated in this function. 
.................... 	// In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
.................... 	WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
0E7E:  MOVLB  1
0E80:  MOVF   x21,F
0E82:  BZ    0E88
0E84:  MOVLW  15
0E86:  BRA    0E8A
0E88:  MOVLW  12
0E8A:  MOVWF  x25
0E8C:  MOVLW  04
0E8E:  MOVWF  xA2
0E90:  MOVFF  125,1A3
0E94:  MOVLB  0
0E96:  RCALL  0C20
....................  
.................... 	// Reenable receive logic 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
0E98:  MOVLW  1F
0E9A:  MOVLB  1
0E9C:  MOVWF  xA4
0E9E:  MOVLW  04
0EA0:  MOVWF  xA5
0EA2:  MOVLB  0
0EA4:  RCALL  0C5C
.................... }//end MACSetDuplex 
0EA6:  GOTO   1068 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *					sleep mode, no packets can be transmitted or received. 
....................  *					All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  * 					called, this function will block until it is it complete. 
....................  *					If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
.................... 	// Disable packet reception 
.................... 	BFCReg(ECON1, ECON1_RXEN); 
....................  
.................... 	// Make sure any last packet which was in-progress when RXEN was cleared 
.................... 	// is completed 
.................... 	while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
.................... 	// If a packet is being transmitted, wait for it to finish 
.................... 	while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
.................... 	// Enter sleep mode 
.................... 	BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *					after a previous call to MACPowerDown().  Calling this 
....................  *					function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *					you don't wait for the link to go up first.  MACIsLinked() 
....................  *					can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
.................... 	// Leave power down mode 
.................... 	BFCReg(ECON2, ECON2_PWRSV); 
....................  
.................... 	// Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
.................... 	// delay is required for the PHY module to return to an operational state. 
.................... 	while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *								0x01: Divide by 1 (25 MHz) 
....................  *								0x02: Divide by 2 (12.5 MHz) 
....................  *								0x03: Divide by 3 (8.333333 MHz) 
....................  *								0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *								0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *					The CLKOUT pin will beginning outputting the new frequency 
....................  *					immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *						   0x01: Divide by 1 (25 MHz) 
....................  *						   0x02: Divide by 2 (12.5 MHz) 
....................  *						   0x03: Divide by 3 (8.333333 MHz) 
....................  *						   0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *						   0x05: Divide by 8 (3.125 MHz) 
....................  *						   0x06: Reserved 
....................  *						   0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
*
4670:  MOVFF  133,58
....................    return(MACIsTxReady(TRUE)); 
4674:  MOVLW  01
4676:  MOVLB  1
4678:  MOVWF  x46
467A:  MOVLB  0
467C:  RCALL  426A
467E:  MOVF   01,W
.................... } 
4680:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
397C:  MOVLW  01
397E:  MOVLB  1
3980:  MOVWF  x45
3982:  MOVLW  30
3984:  MOVFF  145,18A
3988:  MOVWF  x89
398A:  CLRF   x8C
398C:  MOVLW  14
398E:  MOVWF  x8B
3990:  MOVLB  0
3992:  CALL   2D60
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
3996:  MOVLB  1
3998:  MOVF   x30,W
399A:  ANDLW  F0
399C:  SUBLW  40
399E:  BZ    39A6
....................     	return FALSE; 
39A0:  MOVLW  00
39A2:  MOVWF  01
39A4:  BRA    3A5E
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
39A6:  MOVF   x30,W
39A8:  ANDLW  0F
39AA:  MOVWF  00
39AC:  RLCF   00,W
39AE:  MOVLB  0
39B0:  MOVWF  x89
39B2:  RLCF   x89,F
39B4:  MOVLW  FC
39B6:  ANDWF  x89,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
39B8:  MOVLB  1
39BA:  CLRF   x80
39BC:  CLRF   x7F
39BE:  CLRF   x82
39C0:  MOVFF  89,181
39C4:  MOVLB  0
39C6:  RCALL  3718
39C8:  MOVFF  02,12F
39CC:  MOVFF  01,12E
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
39D0:  MOVLB  1
39D2:  CLRF   x48
39D4:  MOVFF  89,147
39D8:  MOVLB  0
39DA:  RCALL  3820
....................  
....................     if(CalcChecksum.Val) 
39DC:  MOVLB  1
39DE:  MOVF   x2E,W
39E0:  IORWF  x2F,W
39E2:  BZ    39EA
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
39E4:  MOVLW  00
39E6:  MOVWF  01
39E8:  BRA    3A5E
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
39EA:  MOVLW  01
39EC:  MOVWF  x97
39EE:  MOVLW  30
39F0:  MOVWF  x96
39F2:  MOVLB  0
39F4:  RCALL  389C
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
39F6:  MOVLB  1
39F8:  MOVF   x26,W
39FA:  IORWF  x27,W
39FC:  BZ    3A16
....................         localIP->Val    = header.DestAddress.Val; 
39FE:  MOVFF  126,FE9
3A02:  MOVFF  127,FEA
3A06:  MOVFF  140,FEF
3A0A:  MOVFF  141,FEC
3A0E:  MOVFF  142,FEC
3A12:  MOVFF  143,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
3A16:  MOVLW  06
3A18:  ADDWF  x28,W
3A1A:  MOVWF  FE9
3A1C:  MOVLW  00
3A1E:  ADDWFC x29,W
3A20:  MOVWF  FEA
3A22:  MOVFF  13C,FEF
3A26:  MOVFF  13D,FEC
3A2A:  MOVFF  13E,FEC
3A2E:  MOVFF  13F,FEC
....................     *protocol           = header.Protocol; 
3A32:  MOVFF  12A,FE9
3A36:  MOVFF  12B,FEA
3A3A:  MOVFF  139,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
3A3E:  MOVFF  12C,FE9
3A42:  MOVFF  12D,FEA
3A46:  MOVLB  0
3A48:  MOVF   x89,W
3A4A:  MOVLB  1
3A4C:  SUBWF  x32,W
3A4E:  MOVWF  00
3A50:  MOVLW  00
3A52:  SUBWFB x33,W
3A54:  MOVFF  00,FEF
3A58:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
3A5A:  MOVLW  01
3A5C:  MOVWF  01
.................... } 
3A5E:  MOVLB  0
3A60:  GOTO   55E0 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
436C:  MOVLW  14
436E:  MOVWF  x89
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
4370:  MOVLW  45
4372:  MOVLB  1
4374:  MOVWF  x82
....................     header.TypeOfService    = IP_SERVICE; 
4376:  CLRF   x83
....................     header.TotalLength      = sizeof(header) + len; 
4378:  MOVLW  14
437A:  ADDWF  x80,W
437C:  MOVWF  x84
437E:  MOVLW  00
4380:  ADDWFC x81,W
4382:  MOVWF  x85
....................     header.Identification   = ++_Identifier; 
4384:  MOVLB  0
4386:  INCF   x87,F
4388:  BTFSC  FD8.2
438A:  INCF   x88,F
438C:  MOVFF  88,187
4390:  MOVFF  87,186
....................     header.FragmentInfo     = 0; 
4394:  MOVLB  1
4396:  CLRF   x89
4398:  CLRF   x88
....................     header.TimeToLive       = MY_IP_TTL; 
439A:  MOVLW  64
439C:  MOVWF  x8A
....................     header.Protocol         = protocol; 
439E:  MOVFF  17F,18B
....................     header.HeaderChecksum   = 0; 
43A2:  CLRF   x8D
43A4:  CLRF   x8C
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
43A6:  MOVFF  19,191
43AA:  MOVFF  18,190
43AE:  MOVFF  17,18F
43B2:  MOVFF  16,18E
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
43B6:  MOVLW  06
43B8:  ADDWF  x7D,W
43BA:  MOVWF  FE9
43BC:  MOVLW  00
43BE:  ADDWFC x7E,W
43C0:  MOVWF  FEA
43C2:  MOVFF  FEF,00
43C6:  MOVFF  FEC,01
43CA:  MOVFF  FEC,02
43CE:  MOVFF  FEC,03
43D2:  MOVFF  03,195
43D6:  MOVFF  02,194
43DA:  MOVFF  01,193
43DE:  MOVFF  00,192
....................  
....................     SwapIPHeader(&header); 
43E2:  MOVLW  01
43E4:  MOVWF  x97
43E6:  MOVLW  82
43E8:  MOVWF  x96
43EA:  MOVLB  0
43EC:  CALL   389C
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
43F0:  MOVLB  1
43F2:  MOVFF  17D,01
43F6:  MOVFF  17E,03
43FA:  MOVFF  17D,196
43FE:  MOVFF  17E,197
4402:  MOVLW  14
4404:  ADDWF  x80,W
4406:  MOVWF  x98
4408:  MOVLW  00
440A:  ADDWFC x81,W
440C:  MOVWF  x99
440E:  MOVFF  17E,19B
4412:  MOVFF  17D,19A
4416:  CLRF   x9C
4418:  MOVWF  x9E
441A:  MOVFF  198,19D
441E:  MOVLB  0
4420:  CALL   3206
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
4424:  MOVLW  01
4426:  MOVLB  1
4428:  MOVWF  x97
442A:  MOVLW  82
442C:  MOVFF  197,1A2
4430:  MOVWF  xA1
4432:  CLRF   xA4
4434:  MOVLW  14
4436:  MOVWF  xA3
4438:  MOVLB  0
443A:  CALL   31B8
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
443E:  MOVLB  1
4440:  CLRF   x97
4442:  CLRF   x96
4444:  CLRF   x99
4446:  MOVLW  14
4448:  MOVWF  x98
444A:  MOVLB  0
444C:  RCALL  4294
444E:  MOVFF  02,18D
4452:  MOVFF  01,18C
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
4456:  MOVFF  4D,196
445A:  MOVLB  1
445C:  CLRF   x98
445E:  MOVLW  0A
4460:  MOVWF  x97
4462:  MOVLB  0
4464:  CALL   30F0
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
4468:  MOVLW  01
446A:  MOVLB  1
446C:  MOVWF  x97
446E:  MOVLW  8C
4470:  MOVFF  197,1A2
4474:  MOVWF  xA1
4476:  CLRF   xA4
4478:  MOVLW  02
447A:  MOVWF  xA3
447C:  MOVLB  0
447E:  CALL   31B8
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
4482:  MOVFF  4D,196
4486:  MOVLB  1
4488:  CLRF   x98
448A:  MOVLW  14
448C:  MOVWF  x97
448E:  MOVLB  0
4490:  CALL   30F0
.................... #endif 
....................  
....................     return 0x0; 
4494:  MOVLW  00
4496:  MOVWF  01
4498:  MOVWF  02
.................... } 
449A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
3B54:  MOVF   x89,W
3B56:  MOVLB  1
3B58:  ADDWF  x43,W
3B5A:  MOVWF  x45
3B5C:  MOVLW  00
3B5E:  ADDWFC x44,W
3B60:  MOVWF  x46
3B62:  MOVWF  x48
3B64:  MOVFF  145,147
3B68:  MOVLB  0
3B6A:  RCALL  3820
.................... } 
3B6C:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
389C:  MOVLW  02
389E:  MOVLB  1
38A0:  ADDWF  x96,W
38A2:  MOVWF  01
38A4:  MOVLW  00
38A6:  ADDWFC x97,W
38A8:  MOVWF  03
38AA:  MOVFF  01,198
38AE:  MOVWF  x99
38B0:  MOVLW  02
38B2:  ADDWF  x96,W
38B4:  MOVWF  FE9
38B6:  MOVLW  00
38B8:  ADDWFC x97,W
38BA:  MOVWF  FEA
38BC:  MOVFF  FEC,19B
38C0:  MOVF   FED,F
38C2:  MOVFF  FEF,19A
38C6:  MOVFF  19B,19D
38CA:  MOVFF  19A,19C
38CE:  MOVLB  0
38D0:  CALL   2DC4
38D4:  MOVFF  199,FEA
38D8:  MOVFF  198,FE9
38DC:  MOVFF  02,FEC
38E0:  MOVF   FED,F
38E2:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
38E6:  MOVLW  04
38E8:  MOVLB  1
38EA:  ADDWF  x96,W
38EC:  MOVWF  01
38EE:  MOVLW  00
38F0:  ADDWFC x97,W
38F2:  MOVWF  03
38F4:  MOVFF  01,198
38F8:  MOVWF  x99
38FA:  MOVLW  04
38FC:  ADDWF  x96,W
38FE:  MOVWF  FE9
3900:  MOVLW  00
3902:  ADDWFC x97,W
3904:  MOVWF  FEA
3906:  MOVFF  FEC,19B
390A:  MOVF   FED,F
390C:  MOVFF  FEF,19A
3910:  MOVFF  19B,19D
3914:  MOVFF  19A,19C
3918:  MOVLB  0
391A:  CALL   2DC4
391E:  MOVFF  199,FEA
3922:  MOVFF  198,FE9
3926:  MOVFF  02,FEC
392A:  MOVF   FED,F
392C:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
3930:  MOVLW  0A
3932:  MOVLB  1
3934:  ADDWF  x96,W
3936:  MOVWF  01
3938:  MOVLW  00
393A:  ADDWFC x97,W
393C:  MOVWF  03
393E:  MOVFF  01,198
3942:  MOVWF  x99
3944:  MOVLW  0A
3946:  ADDWF  x96,W
3948:  MOVWF  FE9
394A:  MOVLW  00
394C:  ADDWFC x97,W
394E:  MOVWF  FEA
3950:  MOVFF  FEC,19B
3954:  MOVF   FED,F
3956:  MOVFF  FEF,19A
395A:  MOVFF  19B,19D
395E:  MOVFF  19A,19C
3962:  MOVLB  0
3964:  CALL   2DC4
3968:  MOVFF  199,FEA
396C:  MOVFF  198,FE9
3970:  MOVFF  02,FEC
3974:  MOVF   FED,F
3976:  MOVFF  01,FEF
.................... } 
397A:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder		9/9/04	Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder		1/5/06	Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
4182:  MOVLW  01
4184:  MOVLB  1
4186:  MOVWF  x7F
4188:  MOVLW  32
418A:  MOVFF  17F,18A
418E:  MOVWF  x89
4190:  CLRF   x8C
4192:  MOVLW  08
4194:  MOVWF  x8B
4196:  MOVLB  0
4198:  CALL   2D60
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Calculate the checksum using the Microchip MAC's DMA module 
.................... 	// The checksum data includes the precomputed checksum in the 
.................... 	// header, so a valid packet will always have a checksum of 
.................... 	// 0x0000 if the packet is not disturbed. 
.................... 	ReceivedChecksum = 0x0000; 
419C:  MOVLB  1
419E:  CLRF   x7D
41A0:  CLRF   x7C
.................... 	CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
41A2:  MOVFF  12D,03
41A6:  MOVFF  12C,FE9
41AA:  MOVFF  12D,FEA
41AE:  MOVFF  FEF,17E
41B2:  CLRF   x80
41B4:  MOVLW  14
41B6:  MOVWF  x7F
41B8:  CLRF   x82
41BA:  MOVFF  17E,181
41BE:  MOVLB  0
41C0:  CALL   3718
41C4:  MOVFF  02,17B
41C8:  MOVFF  01,17A
.................... #endif 
....................  
.................... 	// Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
41CC:  MOVLB  1
41CE:  MOVFF  12C,FE9
41D2:  MOVFF  12D,FEA
41D6:  MOVLW  08
41D8:  SUBWF  FEF,W
41DA:  MOVWF  FEF
....................     MACGetArray(data, *len); 
41DC:  MOVFF  12D,03
41E0:  MOVFF  12C,FE9
41E4:  MOVFF  12D,FEA
41E8:  MOVFF  FEF,17E
41EC:  MOVFF  12B,18A
41F0:  MOVFF  12A,189
41F4:  CLRF   x8C
41F6:  MOVFF  17E,18B
41FA:  MOVLB  0
41FC:  CALL   2D60
....................  
....................  
.................... #if !defined(MCHP_MAC) 
.................... 	// Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
4200:  MOVLW  01
4202:  MOVLB  1
4204:  MOVWF  x7F
4206:  MOVLW  32
4208:  MOVWF  x7E
420A:  MOVLB  0
420C:  RCALL  40A2
....................  
....................     *code = packet.Type; 
420E:  MOVLB  1
4210:  MOVFF  128,FE9
4214:  MOVFF  129,FEA
4218:  MOVFF  132,FEF
....................     *id = packet.Identifier; 
421C:  MOVFF  12E,FE9
4220:  MOVFF  12F,FEA
4224:  MOVFF  137,FEC
4228:  MOVF   FED,F
422A:  MOVFF  136,FEF
....................     *seq = packet.SequenceNumber; 
422E:  MOVFF  130,FE9
4232:  MOVFF  131,FEA
4236:  MOVFF  139,FEC
423A:  MOVF   FED,F
423C:  MOVFF  138,FEF
....................  
....................     debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
4240:  MOVF   x7C,W
4242:  SUBWF  x7A,W
4244:  BNZ   424C
4246:  MOVF   x7D,W
4248:  SUBWF  x7B,W
424A:  BZ    4250
424C:  MOVLW  00
424E:  BRA    4250
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
4250:  MOVF   x7C,W
4252:  SUBWF  x7A,W
4254:  BNZ   425C
4256:  MOVF   x7D,W
4258:  SUBWF  x7B,W
425A:  BZ    4260
425C:  MOVLW  00
425E:  BRA    4262
4260:  MOVLW  01
4262:  MOVWF  01
.................... } 
4264:  MOVLB  0
4266:  GOTO   567C (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET	packet; 
....................     WORD ICMPLen; 
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
*
449C:  MOVLW  01
449E:  MOVLB  1
44A0:  MOVWF  x7B
44A2:  MOVLB  0
44A4:  CALL   30C6
44A8:  MOVFF  01,17A
....................  
.................... 	// Abort if there is no where in the Ethernet controller to 
.................... 	// store this packet. 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
44AC:  MOVLB  1
44AE:  INCFSZ x7A,W
44B0:  BRA    44B4
.................... 		return; 
44B2:  BRA    45A4
....................  
.................... 	IPSetTxBuffer(MyTxBuffer, 0); 
44B4:  MOVFF  17A,196
44B8:  CLRF   x98
44BA:  MOVLW  14
44BC:  MOVWF  x97
44BE:  MOVLB  0
44C0:  CALL   30F0
....................  
....................  
.................... 	ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
44C4:  CLRF   03
44C6:  MOVLB  1
44C8:  MOVF   x2B,W
44CA:  ADDLW  08
44CC:  MOVWF  x78
44CE:  MOVLW  00
44D0:  ADDWFC 03,W
44D2:  MOVWF  x79
....................  
....................     packet.Code             = 0; 
44D4:  CLRF   x31
....................     packet.Type             = code; 
44D6:  MOVFF  128,130
....................     packet.Checksum         = 0; 
44DA:  CLRF   x33
44DC:  CLRF   x32
....................     packet.Identifier       = id; 
44DE:  MOVFF  12D,135
44E2:  MOVFF  12C,134
....................     packet.SequenceNumber   = seq; 
44E6:  MOVFF  12F,137
44EA:  MOVFF  12E,136
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
44EE:  MOVLW  01
44F0:  MOVWF  FEA
44F2:  MOVLW  38
44F4:  MOVWF  FE9
44F6:  MOVFF  12A,FE2
44FA:  MOVFF  129,FE1
44FE:  MOVF   x2B,W
4500:  MOVWF  01
4502:  BZ    450C
4504:  MOVFF  FE6,FEE
4508:  DECFSZ 01,F
450A:  BRA    4504
....................  
....................     SwapICMPPacket(&packet); 
450C:  MOVLW  01
450E:  MOVWF  x7F
4510:  MOVLW  30
4512:  MOVWF  x7E
4514:  MOVLB  0
4516:  RCALL  40A2
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
4518:  MOVLW  08
451A:  MOVLB  1
451C:  ADDWF  x2B,W
451E:  CLRF   x7C
4520:  MOVWF  x7B
4522:  MOVFF  127,17E
4526:  MOVFF  126,17D
452A:  MOVLW  01
452C:  MOVWF  x7F
452E:  MOVFF  17C,181
4532:  MOVFF  17B,180
4536:  MOVLB  0
4538:  RCALL  436C
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
453A:  MOVLW  01
453C:  MOVLB  1
453E:  MOVWF  x7C
4540:  MOVLW  30
4542:  MOVFF  17C,1A2
4546:  MOVWF  xA1
4548:  MOVFF  179,1A4
454C:  MOVFF  178,1A3
4550:  MOVLB  0
4552:  CALL   31B8
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
.................... 	packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
4556:  MOVLB  1
4558:  CLRF   x97
455A:  MOVLW  14
455C:  MOVWF  x96
455E:  MOVFF  179,199
4562:  MOVFF  178,198
4566:  MOVLB  0
4568:  RCALL  4294
456A:  MOVFF  02,133
456E:  MOVFF  01,132
.................... 	IPSetTxBuffer(MyTxBuffer, 2); 
4572:  MOVFF  17A,196
4576:  MOVLB  1
4578:  CLRF   x98
457A:  MOVLW  16
457C:  MOVWF  x97
457E:  MOVLB  0
4580:  CALL   30F0
.................... 	MACPutArray((BYTE*)&packet.Checksum, 2); 
4584:  MOVLW  01
4586:  MOVLB  1
4588:  MOVWF  x7C
458A:  MOVLW  32
458C:  MOVFF  17C,1A2
4590:  MOVWF  xA1
4592:  CLRF   xA4
4594:  MOVLW  02
4596:  MOVWF  xA3
4598:  MOVLB  0
459A:  CALL   31B8
.................... #endif 
....................  
....................  
....................     MACFlush(); 
459E:  CALL   32D4
45A2:  MOVLB  1
.................... } 
45A4:  MOVLB  0
45A6:  GOTO   56D4 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
40A2:  MOVLW  04
40A4:  MOVLB  1
40A6:  ADDWF  x7E,W
40A8:  MOVWF  01
40AA:  MOVLW  00
40AC:  ADDWFC x7F,W
40AE:  MOVWF  03
40B0:  MOVFF  01,180
40B4:  MOVWF  x81
40B6:  MOVLW  04
40B8:  ADDWF  x7E,W
40BA:  MOVWF  FE9
40BC:  MOVLW  00
40BE:  ADDWFC x7F,W
40C0:  MOVWF  FEA
40C2:  MOVFF  FEC,183
40C6:  MOVF   FED,F
40C8:  MOVFF  FEF,182
40CC:  MOVFF  183,19D
40D0:  MOVFF  182,19C
40D4:  MOVLB  0
40D6:  CALL   2DC4
40DA:  MOVFF  181,FEA
40DE:  MOVFF  180,FE9
40E2:  MOVFF  02,FEC
40E6:  MOVF   FED,F
40E8:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
40EC:  MOVLW  06
40EE:  MOVLB  1
40F0:  ADDWF  x7E,W
40F2:  MOVWF  01
40F4:  MOVLW  00
40F6:  ADDWFC x7F,W
40F8:  MOVWF  03
40FA:  MOVFF  01,180
40FE:  MOVWF  x81
4100:  MOVLW  06
4102:  ADDWF  x7E,W
4104:  MOVWF  FE9
4106:  MOVLW  00
4108:  ADDWFC x7F,W
410A:  MOVWF  FEA
410C:  MOVFF  FEC,183
4110:  MOVF   FED,F
4112:  MOVFF  FEF,182
4116:  MOVFF  183,19D
411A:  MOVFF  182,19C
411E:  MOVLB  0
4120:  CALL   2DC4
4124:  MOVFF  181,FEA
4128:  MOVFF  180,FE9
412C:  MOVFF  02,FEC
4130:  MOVF   FED,F
4132:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
4136:  MOVLW  02
4138:  MOVLB  1
413A:  ADDWF  x7E,W
413C:  MOVWF  01
413E:  MOVLW  00
4140:  ADDWFC x7F,W
4142:  MOVWF  03
4144:  MOVFF  01,180
4148:  MOVWF  x81
414A:  MOVLW  02
414C:  ADDWF  x7E,W
414E:  MOVWF  FE9
4150:  MOVLW  00
4152:  ADDWFC x7F,W
4154:  MOVWF  FEA
4156:  MOVFF  FEC,183
415A:  MOVF   FED,F
415C:  MOVFF  FEF,182
4160:  MOVFF  183,19D
4164:  MOVFF  182,19C
4168:  MOVLB  0
416A:  CALL   2DC4
416E:  MOVFF  181,FEA
4172:  MOVFF  180,FE9
4176:  MOVFF  02,FEC
417A:  MOVF   FED,F
417C:  MOVFF  01,FEF
.................... } 
4180:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Darren Rook (CCS)     06/28/04 CCS Port now incorporates 2.20 fixes (above) 
....................  * Darren Rook (CCS)     06/29/04 UDPSocketInfo[] and FindMatching_UDP_Socket() 
....................  *                                no longer static. 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug 
....................  *                         when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets 
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would 
....................  *                         unintentionally keep the remote MAC 
....................  *                         address cached, even after calling 
....................  *                         UDPInit(), UDPClose(), or resetting 
....................  *                         the part without clearing all the 
....................  *                         PICmicro memory. 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
....................  
.................... #if !(STACK_USE_UDP) 
....................  #error do not include UDP.C/UDP.H if STACK_USE_UDP is set to FALSE 
.................... #endif 
....................  
.................... #define debug_udp 
.................... //#define debug_udp debug_printf 
....................  
.................... UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, NODE_INFO *remoteNode, IP_ADDR *localIP); 
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
1114:  MOVLB  1
1116:  CLRF   x20
1118:  MOVF   x20,W
111A:  SUBLW  01
111C:  BNC   112C
....................     { 
....................       UDPClose(s); 
111E:  MOVFF  120,133
1122:  MOVLB  0
1124:  RCALL  1096
....................     } 
1126:  MOVLB  1
1128:  INCF   x20,F
112A:  BRA    1118
.................... } 
112C:  MOVLB  0
112E:  GOTO   115E (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, broadcast node address is set. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A valid port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            This call must always have valid localPort 
....................  *                  value. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................  
....................     p = &UDPSocketInfo[0]; 
*
45AA:  MOVLB  1
45AC:  CLRF   x3B
45AE:  MOVLW  59
45B0:  MOVWF  x3A
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
45B2:  CLRF   x39
45B4:  MOVF   x39,W
45B6:  SUBLW  01
45B8:  BNC   4668
....................     { 
....................         if ( p->localPort == INVALID_UDP_PORT ) 
45BA:  MOVLW  0C
45BC:  ADDWF  x3A,W
45BE:  MOVWF  FE9
45C0:  MOVLW  00
45C2:  ADDWFC x3B,W
45C4:  MOVWF  FEA
45C6:  MOVFF  FEC,13D
45CA:  MOVF   FED,F
45CC:  MOVFF  FEF,13C
45D0:  MOVF   x3C,F
45D2:  BNZ   465C
45D4:  MOVF   x3D,F
45D6:  BNZ   465C
....................         { 
....................             p->localPort    = localPort; 
45D8:  MOVLW  0C
45DA:  ADDWF  x3A,W
45DC:  MOVWF  FE9
45DE:  MOVLW  00
45E0:  ADDWFC x3B,W
45E2:  MOVWF  FEA
45E4:  MOVFF  134,FEC
45E8:  MOVF   FED,F
45EA:  MOVFF  133,FEF
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if ( remoteNode ) 
45EE:  MOVF   x35,W
45F0:  IORWF  x36,W
45F2:  BZ    4618
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
45F4:  MOVFF  13A,13C
45F8:  MOVFF  13B,13D
45FC:  MOVFF  13B,FEA
4600:  MOVFF  13A,FE9
4604:  MOVFF  136,FE2
4608:  MOVFF  135,FE1
460C:  MOVLW  0A
460E:  MOVWF  01
4610:  MOVFF  FE6,FEE
4614:  DECFSZ 01,F
4616:  BRA    4610
....................             } 
....................             // else Set broadcast address - TO BE DONE */ 
....................  
....................  
....................             p->remotePort   = remotePort; 
4618:  MOVLW  0A
461A:  ADDWF  x3A,W
461C:  MOVWF  FE9
461E:  MOVLW  00
4620:  ADDWFC x3B,W
4622:  MOVWF  FEA
4624:  MOVFF  138,FEC
4628:  MOVF   FED,F
462A:  MOVFF  137,FEF
....................             p->TxCount      = 0; 
462E:  MOVLW  0E
4630:  ADDWF  x3A,W
4632:  MOVWF  FE9
4634:  MOVLW  00
4636:  ADDWFC x3B,W
4638:  MOVWF  FEA
463A:  CLRF   FEC
463C:  MOVF   FED,F
463E:  CLRF   FEF
....................             p->RxCount      = 0; 
4640:  MOVLW  10
4642:  ADDWF  x3A,W
4644:  MOVWF  FE9
4646:  MOVLW  00
4648:  ADDWFC x3B,W
464A:  MOVWF  FEA
464C:  CLRF   FEC
464E:  MOVF   FED,F
4650:  CLRF   FEF
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
4652:  MOVFF  139,58
....................             return s; 
4656:  MOVFF  139,01
465A:  BRA    466C
....................         } 
....................         p++; 
465C:  MOVLW  16
465E:  ADDWF  x3A,F
4660:  BTFSC  FD8.0
4662:  INCF   x3B,F
....................     } 
4664:  INCF   x39,F
4666:  BRA    45B4
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
4668:  MOVLW  FF
466A:  MOVWF  01
.................... } 
466C:  MOVLB  0
466E:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................     UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
*
1096:  MOVLB  1
1098:  MOVF   x33,W
109A:  MULLW  16
109C:  MOVF   FF3,W
109E:  CLRF   x35
10A0:  MOVWF  x34
10A2:  MOVLW  0C
10A4:  ADDWF  x34,W
10A6:  MOVWF  01
10A8:  MOVLW  00
10AA:  ADDWFC x35,W
10AC:  MOVWF  03
10AE:  MOVF   01,W
10B0:  ADDLW  59
10B2:  MOVWF  FE9
10B4:  MOVLW  00
10B6:  ADDWFC 03,W
10B8:  MOVWF  FEA
10BA:  CLRF   FEC
10BC:  MOVF   FED,F
10BE:  CLRF   FEF
....................    UDPSocketInfo[s].remoteNode.IPAddr.Val = 0x00000000; 
10C0:  MOVF   x33,W
10C2:  MULLW  16
10C4:  MOVF   FF3,W
10C6:  CLRF   x35
10C8:  MOVWF  x34
10CA:  MOVLW  06
10CC:  ADDWF  x34,F
10CE:  MOVLW  00
10D0:  ADDWFC x35,F
10D2:  MOVLW  59
10D4:  ADDWF  x34,W
10D6:  MOVWF  FE9
10D8:  MOVLW  00
10DA:  ADDWFC x35,W
10DC:  MOVWF  FEA
10DE:  MOVF   FEE,F
10E0:  MOVF   FEE,F
10E2:  CLRF   FEC
10E4:  MOVF   FED,F
10E6:  CLRF   FEF
10E8:  MOVF   FED,F
10EA:  CLRF   FEF
10EC:  MOVF   FED,F
10EE:  CLRF   FEF
....................     UDPSocketInfo[s].Flags.bFirstRead = FALSE; 
10F0:  MOVF   x33,W
10F2:  MULLW  16
10F4:  MOVF   FF3,W
10F6:  CLRF   x35
10F8:  MOVWF  x34
10FA:  MOVLW  15
10FC:  ADDWF  x34,F
10FE:  MOVLW  00
1100:  ADDWFC x35,F
1102:  MOVLW  59
1104:  ADDWF  x34,W
1106:  MOVWF  FE9
1108:  MOVLW  00
110A:  ADDWFC x35,W
110C:  MOVWF  FEA
110E:  BCF    FEF.0
.................... } 
1110:  MOVLB  0
1112:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................     UDP_SOCKET_INFO *p; 
....................     //WORD temp; 
....................     WORD tempOffset; 
....................     WORD tempCount; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
47D0:  MOVF   58,W
47D2:  MULLW  16
47D4:  MOVF   FF3,W
47D6:  CLRF   03
47D8:  ADDLW  59
47DA:  MOVWF  01
47DC:  MOVLW  00
47DE:  ADDWFC 03,F
47E0:  MOVFF  01,136
47E4:  MOVLB  1
47E6:  MOVFF  03,137
....................  
....................     tempCount=p->TxCount; 
47EA:  MOVLW  0E
47EC:  ADDWF  x36,W
47EE:  MOVWF  FE9
47F0:  MOVLW  00
47F2:  ADDWFC x37,W
47F4:  MOVWF  FEA
47F6:  MOVFF  FEC,03
47FA:  MOVF   FED,F
47FC:  MOVFF  FEF,13A
4800:  MOVFF  03,13B
....................  
....................     if ( tempCount == 0 ) 
4804:  MOVF   x3A,F
4806:  BNZ   4880
4808:  MOVF   x3B,F
480A:  BNZ   4880
....................     { 
....................         // This is the very first byte that is loaded in UDP buffer. 
....................         // Remember what transmit buffer we are loading, and 
....................         // start loading this and next bytes in data area of UDP packet. 
....................         p->TxBuffer = MACGetTxBuffer(TRUE); 
480C:  MOVLW  12
480E:  ADDWF  x36,W
4810:  MOVWF  01
4812:  MOVLW  00
4814:  ADDWFC x37,W
4816:  MOVWF  03
4818:  MOVFF  01,13C
481C:  MOVWF  x3D
481E:  MOVLW  01
4820:  MOVWF  x7B
4822:  MOVLB  0
4824:  CALL   30C6
4828:  MOVFF  13D,FEA
482C:  MOVFF  13C,FE9
4830:  MOVFF  01,FEF
....................  
....................       // Make sure that we received a TX buffer 
....................       if(p->TxBuffer == INVALID_BUFFER) 
4834:  MOVLW  12
4836:  MOVLB  1
4838:  ADDWF  x36,W
483A:  MOVWF  FE9
483C:  MOVLW  00
483E:  ADDWFC x37,W
4840:  MOVWF  FEA
4842:  INCFSZ FEF,W
4844:  BRA    484C
....................          return FALSE; 
4846:  MOVLW  00
4848:  MOVWF  01
484A:  BRA    4906
....................  
....................         IPSetTxBuffer(p->TxBuffer, sizeof(UDP_HEADER)); 
484C:  MOVLW  12
484E:  ADDWF  x36,W
4850:  MOVWF  FE9
4852:  MOVLW  00
4854:  ADDWFC x37,W
4856:  MOVWF  FEA
4858:  MOVFF  FEF,13C
485C:  MOVFF  13C,196
4860:  CLRF   x98
4862:  MOVLW  1C
4864:  MOVWF  x97
4866:  MOVLB  0
4868:  CALL   30F0
....................  
....................         p->TxOffset = 0; 
486C:  MOVLW  13
486E:  MOVLB  1
4870:  ADDWF  x36,W
4872:  MOVWF  FE9
4874:  MOVLW  00
4876:  ADDWFC x37,W
4878:  MOVWF  FEA
487A:  CLRF   FEC
487C:  MOVF   FED,F
487E:  CLRF   FEF
....................     } 
....................  
....................     tempOffset=p->TxOffset; 
4880:  MOVLW  13
4882:  ADDWF  x36,W
4884:  MOVWF  FE9
4886:  MOVLW  00
4888:  ADDWFC x37,W
488A:  MOVWF  FEA
488C:  MOVFF  FEC,03
4890:  MOVF   FED,F
4892:  MOVFF  FEF,138
4896:  MOVFF  03,139
....................  
....................    /*if (v>=0x20) 
....................       debug_udp("-%c", v); 
....................    else 
....................       debug_udp("-0x%X", v);*/ 
....................        
....................     // Load it. 
....................     MACPut(v); 
489A:  MOVFF  135,1A0
489E:  MOVLB  0
48A0:  CALL   319A
....................  
....................     // Keep track of number of bytes loaded. 
....................     // If total bytes fill up buffer, transmit it. 
....................     if (tempOffset >= tempCount) 
48A4:  MOVLB  1
48A6:  MOVF   x3B,W
48A8:  SUBWF  x39,W
48AA:  BNC   48BA
48AC:  BNZ   48B4
48AE:  MOVF   x3A,W
48B0:  SUBWF  x38,W
48B2:  BNC   48BA
....................     { 
....................       tempCount++; 
48B4:  INCF   x3A,F
48B6:  BTFSC  FD8.2
48B8:  INCF   x3B,F
....................     } 
....................     tempOffset++; 
48BA:  INCF   x38,F
48BC:  BTFSC  FD8.2
48BE:  INCF   x39,F
....................  
....................     /* //broken in ccs? 
....................     if ( p->TxOffset++ >= p->TxCount ) 
....................     { 
....................         p->TxCount++; 
....................         debug_udp("!"); 
....................     } 
....................     */ 
....................  
....................  
....................  
.................... #define SIZEOF_MAC_HEADER       (14) 
....................  
....................     // Depending on what communication media is used, allowable UDP 
....................     // data length will vary. 
.................... #if STACK_USE_SLIP 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - SIZEOF_MAC_HEADER - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) 
.................... #else 
.................... #define MAX_UDP_DATA  (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) ) 
.................... #endif 
....................  
....................    p->TxOffset = tempOffset; 
48C0:  MOVLW  13
48C2:  ADDWF  x36,W
48C4:  MOVWF  FE9
48C6:  MOVLW  00
48C8:  ADDWFC x37,W
48CA:  MOVWF  FEA
48CC:  MOVFF  139,FEC
48D0:  MOVF   FED,F
48D2:  MOVFF  138,FEF
....................  
....................     //temp = p->TxCount; 
....................     //if ( temp >= MAX_UDP_DATA ) 
....................     p->TxCount = tempCount; 
48D6:  MOVLW  0E
48D8:  ADDWF  x36,W
48DA:  MOVWF  FE9
48DC:  MOVLW  00
48DE:  ADDWFC x37,W
48E0:  MOVWF  FEA
48E2:  MOVFF  13B,FEC
48E6:  MOVF   FED,F
48E8:  MOVFF  13A,FEF
....................     if (tempCount >= MAX_UDP_DATA) 
48EC:  MOVF   x3B,W
48EE:  SUBLW  02
48F0:  BC    4902
48F2:  XORLW  FF
48F4:  BNZ   48FC
48F6:  MOVF   x3A,W
48F8:  SUBLW  E3
48FA:  BC    4902
....................     { 
....................         UDPFlush(); 
48FC:  MOVLB  0
48FE:  RCALL  4682
4900:  MOVLB  1
....................     } 
.................... #undef MAX_UDP_DATA 
....................  
....................  
....................     return TRUE; 
4902:  MOVLW  01
4904:  MOVWF  01
.................... } 
4906:  MOVLB  0
4908:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     // Wait for TX hardware to become available (finish transmitting 
....................     // any previous packet) 
....................     while( !IPIsTxReady(TRUE) ); 
*
4682:  MOVLW  01
4684:  MOVLB  1
4686:  MOVWF  x46
4688:  MOVLB  0
468A:  RCALL  426A
468C:  MOVF   01,F
468E:  BZ    4682
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
4690:  MOVF   58,W
4692:  MULLW  16
4694:  MOVF   FF3,W
4696:  CLRF   03
4698:  ADDLW  59
469A:  MOVWF  01
469C:  MOVLW  00
469E:  ADDWFC 03,F
46A0:  MOVFF  01,144
46A4:  MOVLB  1
46A6:  MOVFF  03,145
....................  
....................     debug_udp("\r\nUDP FLUSH - Sok:%U TxC:%LU SP:%LU DP:%LU ", 
....................          activeUDPSocket, 
....................          p->TxCount, 
....................          p->localPort, 
....................          p->remotePort 
....................       ); 
....................     debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          p->remoteNode.MACAddr.v[0], 
....................          p->remoteNode.MACAddr.v[1], 
....................          p->remoteNode.MACAddr.v[2], 
....................          p->remoteNode.MACAddr.v[3], 
....................          p->remoteNode.MACAddr.v[4], 
....................          p->remoteNode.MACAddr.v[5] 
....................       ); 
....................  
....................  
....................     h.SourcePort        = swaps(p->localPort); 
46AA:  MOVLW  0C
46AC:  ADDWF  x44,W
46AE:  MOVWF  FE9
46B0:  MOVLW  00
46B2:  ADDWFC x45,W
46B4:  MOVWF  FEA
46B6:  MOVFF  FEC,147
46BA:  MOVF   FED,F
46BC:  MOVFF  FEF,146
46C0:  MOVFF  147,19D
46C4:  MOVFF  146,19C
46C8:  MOVLB  0
46CA:  CALL   2DC4
46CE:  MOVFF  02,13D
46D2:  MOVFF  01,13C
....................     h.DestinationPort   = swaps(p->remotePort); 
46D6:  MOVLW  0A
46D8:  MOVLB  1
46DA:  ADDWF  x44,W
46DC:  MOVWF  FE9
46DE:  MOVLW  00
46E0:  ADDWFC x45,W
46E2:  MOVWF  FEA
46E4:  MOVFF  FEC,147
46E8:  MOVF   FED,F
46EA:  MOVFF  FEF,146
46EE:  MOVFF  147,19D
46F2:  MOVFF  146,19C
46F6:  MOVLB  0
46F8:  CALL   2DC4
46FC:  MOVFF  02,13F
4700:  MOVFF  01,13E
....................     h.Length            = (WORD)((WORD)p->TxCount + (WORD)sizeof(UDP_HEADER)); 
4704:  MOVLW  0E
4706:  MOVLB  1
4708:  ADDWF  x44,W
470A:  MOVWF  FE9
470C:  MOVLW  00
470E:  ADDWFC x45,W
4710:  MOVWF  FEA
4712:  MOVFF  FEC,147
4716:  MOVF   FED,F
4718:  MOVFF  FEF,146
471C:  MOVLW  08
471E:  ADDWF  x46,W
4720:  MOVWF  x40
4722:  MOVLW  00
4724:  ADDWFC x47,W
4726:  MOVWF  x41
....................     // Do not swap h.Length yet.  It is needed in IPPutHeader. 
....................     h.Checksum          = 0x0000; 
4728:  CLRF   x43
472A:  CLRF   x42
....................  
....................     IPSetTxBuffer(p->TxBuffer, 0); 
472C:  MOVLW  12
472E:  ADDWF  x44,W
4730:  MOVWF  FE9
4732:  MOVLW  00
4734:  ADDWFC x45,W
4736:  MOVWF  FEA
4738:  MOVFF  FEF,146
473C:  MOVFF  146,196
4740:  CLRF   x98
4742:  MOVLW  14
4744:  MOVWF  x97
4746:  MOVLB  0
4748:  CALL   30F0
....................  
....................     /* 
....................      * Load IP header. 
....................      */ 
....................  
....................     IPPutHeader( &p->remoteNode, 
....................                  IP_PROT_UDP, 
....................                  h.Length ); 
474C:  MOVLB  1
474E:  MOVFF  144,01
4752:  MOVFF  145,03
4756:  MOVFF  144,146
475A:  MOVFF  145,147
475E:  MOVFF  145,17E
4762:  MOVFF  144,17D
4766:  MOVLW  11
4768:  MOVWF  x7F
476A:  MOVFF  141,181
476E:  MOVFF  140,180
4772:  MOVLB  0
4774:  RCALL  436C
....................  
....................  
....................     // Now swap h.Length. 
....................     h.Length            = swaps(h.Length); 
4776:  MOVFF  141,19D
477A:  MOVFF  140,19C
477E:  CALL   2DC4
4782:  MOVFF  02,141
4786:  MOVFF  01,140
....................  
....................     // Now load UDP header. 
....................     IPPutArray((BYTE*)&h, sizeof(h)); 
478A:  MOVLW  01
478C:  MOVLB  1
478E:  MOVWF  x47
4790:  MOVLW  3C
4792:  MOVFF  147,1A2
4796:  MOVWF  xA1
4798:  CLRF   xA4
479A:  MOVLW  08
479C:  MOVWF  xA3
479E:  MOVLB  0
47A0:  CALL   31B8
....................  
....................      // Update checksum. 
....................      // TO BE IMPLEMENTED 
....................  
....................     MACFlush(); 
47A4:  CALL   32D4
....................  
....................     // The buffer was reserved with AutoFree, so we can immediately 
....................    // discard it.  The MAC layer will free it after transmission. 
....................     p->TxBuffer         = INVALID_BUFFER; 
47A8:  MOVLW  12
47AA:  MOVLB  1
47AC:  ADDWF  x44,W
47AE:  MOVWF  FE9
47B0:  MOVLW  00
47B2:  ADDWFC x45,W
47B4:  MOVWF  FEA
47B6:  MOVLW  FF
47B8:  MOVWF  FEF
....................     p->TxCount          = 0; 
47BA:  MOVLW  0E
47BC:  ADDWF  x44,W
47BE:  MOVWF  FE9
47C0:  MOVLW  00
47C2:  ADDWFC x45,W
47C4:  MOVWF  FEA
47C6:  CLRF   FEC
47C8:  MOVF   FED,F
47CA:  CLRF   FEF
....................  
.................... } 
47CC:  MOVLB  0
47CE:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
4AFE:  MOVFF  133,58
....................     return ( UDPSocketInfo[activeUDPSocket].RxCount > 0); 
4B02:  MOVF   58,W
4B04:  MULLW  16
4B06:  MOVF   FF3,W
4B08:  MOVLB  1
4B0A:  CLRF   x35
4B0C:  MOVWF  x34
4B0E:  MOVLW  10
4B10:  ADDWF  x34,W
4B12:  MOVWF  01
4B14:  MOVLW  00
4B16:  ADDWFC x35,W
4B18:  MOVWF  03
4B1A:  MOVF   01,W
4B1C:  ADDLW  59
4B1E:  MOVWF  FE9
4B20:  MOVLW  00
4B22:  ADDWFC 03,W
4B24:  MOVWF  FEA
4B26:  MOVFF  FEC,135
4B2A:  MOVF   FED,F
4B2C:  MOVFF  FEF,134
4B30:  MOVF   x34,F
4B32:  BNZ   4B3C
4B34:  MOVF   x35,F
4B36:  BNZ   4B3C
4B38:  MOVLW  00
4B3A:  BRA    4B3E
4B3C:  MOVLW  01
4B3E:  MOVWF  01
.................... } 
4B40:  MOVLB  0
4B42:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................     // CALLER MUST MAKE SURE THAT THERE IS ENOUGH DATA BYTE IN BUFFER 
....................     // BEFORE CALLING THIS FUNCTION. 
....................     // USE UDPIsGetReady() TO CONFIRM. 
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
4B44:  MOVF   58,W
4B46:  MULLW  16
4B48:  MOVF   FF3,W
4B4A:  MOVLB  1
4B4C:  CLRF   x3F
4B4E:  MOVWF  x3E
4B50:  MOVLW  10
4B52:  ADDWF  x3E,W
4B54:  MOVWF  01
4B56:  MOVLW  00
4B58:  ADDWFC x3F,W
4B5A:  MOVWF  03
4B5C:  MOVF   01,W
4B5E:  ADDLW  59
4B60:  MOVWF  FE9
4B62:  MOVLW  00
4B64:  ADDWFC 03,W
4B66:  MOVWF  FEA
4B68:  MOVFF  FEC,13F
4B6C:  MOVF   FED,F
4B6E:  MOVFF  FEF,13E
4B72:  MOVF   x3E,F
4B74:  BNZ   4B80
4B76:  MOVF   x3F,F
4B78:  BNZ   4B80
....................         return FALSE; 
4B7A:  MOVLW  00
4B7C:  MOVWF  01
4B7E:  BRA    4C5A
....................  
....................     // If if this very first read to packet, set MAC Rx Pointer to 
....................     // beginig of UDP data area. 
....................     if ( UDPSocketInfo[activeUDPSocket].Flags.bFirstRead ) 
4B80:  MOVF   58,W
4B82:  MULLW  16
4B84:  MOVF   FF3,W
4B86:  CLRF   x3F
4B88:  MOVWF  x3E
4B8A:  MOVLW  15
4B8C:  ADDWF  x3E,F
4B8E:  MOVLW  00
4B90:  ADDWFC x3F,F
4B92:  MOVLW  59
4B94:  ADDWF  x3E,W
4B96:  MOVWF  FE9
4B98:  MOVLW  00
4B9A:  ADDWFC x3F,W
4B9C:  MOVWF  FEA
4B9E:  BTFSS  FEF.0
4BA0:  BRA    4BCE
....................     { 
....................         UDPSocketInfo[activeUDPSocket].Flags.bFirstRead = FALSE; 
4BA2:  MOVF   58,W
4BA4:  MULLW  16
4BA6:  MOVF   FF3,W
4BA8:  CLRF   x3F
4BAA:  MOVWF  x3E
4BAC:  MOVLW  15
4BAE:  ADDWF  x3E,F
4BB0:  MOVLW  00
4BB2:  ADDWFC x3F,F
4BB4:  MOVLW  59
4BB6:  ADDWF  x3E,W
4BB8:  MOVWF  FE9
4BBA:  MOVLW  00
4BBC:  ADDWFC x3F,W
4BBE:  MOVWF  FEA
4BC0:  BCF    FEF.0
....................         UDPSetRxBuffer(0); 
4BC2:  CLRF   x44
4BC4:  MOVLW  08
4BC6:  MOVWF  x43
4BC8:  MOVLB  0
4BCA:  CALL   3B54
....................     } 
....................  
....................     *v = MACGet(); 
4BCE:  MOVFF  13D,03
4BD2:  MOVFF  13C,13E
4BD6:  MOVFF  13D,13F
4BDA:  MOVLB  0
4BDC:  CALL   3B6E
4BE0:  MOVFF  13F,FEA
4BE4:  MOVFF  13E,FE9
4BE8:  MOVFF  01,FEF
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount--; 
4BEC:  MOVF   58,W
4BEE:  MULLW  16
4BF0:  MOVF   FF3,W
4BF2:  MOVLB  1
4BF4:  CLRF   x3F
4BF6:  MOVWF  x3E
4BF8:  MOVLW  10
4BFA:  ADDWF  x3E,W
4BFC:  MOVWF  01
4BFE:  MOVLW  00
4C00:  ADDWFC x3F,W
4C02:  MOVWF  03
4C04:  MOVF   01,W
4C06:  ADDLW  59
4C08:  MOVWF  FE9
4C0A:  MOVLW  00
4C0C:  ADDWFC 03,W
4C0E:  MOVWF  FEA
4C10:  MOVLW  FF
4C12:  ADDWF  FEF,F
4C14:  BC    4C1A
4C16:  MOVF   FEE,F
4C18:  DECF   FED,F
....................  
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount == 0 ) 
4C1A:  MOVF   58,W
4C1C:  MULLW  16
4C1E:  MOVF   FF3,W
4C20:  CLRF   x3F
4C22:  MOVWF  x3E
4C24:  MOVLW  10
4C26:  ADDWF  x3E,W
4C28:  MOVWF  01
4C2A:  MOVLW  00
4C2C:  ADDWFC x3F,W
4C2E:  MOVWF  03
4C30:  MOVF   01,W
4C32:  ADDLW  59
4C34:  MOVWF  FE9
4C36:  MOVLW  00
4C38:  ADDWFC 03,W
4C3A:  MOVWF  FEA
4C3C:  MOVFF  FEC,13F
4C40:  MOVF   FED,F
4C42:  MOVFF  FEF,13E
4C46:  MOVF   x3E,F
4C48:  BNZ   4C56
4C4A:  MOVF   x3F,F
4C4C:  BNZ   4C56
....................     { 
....................         MACDiscardRx(); 
4C4E:  MOVLB  0
4C50:  CALL   2CF4
4C54:  MOVLB  1
....................     } 
....................  
....................     return TRUE; 
4C56:  MOVLW  01
4C58:  MOVWF  01
.................... } 
4C5A:  MOVLB  0
4C5C:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................     if ( UDPSocketInfo[activeUDPSocket].RxCount ) 
4C5E:  MOVF   58,W
4C60:  MULLW  16
4C62:  MOVF   FF3,W
4C64:  MOVLB  1
4C66:  CLRF   x3D
4C68:  MOVWF  x3C
4C6A:  MOVLW  10
4C6C:  ADDWF  x3C,W
4C6E:  MOVWF  01
4C70:  MOVLW  00
4C72:  ADDWFC x3D,W
4C74:  MOVWF  03
4C76:  MOVF   01,W
4C78:  ADDLW  59
4C7A:  MOVWF  FE9
4C7C:  MOVLW  00
4C7E:  ADDWFC 03,W
4C80:  MOVWF  FEA
4C82:  MOVF   FEF,F
4C84:  BNZ   4C8A
4C86:  MOVF   FEC,F
4C88:  BZ    4C92
....................         MACDiscardRx(); 
4C8A:  MOVLB  0
4C8C:  CALL   2CF4
4C90:  MOVLB  1
....................  
....................     UDPSocketInfo[activeUDPSocket].RxCount = 0; 
4C92:  MOVF   58,W
4C94:  MULLW  16
4C96:  MOVF   FF3,W
4C98:  CLRF   x3D
4C9A:  MOVWF  x3C
4C9C:  MOVLW  10
4C9E:  ADDWF  x3C,W
4CA0:  MOVWF  01
4CA2:  MOVLW  00
4CA4:  ADDWFC x3D,W
4CA6:  MOVWF  03
4CA8:  MOVF   01,W
4CAA:  ADDLW  59
4CAC:  MOVWF  FE9
4CAE:  MOVLW  00
4CB0:  ADDWFC 03,W
4CB2:  MOVWF  FEA
4CB4:  CLRF   FEC
4CB6:  MOVF   FED,F
4CB8:  CLRF   FEF
.................... } 
4CBA:  MOVLB  0
4CBC:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... /* 
....................  * Pseudo header as defined by rfc 793. 
....................  */ 
.................... typedef struct _UDP_PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } UDP_PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER h; 
....................     UDP_SOCKET s; 
....................     UDP_PSEUDO_HEADER pseudoHeader; 
....................     WORD_VAL   checksum; 
....................  
....................     /* 
....................      * Retrieve UDP header. 
....................      */ 
....................     //MACGetArray((BYTE*)&h, sizeof(h)); 
....................     MACGetArray(&h, sizeof(UDP_HEADER)); 
*
3E98:  MOVLW  01
3E9A:  MOVLB  1
3E9C:  MOVWF  x8A
3E9E:  MOVLW  2C
3EA0:  MOVWF  x89
3EA2:  CLRF   x8C
3EA4:  MOVLW  08
3EA6:  MOVWF  x8B
3EA8:  MOVLB  0
3EAA:  CALL   2D60
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
3EAE:  MOVFF  12D,19D
3EB2:  MOVFF  12C,19C
3EB6:  CALL   2DC4
3EBA:  MOVFF  02,12D
3EBE:  MOVFF  01,12C
....................     h.DestinationPort   = swaps(h.DestinationPort); 
3EC2:  MOVFF  12F,19D
3EC6:  MOVFF  12E,19C
3ECA:  CALL   2DC4
3ECE:  MOVFF  02,12F
3ED2:  MOVFF  01,12E
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
3ED6:  MOVFF  131,19D
3EDA:  MOVFF  130,19C
3EDE:  CALL   2DC4
3EE2:  MOVLW  08
3EE4:  MOVLB  1
3EE6:  SUBWF  01,W
3EE8:  MOVWF  x30
3EEA:  MOVLW  00
3EEC:  SUBWFB 02,W
3EEE:  MOVWF  x31
....................  
....................       debug_udp("\r\nUDP PROCESS SP=%LX DP=%LX PAYLOAD=%LX ", 
....................             h.SourcePort, 
....................             h.DestinationPort, 
....................             h.Length 
....................          ); 
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
3EF0:  MOVF   x32,W
3EF2:  IORWF  x33,W
3EF4:  BTFSC  FD8.2
3EF6:  BRA    401C
....................    { 
....................        h.Checksum          = swaps(h.Checksum); 
3EF8:  MOVFF  133,19D
3EFC:  MOVFF  132,19C
3F00:  MOVLB  0
3F02:  CALL   2DC4
3F06:  MOVFF  02,133
3F0A:  MOVFF  01,132
....................  
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
3F0E:  MOVLW  06
3F10:  MOVLB  1
3F12:  ADDWF  x26,W
3F14:  MOVWF  FE9
3F16:  MOVLW  00
3F18:  ADDWFC x27,W
3F1A:  MOVWF  FEA
3F1C:  MOVFF  FEF,00
3F20:  MOVFF  FEC,01
3F24:  MOVFF  FEC,02
3F28:  MOVFF  FEC,03
3F2C:  MOVFF  03,138
3F30:  MOVFF  02,137
3F34:  MOVFF  01,136
3F38:  MOVFF  00,135
....................        pseudoHeader.DestAddress.v[0]   = localIP->v[0]; 
3F3C:  MOVFF  128,FE9
3F40:  MOVFF  129,FEA
3F44:  MOVFF  FEF,139
....................        pseudoHeader.DestAddress.v[1]   = localIP->v[1]; 
3F48:  MOVLW  01
3F4A:  ADDWF  x28,W
3F4C:  MOVWF  FE9
3F4E:  MOVLW  00
3F50:  ADDWFC x29,W
3F52:  MOVWF  FEA
3F54:  MOVFF  FEF,13A
....................        pseudoHeader.DestAddress.v[2]   = localIP->v[2]; 
3F58:  MOVLW  02
3F5A:  ADDWF  x28,W
3F5C:  MOVWF  FE9
3F5E:  MOVLW  00
3F60:  ADDWFC x29,W
3F62:  MOVWF  FEA
3F64:  MOVFF  FEF,13B
....................        pseudoHeader.DestAddress.v[3]   = localIP->v[3]; 
3F68:  MOVLW  03
3F6A:  ADDWF  x28,W
3F6C:  MOVWF  FE9
3F6E:  MOVLW  00
3F70:  ADDWFC x29,W
3F72:  MOVWF  FEA
3F74:  MOVFF  FEF,13C
....................        pseudoHeader.Zero               = 0x0; 
3F78:  CLRF   x3D
....................        pseudoHeader.Protocol           = IP_PROT_UDP; 
3F7A:  MOVLW  11
3F7C:  MOVWF  x3E
....................        pseudoHeader.Length             = len; 
3F7E:  MOVFF  12B,140
3F82:  MOVFF  12A,13F
....................  
....................        SwapPseudoHeader(pseudoHeader); 
3F86:  MOVFF  140,19D
3F8A:  MOVFF  13F,19C
3F8E:  MOVLB  0
3F90:  CALL   2DC4
3F94:  MOVFF  02,140
3F98:  MOVFF  01,13F
....................  
....................        checksum.Val = ~CalcIPChecksum(&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
3F9C:  MOVLW  01
3F9E:  MOVLB  1
3FA0:  MOVWF  x44
3FA2:  MOVLW  35
3FA4:  MOVWF  x43
3FA6:  CLRF   x46
3FA8:  MOVLW  0C
3FAA:  MOVWF  x45
3FAC:  MOVLB  0
3FAE:  BRA    3A64
3FB0:  MOVFF  01,141
3FB4:  MOVLB  1
3FB6:  COMF   x41,F
3FB8:  MOVFF  02,142
3FBC:  COMF   x42,F
....................  
....................  
....................        // Set UDP packet checksum = pseudo header checksum in MAC RAM. 
....................        IPSetRxBuffer(6); 
3FBE:  CLRF   x44
3FC0:  MOVLW  06
3FC2:  MOVWF  x43
3FC4:  MOVLB  0
3FC6:  RCALL  3B54
....................        MACPut(checksum.v[0]); 
3FC8:  MOVFF  141,1A0
3FCC:  CALL   319A
....................       // In case if the end of the RX buffer is reached and a wraparound is needed, set the next address to prevent writing to the wrong address. 
....................        IPSetRxBuffer(7); 
3FD0:  MOVLB  1
3FD2:  CLRF   x44
3FD4:  MOVLW  07
3FD6:  MOVWF  x43
3FD8:  MOVLB  0
3FDA:  RCALL  3B54
....................        MACPut(checksum.v[1]); 
3FDC:  MOVFF  142,1A0
3FE0:  CALL   319A
....................        IPSetRxBuffer(0); 
3FE4:  MOVLB  1
3FE6:  CLRF   x44
3FE8:  CLRF   x43
3FEA:  MOVLB  0
3FEC:  RCALL  3B54
....................  
....................        // Now calculate UDP packet checksum in NIC RAM - including 
....................        // pesudo header. 
....................        checksum.Val = CalcIPBufferChecksum(len); 
3FEE:  MOVFF  12B,144
3FF2:  MOVFF  12A,143
3FF6:  BRA    3B9A
3FF8:  MOVFF  02,142
3FFC:  MOVFF  01,141
....................  
....................        if ( checksum.Val != h.Checksum ) 
4000:  MOVLB  1
4002:  MOVF   x32,W
4004:  SUBWF  x41,W
4006:  BNZ   400E
4008:  MOVF   x33,W
400A:  SUBWF  x42,W
400C:  BZ    401C
....................        { 
....................            debug_udp("INVALID-CS "); 
....................            MACDiscardRx(); 
400E:  MOVLB  0
4010:  CALL   2CF4
....................            return TRUE; 
4014:  MOVLW  01
4016:  MOVWF  01
4018:  BRA    409E
401A:  MOVLB  1
....................        } 
....................    } 
....................  
....................     s = FindMatching_UDP_Socket(&h, remoteNode, localIP); 
401C:  MOVLW  01
401E:  MOVWF  x44
4020:  MOVLW  2C
4022:  MOVWF  x43
4024:  MOVFF  127,146
4028:  MOVFF  126,145
402C:  MOVFF  129,148
4030:  MOVFF  128,147
4034:  MOVLB  0
4036:  BRA    3CF4
4038:  MOVFF  01,134
....................     if ( s == INVALID_UDP_SOCKET ) 
403C:  MOVLB  1
403E:  INCFSZ x34,W
4040:  BRA    404C
....................     { 
....................         /* 
....................          * If there is no matching socket, There is no one to handle 
....................          * this data.  Discard it. 
....................          */ 
....................         debug_udp("INVALID-SOCKET "); 
....................         MACDiscardRx(); 
4042:  MOVLB  0
4044:  CALL   2CF4
....................     } 
....................     else { 
4048:  BRA    409A
404A:  MOVLB  1
....................         UDPSocketInfo[s].RxCount = h.Length; 
404C:  MOVF   x34,W
404E:  MULLW  16
4050:  MOVF   FF3,W
4052:  CLRF   x44
4054:  MOVWF  x43
4056:  MOVLW  10
4058:  ADDWF  x43,W
405A:  MOVWF  01
405C:  MOVLW  00
405E:  ADDWFC x44,W
4060:  MOVWF  03
4062:  MOVF   01,W
4064:  ADDLW  59
4066:  MOVWF  FE9
4068:  MOVLW  00
406A:  ADDWFC 03,W
406C:  MOVWF  FEA
406E:  MOVFF  131,FEC
4072:  MOVF   FED,F
4074:  MOVFF  130,FEF
....................         UDPSocketInfo[s].Flags.bFirstRead = TRUE; 
4078:  MOVF   x34,W
407A:  MULLW  16
407C:  MOVF   FF3,W
407E:  CLRF   x44
4080:  MOVWF  x43
4082:  MOVLW  15
4084:  ADDWF  x43,F
4086:  MOVLW  00
4088:  ADDWFC x44,F
408A:  MOVLW  59
408C:  ADDWF  x43,W
408E:  MOVWF  FE9
4090:  MOVLW  00
4092:  ADDWFC x44,W
4094:  MOVWF  FEA
4096:  BSF    FEF.0
4098:  MOVLB  0
....................  
....................     debug_udp("MATCH AS:%U ", s); 
....................     /*debug_udp("MAC-%X:%X:%X:%X:%X:%X", 
....................          remoteNode->MACAddr.v[0], 
....................          remoteNode->MACAddr.v[1], 
....................          remoteNode->MACAddr.v[2], 
....................          remoteNode->MACAddr.v[3], 
....................          remoteNode->MACAddr.v[4], 
....................          remoteNode->MACAddr.v[5] 
....................       );*/ 
....................     } 
....................  
....................     return TRUE; 
409A:  MOVLW  01
409C:  MOVWF  01
.................... } 
409E:  GOTO   5638 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, 
....................  *                                NODE_INFO *remoteNode, 
....................  *                                IP_ADDR *localIP) 
....................  * 
....................  * PreCondition:    UDP Segment header has been retrieved from buffer 
....................  *                  The IP header has also been retrieved 
....................  * 
....................  * Input:           remoteNode      - Remote node info from IP header 
....................  *                  h               - header of UDP semgent. 
....................  * 
....................  * Output:          matching UDP socket or INVALID_UDP_SOCKET 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define BROADCAST_ADDRESS   (0xffffffffL) 
.................... static UDP_SOCKET FindMatching_UDP_Socket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET partialMatch; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................     partialMatch = INVALID_UDP_SOCKET; 
*
3CF4:  MOVLW  FF
3CF6:  MOVLB  1
3CF8:  MOVWF  x4A
....................  
....................     p = UDPSocketInfo; 
3CFA:  CLRF   x4C
3CFC:  MOVLW  59
3CFE:  MOVWF  x4B
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
3D00:  CLRF   x49
3D02:  MOVF   x49,W
3D04:  SUBLW  01
3D06:  BTFSS  FD8.0
3D08:  BRA    3E1C
....................     { 
....................         /* 
....................          * This packet is said to be matching with current socket 
....................          * 1. If its destination port matches with our local port. 
....................          * 2. This socket does not have any data pending. 
....................          * 3. Packet source IP address matches with socket remote IP address. 
....................          *    OR this socket had transmitted packet with destination address 
....................          *       as broadcast. 
....................          */ 
....................         if ( p->localPort == h->DestinationPort ) 
3D0A:  MOVLW  0C
3D0C:  ADDWF  x4B,W
3D0E:  MOVWF  FE9
3D10:  MOVLW  00
3D12:  ADDWFC x4C,W
3D14:  MOVWF  FEA
3D16:  MOVFF  FEC,14E
3D1A:  MOVF   FED,F
3D1C:  MOVFF  FEF,14D
3D20:  MOVLW  02
3D22:  ADDWF  x43,W
3D24:  MOVWF  FE9
3D26:  MOVLW  00
3D28:  ADDWFC x44,W
3D2A:  MOVWF  FEA
3D2C:  MOVFF  FEC,03
3D30:  MOVF   FED,F
3D32:  MOVF   FEF,W
3D34:  SUBWF  x4D,W
3D36:  BTFSS  FD8.2
3D38:  BRA    3E10
3D3A:  MOVF   03,W
3D3C:  SUBWF  x4E,W
3D3E:  BNZ   3E10
....................         { 
....................             if ( (p->remotePort == h->SourcePort) && (p->RxCount == 0L) ) 
3D40:  MOVLW  0A
3D42:  ADDWF  x4B,W
3D44:  MOVWF  FE9
3D46:  MOVLW  00
3D48:  ADDWFC x4C,W
3D4A:  MOVWF  FEA
3D4C:  MOVFF  FEC,14E
3D50:  MOVF   FED,F
3D52:  MOVFF  FEF,14D
3D56:  MOVFF  143,FE9
3D5A:  MOVFF  144,FEA
3D5E:  MOVFF  FEC,03
3D62:  MOVF   FED,F
3D64:  MOVF   FEF,W
3D66:  SUBWF  x4D,W
3D68:  BNZ   3E0C
3D6A:  MOVF   03,W
3D6C:  SUBWF  x4E,W
3D6E:  BNZ   3E0C
3D70:  MOVLW  10
3D72:  ADDWF  x4B,W
3D74:  MOVWF  FE9
3D76:  MOVLW  00
3D78:  ADDWFC x4C,W
3D7A:  MOVWF  FEA
3D7C:  MOVFF  FEC,14E
3D80:  MOVF   FED,F
3D82:  MOVFF  FEF,14D
3D86:  MOVF   x4D,F
3D88:  BNZ   3E0C
3D8A:  MOVF   x4E,F
3D8C:  BNZ   3E0C
....................             { 
....................                 if ( (p->remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) || 
....................                      (localIP->Val == BROADCAST_ADDRESS) ) 
3D8E:  MOVLW  06
3D90:  ADDWF  x4B,W
3D92:  MOVWF  FE9
3D94:  MOVLW  00
3D96:  ADDWFC x4C,W
3D98:  MOVWF  FEA
3D9A:  MOVFF  FEF,14D
3D9E:  MOVFF  FEC,14E
3DA2:  MOVFF  FEC,14F
3DA6:  MOVFF  FEC,150
3DAA:  MOVLW  06
3DAC:  ADDWF  x45,W
3DAE:  MOVWF  FE9
3DB0:  MOVLW  00
3DB2:  ADDWFC x46,W
3DB4:  MOVWF  FEA
3DB6:  MOVFF  FEF,00
3DBA:  MOVFF  FEC,01
3DBE:  MOVFF  FEC,02
3DC2:  MOVFF  FEC,03
3DC6:  MOVF   00,W
3DC8:  SUBWF  x4D,W
3DCA:  BNZ   3DDE
3DCC:  MOVF   01,W
3DCE:  SUBWF  x4E,W
3DD0:  BNZ   3DDE
3DD2:  MOVF   02,W
3DD4:  SUBWF  x4F,W
3DD6:  BNZ   3DDE
3DD8:  MOVF   03,W
3DDA:  SUBWF  x50,W
3DDC:  BZ    3E06
3DDE:  MOVFF  147,FE9
3DE2:  MOVFF  148,FEA
3DE6:  MOVFF  FEF,14D
3DEA:  MOVFF  FEC,14E
3DEE:  MOVFF  FEC,14F
3DF2:  MOVFF  FEC,150
3DF6:  INCFSZ x4D,W
3DF8:  BRA    3E0C
3DFA:  INCFSZ x4E,W
3DFC:  BRA    3E0C
3DFE:  INCFSZ x4F,W
3E00:  BRA    3E0C
3E02:  INCFSZ x50,W
3E04:  BRA    3E0C
....................                 { 
....................                     return s; 
3E06:  MOVFF  149,01
3E0A:  BRA    3E92
....................                 } 
....................             } 
....................  
....................             partialMatch = s; 
3E0C:  MOVFF  149,14A
....................         } 
....................         p++; 
3E10:  MOVLW  16
3E12:  ADDWF  x4B,F
3E14:  BTFSC  FD8.0
3E16:  INCF   x4C,F
....................     } 
3E18:  INCF   x49,F
3E1A:  BRA    3D02
....................  
....................     if ( partialMatch != INVALID_UDP_SOCKET ) 
3E1C:  INCFSZ x4A,W
3E1E:  BRA    3E22
3E20:  BRA    3E8E
....................     { 
....................         p = &UDPSocketInfo[partialMatch]; 
3E22:  MOVF   x4A,W
3E24:  MULLW  16
3E26:  MOVF   FF3,W
3E28:  CLRF   03
3E2A:  ADDLW  59
3E2C:  MOVWF  01
3E2E:  MOVLW  00
3E30:  ADDWFC 03,F
3E32:  MOVFF  01,14B
3E36:  MOVFF  03,14C
....................  
....................         memcpy(&p->remoteNode, 
....................                 remoteNode, sizeof(NODE_INFO) ); 
3E3A:  MOVFF  14C,03
3E3E:  MOVFF  14B,14D
3E42:  MOVFF  14C,14E
3E46:  MOVFF  14C,FEA
3E4A:  MOVFF  14B,FE9
3E4E:  MOVFF  146,FE2
3E52:  MOVFF  145,FE1
3E56:  MOVLW  0A
3E58:  MOVWF  01
3E5A:  MOVFF  FE6,FEE
3E5E:  DECFSZ 01,F
3E60:  BRA    3E5A
....................  
....................         p->remotePort = h->SourcePort; 
3E62:  MOVLW  0A
3E64:  ADDWF  x4B,W
3E66:  MOVWF  01
3E68:  MOVLW  00
3E6A:  ADDWFC x4C,W
3E6C:  MOVFF  143,FE9
3E70:  MOVFF  144,FEA
3E74:  MOVFF  FEC,03
3E78:  MOVF   FED,F
3E7A:  MOVFF  FEF,14F
3E7E:  MOVWF  FEA
3E80:  MOVFF  01,FE9
3E84:  MOVFF  03,FEC
3E88:  MOVF   FED,F
3E8A:  MOVFF  14F,FEF
....................     } 
....................     return partialMatch; 
3E8E:  MOVFF  14A,01
.................... } 
3E92:  MOVLB  0
3E94:  GOTO   4038 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.c 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
....................  *                                               (Rev 2.11) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/14/04 DHCP will force set IP Address to 0.0.0.0 during init. 
....................  * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
....................  * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
....................  *                              where UDPPut was called before setting 
....................  *                              active socket. 
....................  * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
....................  *                              NAK and renew existing IP address. 
....................  * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
....................  *                              chaddr field before accpting the packet. 
....................  *                              Fixed DHCPTask() where it would not 
....................  *                              reply to first OFFER. 
....................  * Darren Rook (CCS)    6/28/04 CCS Port now uses 2.20 (see above) 
....................  * Darren Rook (CCS)    6/29/04 DHCPServerID, DHCPLeaseTime, tempIPAddress, 
....................  *                              tempGateway, tempMask, _DHCPReceive() 
....................  *                              and _DHCPSend() no longer static. 
....................  * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
....................  *                              state to adjust for irregular TICK_SECOND 
....................  *                              Without this logic, actual lease time count 
....................  *                              down may be incorrect. 
....................  * Darren Rook (CCS)    7/13/06 Implemented Nilesh's 03/1/04 fix 
....................  * Howard Schlunder      5/11/06   Fixed tickDiff usage, reducing 
....................  *                        accumulated timing error.  Fixed DHCP 
....................  *                        state machine requesting IP 0.0.0.0 
....................  *                        after lease expiration. 
....................  * Howard Schlunder      6/01/06   Added DHCPState.bits.bOfferReceived flag to 
....................  *                        allow operation on networks with multiple 
....................  *                        DHCP servers offering multiple addresses 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack 
....................  * Howard Schlunder      8/01/06 Added DNS server option to DHCP request,  
....................  *                        untested Host Name option to DHCP request 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/dhcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 Added DHCPIsDisabled() macro, returns true if DHCP is disabled 
....................  * Darren Rook (CCS)    07/13/06 Changed DHCPIsDisabled() to use AppConfig instead of smDHCPState 
....................  * Darren Rook (CCS)    08/25/06 In synch with Microchip's V3.60 stack (no changes) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef DHCP_H 
.................... #define DHCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... typedef enum _SM_DHCP 
.................... { 
.................... 	SM_DHCP_INIT_FIRST_TIME, 
....................     SM_DHCP_INIT, 
....................     SM_DHCP_RESET_WAIT, 
....................     SM_DHCP_BROADCAST, 
....................     SM_DHCP_DISCOVER, 
....................     SM_DHCP_REQUEST, 
....................     SM_DHCP_BIND, 
....................     SM_DHCP_BOUND, 
....................     SM_DHCP_DISABLED, 
.................... } SM_DHCP; 
....................  
.................... SM_DHCP smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPDisable(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Puts DHCPTask into unhandled state "SM_DHCP_DISABLED" 
....................  *                  and hence DHCP is effictively disabled. 
....................  * 
....................  * Note:            This macro should be called before DHCPTask is called 
....................  *                  or else a UDP port will be kept open and there will 
....................  *                  be no task to process it. 
....................  ********************************************************************/ 
.................... #define DHCPDisable()       (smDHCPState = SM_DHCP_DISABLED) 
....................  
.................... #define DHCPIsDisabled()      (smDHCPState == SM_DHCP_DISABLED) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void); 
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL DHCPIsBound(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if DHCP is bound to given configuration 
....................  *                  FALSE if DHCP has yet to be bound. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... #define DHCPIsBound()       (DHCPState.bits.bIsBound) 
....................  
.................... typedef union _DHCP_STATE 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bIsBound : 1; 
....................         unsigned char bOfferReceived : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } DHCP_STATE; 
....................  
....................  
.................... static DHCP_STATE DHCPState; 
....................  
.................... /********************************************************************* 
....................  * Macro:           void DHCPReset(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Closes any previously opened DHCP socket 
....................  *                  and resets DHCP state machine so that on next 
....................  *                  call to DHCPTask will result in new DHCP request. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void DHCPReset(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/udp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        Microchip C18 v3.02 or higher 
....................  *					Microchip C30 v2.01 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 UDPSetRxBuffer() and UDPSetTxBuffer() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef UDP_H 
.................... #define UDP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... typedef WORD UDP_PORT; 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... typedef struct _UDP_SOCKET_INFO 
.................... { 
....................     NODE_INFO   remoteNode; 
....................     UDP_PORT    remotePort; 
....................     UDP_PORT    localPort; 
....................     WORD        TxCount; 
....................     WORD        RxCount; 
....................     BUFFER      TxBuffer; 
....................     WORD      TxOffset; 
....................     struct 
....................     { 
....................         int1 bFirstRead; 
....................     } Flags; 
.................... } UDP_SOCKET_INFO; 
....................  
.................... #define INVALID_UDP_SOCKET      (0xff) 
.................... #define INVALID_UDP_PORT      (0L) 
....................  
.................... /* 
....................  * All module utilizing UDP module will get extern definition of 
....................  * activeUDPSocket.  While UDP module itself will define activeUDPSocket. 
....................  */ 
.................... UDP_SOCKET activeUDPSocket; 
.................... UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
....................  
.................... typedef struct _UDP_HEADER 
.................... { 
....................     UDP_PORT    SourcePort; 
....................     UDP_PORT    DestinationPort; 
....................     WORD        Length; 
....................     WORD        Checksum; 
.................... } UDP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes internal variables. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void        UDPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................  *                                     NODE_INFO *remoteNode, 
....................  *                                     UDP_PORT remotePort) 
....................  * 
....................  * PreCondition:    UDPInit() is already called 
....................  * 
....................  * Input:           remoteNode - Remote Node info such as MAC and IP 
....................  *                               address 
....................  *                               If NULL, localPort is opened for 
....................  *                               Listen. 
....................  *                  remotePort - Remote Port to which to talk to 
....................  *                               If INVALID_UDP_SOCKET, localPort is 
....................  *                               opened for Listen. 
....................  *                  localPort  - A non-zero port number. 
....................  * 
....................  * Output:          A valid UDP socket that is to be used for 
....................  *                  subsequent UDP communications. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        A UDP packet header is assembled and loaded into 
....................  *                  UDP transmit buffer. 
....................  * 
....................  * Note:            A localPort value of '0' is considered nonexistent 
....................  *                  port.  This call must always have nonzero localPort 
....................  *                  value. 
....................  *                  This function sets returned socket as an active 
....................  *                  UDP socket. 
....................   ********************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPClose(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPOpen() is already called 
....................  * 
....................  * Input:           s       - Socket that is to be closed. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given socket is marked as available for future 
....................  *                  new communcations. 
....................  * 
....................  * Note:            This function does not affect previous 
....................  *                  active UDP socket designation. 
....................   ********************************************************************/ 
.................... void UDPClose(UDP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL UDPIsPutReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition: 
....................  * 
....................  * Input:           s       - Socket that is to be loaded and made 
....................  *                            an active UDP socket. 
....................  * 
....................  * Output:          TRUE if at least one UDP buffer is ready to transmit 
....................  *                  FALSE if no UDP buffer is ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This call sets given socket as an active UDP socket. 
....................  ********************************************************************/ 
.................... //#define UDPIsPutReady(s)        (activeUDPSocket = s, MACIsTxReady(TRUE)) 
.................... BOOL UDPIsPutReady(int8 s) { 
....................    activeUDPSocket = s; 
....................    return(MACIsTxReady(TRUE)); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPPut(BYTE v) 
....................  * 
....................  * PreCondition:    UDPIsPutReady() == TRUE with desired UDP socket 
....................  *                  that is to be loaded. 
....................  * 
....................  * Input:           v       - Data byte to loaded into transmit buffer 
....................  * 
....................  * Output:          TRUE if transmit buffer is still ready to accept 
....................  *                  more data bytes 
....................  * 
....................  *                  FALSE if transmit buffer can no longer accept 
....................  *                  any more data byte. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Given data byte is put into UDP transmit buffer 
....................  *                  and active UDP socket buffer length is incremented 
....................  *                  by one. 
....................  *                  If buffer has become full, FALSE is returned. 
....................  *                  Or else TRUE is returned. 
....................  * 
....................  * Note:            This function loads data into an active UDP socket 
....................  *                  as determined by previous call to UDPIsPutReady() 
....................  ********************************************************************/ 
.................... BOOL UDPPut(BYTE v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPFlush(void) 
....................  * 
....................  * PreCondition:    UDPPut() is already called and desired UDP socket 
....................  *                  is set as an active socket by calling 
....................  *                  UDPIsPutReady(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          All and any data associated with active UDP socket 
....................  *                  buffer is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function transmit all data from 
....................  *                  an active UDP socket. 
....................  ********************************************************************/ 
.................... void UDPFlush(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPIsGetReady(UDP_SOCKET s) 
....................  * 
....................  * PreCondition:    UDPInit() is already called. 
....................  * 
....................  * Input:           A valid UDP socket that is already "Listen"ed on 
....................  *                  or opened. 
....................  * 
....................  * Output:          TRUE if given port contains any data. 
....................  *                  FALSE if given port does not contain any data. 
....................  * 
....................  * Side Effects:    Given socket is set as an active UDP Socket. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function automatically sets supplied socket 
....................  *                  as an active socket.  Caller need not call 
....................  *                  explicit function UDPSetActiveSocket().  All 
....................  *                  subsequent calls will us this socket as an 
....................  *                  active socket. 
....................  ********************************************************************/ 
.................... BOOL UDPIsGetReady(UDP_SOCKET s); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPGet(BYTE *v) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           v       - Buffer to receive UDP data byte 
....................  * 
....................  * Output:          TRUE    if a data byte was read 
....................  *                  FALSE   if no data byte was read or available 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function fetches data from an active UDP 
....................  *                  socket as set by UDPIsGetReady() call. 
....................  ********************************************************************/ 
.................... BOOL UDPGet(BYTE *v); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void UDPDiscard(void) 
....................  * 
....................  * PreCondition:    UDPInit() is already called    AND 
....................  *                  UDPIsGetReady() == TRUE with desired UDP socket. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            This function discards an active UDP socket content. 
....................  ********************************************************************/ 
.................... void UDPDiscard(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL UDPProcess(NODE_INFO* remoteNode, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    UDPInit() is already called     AND 
....................  *                  UDP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remoteNode      - Remote node info 
....................  *                  len             - Total length of UDP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        UDPProcess(NODE_INFO *remoteNode, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetTxBuffer(a, b) (UDPSocketInfo[activeUDPSocket].TxOffset = b,  IPSetTxBuffer(a, b+sizeof(UDP_HEADER))) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           UDPSetRxBuffer(a) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define UDPSetRxBuffer(a) IPSetRxBuffer(a+sizeof(UDP_HEADER)) 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_SIIP) 
....................     #error DHCP module is not available when SLIP is used. 
.................... #endif 
....................  
.................... #define debug_dhcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_dhcp debug_printf 
....................  
.................... #define DHCP_TIMEOUT                    (2 * TICKS_PER_SECOND) 
....................  
....................  
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u) 
.................... #define BOOT_REPLY                      (2u) 
.................... #define HW_TYPE                         (1u) 
.................... #define LEN_OF_HW_TYPE                  (6u) 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u) 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u) 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u) 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u) 
.................... #define DHCP_OFFER_MESSAGE              (2u) 
.................... #define DHCP_REQUEST_MESSAGE            (3u) 
.................... #define DHCP_DECLINE_MESSAGE            (4u) 
.................... #define DHCP_ACK_MESSAGE                (5u) 
.................... #define DHCP_NAK_MESSAGE                (6u) 
.................... #define DHCP_RELEASE_MESSAGE            (7u) 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u) 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u) 
....................  
.................... #define DHCP_PARAM_REQUEST_LIST         (55u) 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u) 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u) 
.................... #define DHCP_SUBNET_MASK                (1u) 
.................... #define DHCP_ROUTER                     (3u) 
.................... #define DHCP_DNS                  (6u) 
.................... #define DHCP_HOST_NAME               (12u) 
.................... #define DHCP_IP_LEASE_TIME              (51u) 
.................... #define DHCP_END_OPTION                 (255u) 
....................  
.................... #define HALF_HOUR                       (WORD)((WORD)60 * (WORD)30) 
....................  
.................... static UDP_SOCKET DHCPSocket = INVALID_UDP_SOCKET; 
....................  
.................... static DWORD_VAL DHCPServerID; 
.................... static DWORD_VAL DHCPLeaseTime; 
....................  
.................... static IP_ADDR tempIPAddress; 
.................... static IP_ADDR tempGateway; 
.................... static IP_ADDR tempMask; 
.................... #if STACK_USE_DNS 
.................... static IP_ADDR tempDNS; 
.................... #endif 
.................... //static BYTE tempHostName[16]; 
....................  
.................... static union 
.................... { 
....................    struct 
....................    { 
....................       char IPAddress:1; 
....................       char Gateway:1; 
....................       char Mask:1; 
....................       char DNS:1; 
....................       char HostName:1; 
....................    } bits; 
....................    BYTE Val; 
.................... } ValidValues; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType); 
....................  
.................... BYTE DHCPBindCount = 0; 
....................  
....................  
....................  
.................... #define USARTPut(a) 
....................  
.................... void DHCPReset(void) 
.................... { 
....................     // Do not reset DHCP if it was previously disabled. 
....................     if ( smDHCPState == SM_DHCP_DISABLED ) 
*
1132:  MOVF   x85,W
1134:  SUBLW  08
1136:  BNZ   113A
....................         return; 
1138:  BRA    1150
....................  
....................     if ( DHCPSocket != INVALID_UDP_SOCKET ) 
113A:  INCFSZ x8A,W
113C:  BRA    1140
113E:  BRA    1146
....................         UDPClose(DHCPSocket); 
1140:  MOVFF  8A,133
1144:  RCALL  1096
....................  
....................     DHCPSocket = INVALID_UDP_SOCKET; 
1146:  MOVLW  FF
1148:  MOVWF  x8A
....................  
....................     smDHCPState = SM_DHCP_INIT_FIRST_TIME; 
114A:  CLRF   x85
....................     DHCPBindCount = 0; 
114C:  CLRF   xA0
....................     DHCPState.bits.bIsBound = FALSE; 
114E:  BCF    x86.0
.................... } 
1150:  RETLW  00
....................  
.................... void DebugDHCPDisplayState(int8 st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case SM_DHCP_INIT_FIRST_TIME:   debug_dhcp("INIT_FIRST_TIME");   break; 
....................       case SM_DHCP_INIT:              debug_dhcp("INIT");   break; 
....................       case SM_DHCP_RESET_WAIT:        debug_dhcp("RESET_WAIT");   break; 
....................       case SM_DHCP_BROADCAST:         debug_dhcp("BROADCAST");   break; 
....................       case SM_DHCP_DISCOVER:          debug_dhcp("DISCOVER");   break; 
....................       case SM_DHCP_REQUEST:           debug_dhcp("REQUEST");   break; 
....................       case SM_DHCP_BIND:              debug_dhcp("BIND");   break; 
....................       case SM_DHCP_BOUND:             debug_dhcp("BOUND");   break; 
....................       case SM_DHCP_DISABLED:          debug_dhcp("DISABLED");   break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void DHCPTask(void) 
....................  * 
....................  * PreCondition:    DHCPInit() is already called AND 
....................  *                  IPGetHeader() is called with 
....................  *                  IPFrameType == IP_PROT_UDP 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Fetches pending UDP packet from MAC receive buffer 
....................  *                  and dispatches it appropriate UDP socket. 
....................  *                  If not UDP socket is matched, UDP packet is 
....................  *                  silently discarded. 
....................  * 
....................  * Note:            Caller must make sure that MAC receive buffer 
....................  *                  access pointer is set to begining of UDP packet. 
....................  *                  Required steps before calling this function is: 
....................  * 
....................  *                  If ( MACIsRxReady() ) 
....................  *                  { 
....................  *                      MACGetHeader() 
....................  *                      If MACFrameType == IP 
....................  *                          IPGetHeader() 
....................  *                          if ( IPFrameType == IP_PROT_UDP ) 
....................  *                              Call DHCPTask() 
....................  *                  ... 
....................  ********************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
....................    NODE_INFO DHCPServerNode; 
....................    static TICKTYPE lastTryTick; 
....................    BYTE DHCPRecvReturnValue; 
....................    TICKTYPE tickDiff; 
....................    //static int8 debugLastState; 
....................  
....................    //debugLastState = smDHCPState; 
....................  
....................     switch(smDHCPState) 
....................     { 
*
50D0:  MOVF   x85,W
50D2:  ADDLW  F8
50D4:  BTFSC  FD8.0
50D6:  BRA    54FE
50D8:  ADDLW  08
50DA:  GOTO   5504
....................    case SM_DHCP_INIT_FIRST_TIME: 
....................         tempIPAddress.Val = 0x0; 
50DE:  CLRF   x96
50E0:  CLRF   x95
50E2:  CLRF   x94
50E4:  CLRF   x93
.................... //        smDHCPState = SM_DHCP_INIT;         // State automatically changes 
....................         /* No break */ 
....................  
....................     case SM_DHCP_INIT: 
....................         //debug(debug_putc,"\r\n\r\nDHCP: INIT"); 
....................  
....................         //dsr add 061404 
....................         //MY_IP=0; 
....................  
....................         DHCPServerNode.MACAddr.v[0] = 0xff; 
50E6:  MOVLW  FF
50E8:  MOVLB  1
50EA:  MOVWF  x26
....................         DHCPServerNode.MACAddr.v[1] = 0xff; 
50EC:  MOVWF  x27
....................         DHCPServerNode.MACAddr.v[2] = 0xff; 
50EE:  MOVWF  x28
....................         DHCPServerNode.MACAddr.v[3] = 0xff; 
50F0:  MOVWF  x29
....................         DHCPServerNode.MACAddr.v[4] = 0xff; 
50F2:  MOVWF  x2A
....................         DHCPServerNode.MACAddr.v[5] = 0xff; 
50F4:  MOVWF  x2B
....................         DHCPServerNode.IPAddr.Val = 0xffffffff; 
50F6:  MOVWF  x2F
50F8:  MOVWF  x2E
50FA:  MOVWF  x2D
50FC:  MOVWF  x2C
....................         DHCPSocket = UDPOpen(DHCP_CLIENT_PORT, 
....................                              &DHCPServerNode, 
....................                              DHCP_SERVER_PORT); 
50FE:  CLRF   x34
5100:  MOVLW  44
5102:  MOVWF  x33
5104:  MOVLW  01
5106:  MOVWF  x36
5108:  MOVLW  26
510A:  MOVWF  x35
510C:  CLRF   x38
510E:  MOVLW  43
5110:  MOVWF  x37
5112:  MOVLB  0
5114:  CALL   45AA
5118:  MOVFF  01,8A
....................         lastTryTick = TickGet(); 
511C:  CALL   1730
5120:  MOVFF  02,A2
5124:  MOVFF  01,A1
....................         smDHCPState = SM_DHCP_RESET_WAIT; 
5128:  MOVLW  02
512A:  MOVWF  x85
....................         /* No break */ 
....................  
....................     case SM_DHCP_RESET_WAIT: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= (TICKS_PER_SECOND/5) ) 
512C:  CALL   1730
5130:  MOVFF  02,134
5134:  MOVFF  01,133
5138:  MOVLB  1
513A:  MOVF   02,W
513C:  MOVLB  0
513E:  SUBWF  xA2,W
5140:  BNC   5154
5142:  BNZ   5158
5144:  MOVF   xA1,W
5146:  MOVLB  1
5148:  SUBWF  x33,W
514A:  BTFSC  FD8.0
514C:  BRA    5152
514E:  MOVLB  0
5150:  BRA    5158
5152:  MOVLB  0
5154:  MOVLW  00
5156:  BRA    515A
5158:  MOVLW  01
515A:  CLRF   03
515C:  IORWF  03,W
515E:  BZ    5196
5160:  MOVLW  FF
5162:  BSF    FD8.0
5164:  SUBFWB xA1,W
5166:  MOVLB  1
5168:  MOVWF  x33
516A:  MOVLW  FF
516C:  MOVLB  0
516E:  SUBFWB xA2,W
5170:  MOVLB  1
5172:  MOVWF  x34
5174:  MOVLB  0
5176:  CALL   1730
517A:  MOVF   01,W
517C:  MOVLB  1
517E:  ADDWF  x33,F
5180:  MOVF   02,W
5182:  ADDWFC x34,F
5184:  MOVLW  01
5186:  ADDWF  x33,W
5188:  MOVWF  01
518A:  MOVLW  00
518C:  ADDWFC x34,W
518E:  MOVWF  03
5190:  MOVF   01,W
5192:  BRA    51B6
5194:  MOVLB  0
5196:  CALL   1730
519A:  MOVFF  02,134
519E:  MOVFF  01,133
51A2:  MOVF   xA1,W
51A4:  MOVLB  1
51A6:  SUBWF  01,W
51A8:  MOVWF  00
51AA:  MOVLB  0
51AC:  MOVF   xA2,W
51AE:  MOVLB  1
51B0:  SUBWFB 02,W
51B2:  MOVWF  03
51B4:  MOVF   00,W
51B6:  SUBLW  01
51B8:  BC    51C0
....................             //debug(debug_putc,"\r\n\r\nDHCP: RESET_WAIT"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
51BA:  MOVLW  03
51BC:  MOVLB  0
51BE:  MOVWF  x85
....................         break; 
51C0:  MOVLB  0
51C2:  BRA    54FE
....................  
....................     case SM_DHCP_BROADCAST: 
....................        // Assume default IP Lease time of 60 seconds. 
....................        // This should be minimum possible to make sure that if 
....................        // server did not specify lease time, we try again after this minimum time. 
....................        DHCPLeaseTime.Val = 60; 
51C4:  CLRF   x92
51C6:  CLRF   x91
51C8:  CLRF   x90
51CA:  MOVLW  3C
51CC:  MOVWF  x8F
....................  
....................         // If we have already obtained some IP address, renew it. 
....................         if(DHCPState.bits.bIsBound) 
51CE:  BTFSS  x86.0
51D0:  BRA    51D8
....................         { 
....................             smDHCPState = SM_DHCP_REQUEST; 
51D2:  MOVLW  05
51D4:  MOVWF  x85
....................         } 
....................         else if ( UDPIsPutReady(DHCPSocket) ) 
51D6:  BRA    5202
51D8:  MOVFF  8A,133
51DC:  CALL   4670
51E0:  MOVF   01,F
51E2:  BZ    5202
....................         { 
....................             // To minimize code requirement, user must make sure that 
....................             // above call will be successful by making at least one 
....................             // UDP socket available. 
....................             // Usually this will be the case, given that DHCP will be 
....................             // the first one to use UDP socket. 
....................             // Also, we will not check for transmitter readiness, 
....................             // we assume it to be ready. 
....................             _DHCPSend(DHCP_DISCOVER_MESSAGE); 
51E4:  MOVLW  01
51E6:  MOVLB  1
51E8:  MOVWF  x33
51EA:  MOVLB  0
51EC:  CALL   490A
....................          ValidValues.Val = 0x00; 
51F0:  CLRF   x9F
....................  
....................             lastTryTick = TickGet(); 
51F2:  CALL   1730
51F6:  MOVFF  02,A2
51FA:  MOVFF  01,A1
....................             smDHCPState = SM_DHCP_DISCOVER; 
51FE:  MOVLW  04
5200:  MOVWF  x85
....................         } 
....................  
....................         break; 
5202:  BRA    54FE
....................  
....................  
....................     case SM_DHCP_DISCOVER: 
....................         if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
5204:  CALL   1730
5208:  MOVFF  02,134
520C:  MOVFF  01,133
5210:  MOVLB  1
5212:  MOVF   02,W
5214:  MOVLB  0
5216:  SUBWF  xA2,W
5218:  BNC   522C
521A:  BNZ   5230
521C:  MOVF   xA1,W
521E:  MOVLB  1
5220:  SUBWF  x33,W
5222:  BTFSC  FD8.0
5224:  BRA    522A
5226:  MOVLB  0
5228:  BRA    5230
522A:  MOVLB  0
522C:  MOVLW  00
522E:  BRA    5232
5230:  MOVLW  01
5232:  CLRF   03
5234:  IORWF  03,W
5236:  BZ    526E
5238:  MOVLW  FF
523A:  BSF    FD8.0
523C:  SUBFWB xA1,W
523E:  MOVLB  1
5240:  MOVWF  x33
5242:  MOVLW  FF
5244:  MOVLB  0
5246:  SUBFWB xA2,W
5248:  MOVLB  1
524A:  MOVWF  x34
524C:  MOVLB  0
524E:  CALL   1730
5252:  MOVF   01,W
5254:  MOVLB  1
5256:  ADDWF  x33,F
5258:  MOVF   02,W
525A:  ADDWFC x34,F
525C:  MOVLW  01
525E:  ADDWF  x33,W
5260:  MOVWF  01
5262:  MOVLW  00
5264:  ADDWFC x34,W
5266:  MOVWF  03
5268:  MOVF   01,W
526A:  BRA    528E
526C:  MOVLB  0
526E:  CALL   1730
5272:  MOVFF  02,134
5276:  MOVFF  01,133
527A:  MOVF   xA1,W
527C:  MOVLB  1
527E:  SUBWF  01,W
5280:  MOVWF  00
5282:  MOVLB  0
5284:  MOVF   xA2,W
5286:  MOVLB  1
5288:  SUBWFB 02,W
528A:  MOVWF  03
528C:  MOVF   00,W
528E:  SUBLW  13
5290:  BC    5298
....................       { 
....................             //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER TO BROADCAST"); 
....................             smDHCPState = SM_DHCP_BROADCAST; 
5292:  MOVLW  03
5294:  MOVLB  0
5296:  MOVWF  x85
....................             //return; 
....................         } 
....................  
....................         if ( UDPIsGetReady(DHCPSocket) ) 
5298:  MOVFF  8A,133
529C:  MOVLB  0
529E:  RCALL  4AFE
52A0:  MOVF   01,F
52A2:  BZ    52B6
....................         { 
....................  
....................             if ( _DHCPReceive() == DHCP_OFFER_MESSAGE ) 
52A4:  RCALL  4CBE
52A6:  MOVF   01,W
52A8:  SUBLW  02
52AA:  BNZ   52B2
....................             { 
....................                 //debug(debug_putc,"\r\n\r\nDHCP: DISCOVER BACK TO REQUEST"); 
....................                 smDHCPState = SM_DHCP_REQUEST; 
52AC:  MOVLW  05
52AE:  MOVWF  x85
....................             } 
....................             else 
52B0:  BRA    52B4
....................                break; 
52B2:  BRA    54FE
....................         } 
....................         else 
52B4:  BRA    52B8
....................            break; 
52B6:  BRA    54FE
....................  
....................  
....................     case SM_DHCP_REQUEST: 
....................         if ( UDPIsPutReady(DHCPSocket) ) 
52B8:  MOVFF  8A,133
52BC:  CALL   4670
52C0:  MOVF   01,F
52C2:  BZ    52E0
....................         { 
....................             _DHCPSend(DHCP_REQUEST_MESSAGE); 
52C4:  MOVLW  03
52C6:  MOVLB  1
52C8:  MOVWF  x33
52CA:  MOVLB  0
52CC:  CALL   490A
....................             lastTryTick = TickGet(); 
52D0:  CALL   1730
52D4:  MOVFF  02,A2
52D8:  MOVFF  01,A1
....................             smDHCPState = SM_DHCP_BIND; 
52DC:  MOVLW  06
52DE:  MOVWF  x85
....................             //debug(debug_putc,"\r\n\r\nDHCP: REQUEST TO BIND"); 
....................         } 
....................         break; 
52E0:  BRA    54FE
....................  
....................     case SM_DHCP_BIND: 
....................         if ( UDPIsGetReady(DHCPSocket) ) 
52E2:  MOVFF  8A,133
52E6:  RCALL  4AFE
52E8:  MOVF   01,F
52EA:  BZ    5372
....................         { 
....................             DHCPRecvReturnValue = _DHCPReceive(); 
52EC:  RCALL  4CBE
52EE:  MOVFF  01,130
....................             if ( DHCPRecvReturnValue == DHCP_NAK_MESSAGE ) 
52F2:  MOVLB  1
52F4:  MOVF   x30,W
52F6:  SUBLW  06
52F8:  BNZ   5306
....................             { 
....................                // (RSS) NAK recieved.  DHCP server didn't like our DHCP Request format 
....................             DHCPReset();                  // Start all over again 
52FA:  MOVLB  0
52FC:  CALL   1132
....................             return; 
5300:  BRA    54FE
....................             } 
....................             else if ( DHCPRecvReturnValue == DHCP_ACK_MESSAGE ) 
5302:  BRA    536C
5304:  MOVLB  1
5306:  MOVF   x30,W
5308:  SUBLW  05
530A:  BNZ   536E
....................             { 
....................                 // Once DCHP is successful, release the UDP socket 
....................                 // This will ensure that UDP layer discards any further DHCP related packets. 
....................                 UDPClose(DHCPSocket); 
530C:  MOVFF  8A,133
5310:  MOVLB  0
5312:  CALL   1096
....................                 DHCPSocket = INVALID_UDP_SOCKET; 
5316:  MOVLW  FF
5318:  MOVWF  x8A
....................  
....................                 lastTryTick = TickGet(); 
531A:  CALL   1730
531E:  MOVFF  02,A2
5322:  MOVFF  01,A1
....................                 smDHCPState = SM_DHCP_BOUND; 
5326:  MOVLW  07
5328:  MOVWF  x85
....................  
....................             if(ValidValues.bits.IPAddress) 
532A:  BTFSS  x9F.0
532C:  BRA    533E
....................                    AppConfig.MyIPAddr = tempIPAddress; 
532E:  MOVFF  96,19
5332:  MOVFF  95,18
5336:  MOVFF  94,17
533A:  MOVFF  93,16
....................             if(ValidValues.bits.Mask) 
533E:  BTFSS  x9F.2
5340:  BRA    5352
....................                AppConfig.MyMask = tempMask; 
5342:  MOVFF  9E,23
5346:  MOVFF  9D,22
534A:  MOVFF  9C,21
534E:  MOVFF  9B,20
....................             if(ValidValues.bits.Gateway) 
5352:  BTFSS  x9F.1
5354:  BRA    5366
....................                AppConfig.MyGateway = tempGateway; 
5356:  MOVFF  9A,27
535A:  MOVFF  99,26
535E:  MOVFF  98,25
5362:  MOVFF  97,24
....................          #if STACK_USE_DNS 
....................             if(ValidValues.bits.DNS) 
....................                AppConfig.PrimaryDNSServer = tempDNS; 
....................          #endif 
.................... //            if(ValidValues.bits.HostName) 
.................... //               memcpy(AppConfig.NetBIOSName, (void*)tempHostName, sizeof(AppConfig.NetBIOSName)); 
....................  
....................                 DHCPState.bits.bIsBound = TRUE; 
5366:  BSF    x86.0
....................  
....................                 DHCPBindCount++; 
5368:  INCF   xA0,F
....................  
....................                 return; 
536A:  BRA    54FE
536C:  MOVLB  1
....................             } 
....................         } 
....................         else if ( TickGetDiff(TickGet(), lastTryTick) >= DHCP_TIMEOUT ) 
536E:  BRA    5406
5370:  MOVLB  0
5372:  CALL   1730
5376:  MOVFF  02,134
537A:  MOVFF  01,133
537E:  MOVLB  1
5380:  MOVF   02,W
5382:  MOVLB  0
5384:  SUBWF  xA2,W
5386:  BNC   539A
5388:  BNZ   539E
538A:  MOVF   xA1,W
538C:  MOVLB  1
538E:  SUBWF  x33,W
5390:  BTFSC  FD8.0
5392:  BRA    5398
5394:  MOVLB  0
5396:  BRA    539E
5398:  MOVLB  0
539A:  MOVLW  00
539C:  BRA    53A0
539E:  MOVLW  01
53A0:  CLRF   03
53A2:  IORWF  03,W
53A4:  BZ    53DC
53A6:  MOVLW  FF
53A8:  BSF    FD8.0
53AA:  SUBFWB xA1,W
53AC:  MOVLB  1
53AE:  MOVWF  x33
53B0:  MOVLW  FF
53B2:  MOVLB  0
53B4:  SUBFWB xA2,W
53B6:  MOVLB  1
53B8:  MOVWF  x34
53BA:  MOVLB  0
53BC:  CALL   1730
53C0:  MOVF   01,W
53C2:  MOVLB  1
53C4:  ADDWF  x33,F
53C6:  MOVF   02,W
53C8:  ADDWFC x34,F
53CA:  MOVLW  01
53CC:  ADDWF  x33,W
53CE:  MOVWF  01
53D0:  MOVLW  00
53D2:  ADDWFC x34,W
53D4:  MOVWF  03
53D6:  MOVF   01,W
53D8:  BRA    53FC
53DA:  MOVLB  0
53DC:  CALL   1730
53E0:  MOVFF  02,134
53E4:  MOVFF  01,133
53E8:  MOVF   xA1,W
53EA:  MOVLB  1
53EC:  SUBWF  01,W
53EE:  MOVWF  00
53F0:  MOVLB  0
53F2:  MOVF   xA2,W
53F4:  MOVLB  1
53F6:  SUBWFB 02,W
53F8:  MOVWF  03
53FA:  MOVF   00,W
53FC:  SUBLW  13
53FE:  BC    5406
....................             smDHCPState = SM_DHCP_BROADCAST; 
5400:  MOVLW  03
5402:  MOVLB  0
5404:  MOVWF  x85
....................         break; 
5406:  MOVLB  0
5408:  BRA    54FE
....................  
....................     case SM_DHCP_BOUND: 
....................         // Keep track of how long we use this IP configuration. 
....................         // When lease period expires, renew the configuration. 
....................         tickDiff = TickGetDiff(TickGet(), lastTryTick); 
540A:  CALL   1730
540E:  MOVFF  02,134
5412:  MOVFF  01,133
5416:  MOVLB  1
5418:  MOVF   02,W
541A:  MOVLB  0
541C:  SUBWF  xA2,W
541E:  BNC   5432
5420:  BNZ   5436
5422:  MOVF   xA1,W
5424:  MOVLB  1
5426:  SUBWF  x33,W
5428:  BTFSC  FD8.0
542A:  BRA    5430
542C:  MOVLB  0
542E:  BRA    5436
5430:  MOVLB  0
5432:  MOVLW  00
5434:  BRA    5438
5436:  MOVLW  01
5438:  CLRF   03
543A:  IORWF  03,W
543C:  BZ    5474
543E:  MOVLW  FF
5440:  BSF    FD8.0
5442:  SUBFWB xA1,W
5444:  MOVLB  1
5446:  MOVWF  x33
5448:  MOVLW  FF
544A:  MOVLB  0
544C:  SUBFWB xA2,W
544E:  MOVLB  1
5450:  MOVWF  x34
5452:  MOVLB  0
5454:  CALL   1730
5458:  MOVF   01,W
545A:  MOVLB  1
545C:  ADDWF  x33,F
545E:  MOVF   02,W
5460:  ADDWFC x34,F
5462:  MOVLW  01
5464:  ADDWF  x33,W
5466:  MOVWF  01
5468:  MOVLW  00
546A:  ADDWFC x34,W
546C:  MOVWF  03
546E:  MOVF   01,W
5470:  BRA    5494
5472:  MOVLB  0
5474:  CALL   1730
5478:  MOVFF  02,134
547C:  MOVFF  01,133
5480:  MOVF   xA1,W
5482:  MOVLB  1
5484:  SUBWF  01,W
5486:  MOVWF  00
5488:  MOVLB  0
548A:  MOVF   xA2,W
548C:  MOVLB  1
548E:  SUBWFB 02,W
5490:  MOVWF  03
5492:  MOVF   00,W
5494:  MOVWF  x31
5496:  MOVFF  03,132
....................  
....................         if(tickDiff >= TICKS_PER_SECOND) 
549A:  MOVF   x32,F
549C:  BNZ   54A4
549E:  MOVF   x31,W
54A0:  SUBLW  09
54A2:  BC    54FE
....................         { 
....................          do 
....................          { 
....................                DHCPLeaseTime.Val--; 
54A4:  MOVLW  FF
54A6:  MOVLB  0
54A8:  ADDWF  x8F,F
54AA:  BTFSS  FD8.0
54AC:  ADDWF  x90,F
54AE:  BTFSS  FD8.0
54B0:  ADDWF  x91,F
54B2:  BTFSS  FD8.0
54B4:  ADDWF  x92,F
....................             tickDiff -= TICKS_PER_SECOND; 
54B6:  MOVLW  0A
54B8:  MOVLB  1
54BA:  SUBWF  x31,F
54BC:  MOVLW  00
54BE:  SUBWFB x32,F
....................                if(DHCPLeaseTime.Val == 0u) 
54C0:  MOVLB  0
54C2:  MOVF   x8F,F
54C4:  BNZ   54D6
54C6:  MOVF   x90,F
54C8:  BNZ   54D6
54CA:  MOVF   x91,F
54CC:  BNZ   54D6
54CE:  MOVF   x92,F
54D0:  BNZ   54D6
....................                   smDHCPState = SM_DHCP_INIT; 
54D2:  MOVLW  01
54D4:  MOVWF  x85
....................          } while(tickDiff >= TICKS_PER_SECOND); 
54D6:  MOVLB  1
54D8:  MOVF   x32,F
54DA:  BNZ   54A4
54DC:  MOVF   x31,W
54DE:  SUBLW  09
54E0:  BNC   54A4
....................             lastTryTick = TickGet() - tickDiff; 
54E2:  MOVLB  0
54E4:  CALL   1730
54E8:  MOVLB  1
54EA:  MOVF   x31,W
54EC:  SUBWF  01,W
54EE:  MOVLB  0
54F0:  MOVWF  xA1
54F2:  MOVLB  1
54F4:  MOVF   x32,W
54F6:  SUBWFB 02,W
54F8:  MOVLB  0
54FA:  MOVWF  xA2
54FC:  MOVLB  1
54FE:  MOVLB  0
....................         } 
....................     } 
....................  
....................    /*if (debugLastState != smDHCPState) 
....................    { 
....................       debug_dhcp("\r\nDHCP TASK - ", ); 
....................       DebugDHCPDisplayState(debugLastState); 
....................       debug_dhcp(" -> "); 
....................       DebugDHCPDisplayState(smDHCPState); 
....................    }*/ 
.................... } 
5500:  GOTO   56E2 (RETURN)
....................  
.................... /********************************************************************* 
....................         DHCP PACKET FORMAT AS PER RFC 1541 
....................  
....................    0                   1                   2                   3 
....................    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
....................    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
....................    |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
....................    +---------------+---------------+---------------+---------------+ 
....................    |                            xid (4)                            | 
....................    +-------------------------------+-------------------------------+ 
....................    |           secs (2)            |           flags (2)           | 
....................    +-------------------------------+-------------------------------+ 
....................    |                          ciaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          yiaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          siaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          giaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          chaddr  (16)                         | 
....................    |                                                               | 
....................    |                                                               | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          sname   (64)                         | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          file    (128)                        | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          options (312)                        | 
....................    +---------------------------------------------------------------+ 
....................  
....................  ********************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
....................     BYTE v; 
....................     BYTE i, j; 
....................     BYTE type; 
....................     BOOL lbDone; 
....................     DWORD_VAL tempServerID; 
....................  
....................  
....................     // Assume unknown message until proven otherwise. 
....................     type = DHCP_UNKNOWN_MESSAGE; 
*
4CBE:  MOVLB  1
4CC0:  CLRF   x36
....................  
....................     UDPGet(&v);                             // op 
4CC2:  MOVLW  01
4CC4:  MOVWF  x3D
4CC6:  MOVLW  33
4CC8:  MOVWF  x3C
4CCA:  MOVLB  0
4CCC:  RCALL  4B44
....................  
....................     //Make sure this is BOOT_REPLY. 
....................     if ( v == BOOT_REPLY ) 
4CCE:  MOVLB  1
4CD0:  MOVF   x33,W
4CD2:  SUBLW  02
4CD4:  BTFSS  FD8.2
4CD6:  BRA    506E
....................     { 
....................         //Discard htype, hlen, hops, xid, secs, flags, ciaddr. 
....................         for ( i = 0; i < 15u; i++ ) 
4CD8:  CLRF   x34
4CDA:  MOVF   x34,W
4CDC:  SUBLW  0E
4CDE:  BNC   4CF2
....................             UDPGet(&v); 
4CE0:  MOVLW  01
4CE2:  MOVWF  x3D
4CE4:  MOVLW  33
4CE6:  MOVWF  x3C
4CE8:  MOVLB  0
4CEA:  RCALL  4B44
4CEC:  MOVLB  1
4CEE:  INCF   x34,F
4CF0:  BRA    4CDA
....................  
....................       // Check to see if this is the first offer 
....................       if(DHCPState.bits.bOfferReceived) 
4CF2:  MOVLB  0
4CF4:  BTFSS  x86.1
4CF6:  BRA    4D18
....................       { 
....................            // Discard offered IP address, we already have an offer 
....................            for ( i = 0; i < 4u; i++ ) 
4CF8:  MOVLB  1
4CFA:  CLRF   x34
4CFC:  MOVF   x34,W
4CFE:  SUBLW  03
4D00:  BNC   4D14
....................                UDPGet(&v); 
4D02:  MOVLW  01
4D04:  MOVWF  x3D
4D06:  MOVLW  33
4D08:  MOVWF  x3C
4D0A:  MOVLB  0
4D0C:  RCALL  4B44
4D0E:  MOVLB  1
4D10:  INCF   x34,F
4D12:  BRA    4CFC
....................       } 
....................       else 
4D14:  BRA    4D4C
4D16:  MOVLB  0
....................       { 
....................            // Save offered IP address until we know for sure that we have it. 
....................            UDPGet(&tempIPAddress.v[0]); 
4D18:  MOVLB  1
4D1A:  CLRF   x3D
4D1C:  MOVLW  93
4D1E:  MOVWF  x3C
4D20:  MOVLB  0
4D22:  RCALL  4B44
....................            UDPGet(&tempIPAddress.v[1]); 
4D24:  MOVLB  1
4D26:  CLRF   x3D
4D28:  MOVLW  94
4D2A:  MOVWF  x3C
4D2C:  MOVLB  0
4D2E:  RCALL  4B44
....................            UDPGet(&tempIPAddress.v[2]); 
4D30:  MOVLB  1
4D32:  CLRF   x3D
4D34:  MOVLW  95
4D36:  MOVWF  x3C
4D38:  MOVLB  0
4D3A:  RCALL  4B44
....................            UDPGet(&tempIPAddress.v[3]); 
4D3C:  MOVLB  1
4D3E:  CLRF   x3D
4D40:  MOVLW  96
4D42:  MOVWF  x3C
4D44:  MOVLB  0
4D46:  RCALL  4B44
....................          ValidValues.bits.IPAddress = 1; 
4D48:  BSF    x9F.0
4D4A:  MOVLB  1
....................       } 
....................  
....................         //Ignore siaddr, giaddr 
....................         for ( i = 0; i < 8u; i++ ) 
4D4C:  CLRF   x34
4D4E:  MOVF   x34,W
4D50:  SUBLW  07
4D52:  BNC   4D66
....................             UDPGet(&v); 
4D54:  MOVLW  01
4D56:  MOVWF  x3D
4D58:  MOVLW  33
4D5A:  MOVWF  x3C
4D5C:  MOVLB  0
4D5E:  RCALL  4B44
4D60:  MOVLB  1
4D62:  INCF   x34,F
4D64:  BRA    4D4E
....................  
....................         //Check to see if chaddr (Client Hardware Address) belongs to us. 
....................         for ( i = 0; i < 6u; i++ ) 
4D66:  CLRF   x34
4D68:  MOVF   x34,W
4D6A:  SUBLW  05
4D6C:  BNC   4DA0
....................         { 
....................             UDPGet(&v); 
4D6E:  MOVLW  01
4D70:  MOVWF  x3D
4D72:  MOVLW  33
4D74:  MOVWF  x3C
4D76:  MOVLB  0
4D78:  RCALL  4B44
....................             if ( v != AppConfig.MyMACAddr.v[i]) 
4D7A:  CLRF   03
4D7C:  MOVLB  1
4D7E:  MOVF   x34,W
4D80:  ADDLW  04
4D82:  MOVWF  01
4D84:  MOVLW  00
4D86:  ADDWFC 03,F
4D88:  MOVF   01,W
4D8A:  ADDLW  16
4D8C:  MOVWF  FE9
4D8E:  MOVLW  00
4D90:  ADDWFC 03,W
4D92:  MOVWF  FEA
4D94:  MOVF   FEF,W
4D96:  SUBWF  x33,W
4D98:  BZ    4D9C
....................                 goto UDPInvalid; 
4D9A:  BRA    50C2
....................         } 
4D9C:  INCF   x34,F
4D9E:  BRA    4D68
....................  
....................         //Ignore part of chaddr, sname, file, magic cookie. 
....................         for ( i = 0; i < 206u; i++ ) 
4DA0:  CLRF   x34
4DA2:  MOVF   x34,W
4DA4:  SUBLW  CD
4DA6:  BNC   4DBA
....................             UDPGet(&v); 
4DA8:  MOVLW  01
4DAA:  MOVWF  x3D
4DAC:  MOVLW  33
4DAE:  MOVWF  x3C
4DB0:  MOVLB  0
4DB2:  RCALL  4B44
4DB4:  MOVLB  1
4DB6:  INCF   x34,F
4DB8:  BRA    4DA2
....................  
....................         lbDone = FALSE; 
4DBA:  BCF    x37.0
....................         do 
....................         { 
....................          // Get the Option number 
....................          // Break out eventually in case if this is a malformed 
....................          // DHCP message, ie: missing DHCP_END_OPTION marker 
....................          if(!UDPGet(&v)) 
4DBC:  MOVLW  01
4DBE:  MOVWF  x3D
4DC0:  MOVLW  33
4DC2:  MOVWF  x3C
4DC4:  MOVLB  0
4DC6:  RCALL  4B44
4DC8:  MOVF   01,F
4DCA:  BNZ   4DD4
....................          { 
....................             lbDone = TRUE; 
4DCC:  MOVLB  1
4DCE:  BSF    x37.0
....................             break; 
4DD0:  BRA    506E
4DD2:  MOVLB  0
....................          } 
....................  
....................             switch(v) 
....................             { 
4DD4:  MOVLB  1
4DD6:  MOVF   x33,W
4DD8:  XORLW  35
4DDA:  MOVLB  0
4DDC:  BZ    4DFC
4DDE:  XORLW  34
4DE0:  BZ    4E3C
4DE2:  XORLW  02
4DE4:  BTFSC  FD8.2
4DE6:  BRA    4EB4
4DE8:  XORLW  35
4DEA:  BTFSC  FD8.2
4DEC:  BRA    4F48
4DEE:  XORLW  C9
4DF0:  BTFSC  FD8.2
4DF2:  BRA    4F9E
4DF4:  XORLW  CC
4DF6:  BTFSC  FD8.2
4DF8:  BRA    4FA6
4DFA:  BRA    5042
....................             case DHCP_MESSAGE_TYPE: 
....................                 UDPGet(&v);                         // Skip len 
4DFC:  MOVLW  01
4DFE:  MOVLB  1
4E00:  MOVWF  x3D
4E02:  MOVLW  33
4E04:  MOVWF  x3C
4E06:  MOVLB  0
4E08:  RCALL  4B44
....................                 // Len must be 1. 
....................                 if ( v == 1u ) 
4E0A:  MOVLB  1
4E0C:  DECFSZ x33,W
4E0E:  BRA    4E36
....................                 { 
....................                     UDPGet(&type);                  // Get type 
4E10:  MOVLW  01
4E12:  MOVWF  x3D
4E14:  MOVLW  36
4E16:  MOVWF  x3C
4E18:  MOVLB  0
4E1A:  RCALL  4B44
....................  
....................                // Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
....................                if(DHCPState.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
4E1C:  BTFSS  x86.1
4E1E:  BRA    4E32
4E20:  MOVLB  1
4E22:  MOVF   x36,W
4E24:  SUBLW  02
4E26:  BTFSC  FD8.2
4E28:  BRA    4E2E
4E2A:  MOVLB  0
4E2C:  BRA    4E32
....................                { 
....................                   goto UDPInvalid; 
4E2E:  BRA    50C2
4E30:  MOVLB  0
....................                } 
....................             } 
....................                 else 
4E32:  BRA    4E3A
4E34:  MOVLB  1
....................                     goto UDPInvalid; 
4E36:  BRA    50C2
4E38:  MOVLB  0
....................                 break; 
4E3A:  BRA    5068
....................  
....................             case DHCP_SUBNET_MASK: 
....................                 UDPGet(&v);                     // Skip len 
4E3C:  MOVLW  01
4E3E:  MOVLB  1
4E40:  MOVWF  x3D
4E42:  MOVLW  33
4E44:  MOVWF  x3C
4E46:  MOVLB  0
4E48:  RCALL  4B44
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
4E4A:  MOVLB  1
4E4C:  MOVF   x33,W
4E4E:  SUBLW  04
4E50:  BNZ   4EAE
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
4E52:  MOVLB  0
4E54:  BTFSS  x86.1
4E56:  BRA    4E78
....................                { 
....................                     // Discard offered IP mask, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
4E58:  MOVLB  1
4E5A:  CLRF   x34
4E5C:  MOVF   x34,W
4E5E:  SUBLW  03
4E60:  BNC   4E74
....................                         UDPGet(&v); 
4E62:  MOVLW  01
4E64:  MOVWF  x3D
4E66:  MOVLW  33
4E68:  MOVWF  x3C
4E6A:  MOVLB  0
4E6C:  RCALL  4B44
4E6E:  MOVLB  1
4E70:  INCF   x34,F
4E72:  BRA    4E5C
....................                } 
....................                else 
4E74:  BRA    4EAC
4E76:  MOVLB  0
....................                { 
....................                        UDPGet(&tempMask.v[0]); 
4E78:  MOVLB  1
4E7A:  CLRF   x3D
4E7C:  MOVLW  9B
4E7E:  MOVWF  x3C
4E80:  MOVLB  0
4E82:  RCALL  4B44
....................                        UDPGet(&tempMask.v[1]); 
4E84:  MOVLB  1
4E86:  CLRF   x3D
4E88:  MOVLW  9C
4E8A:  MOVWF  x3C
4E8C:  MOVLB  0
4E8E:  RCALL  4B44
....................                        UDPGet(&tempMask.v[2]); 
4E90:  MOVLB  1
4E92:  CLRF   x3D
4E94:  MOVLW  9D
4E96:  MOVWF  x3C
4E98:  MOVLB  0
4E9A:  RCALL  4B44
....................                        UDPGet(&tempMask.v[3]); 
4E9C:  MOVLB  1
4E9E:  CLRF   x3D
4EA0:  MOVLW  9E
4EA2:  MOVWF  x3C
4EA4:  MOVLB  0
4EA6:  RCALL  4B44
....................                   ValidValues.bits.Mask = 1; 
4EA8:  BSF    x9F.2
4EAA:  MOVLB  1
....................                } 
....................                 } 
....................                 else 
4EAC:  BRA    4EB0
....................                     goto UDPInvalid; 
4EAE:  BRA    50C2
....................                 break; 
4EB0:  MOVLB  0
4EB2:  BRA    5068
....................  
....................             case DHCP_ROUTER: 
....................                 UDPGet(&j); 
4EB4:  MOVLW  01
4EB6:  MOVLB  1
4EB8:  MOVWF  x3D
4EBA:  MOVLW  35
4EBC:  MOVWF  x3C
4EBE:  MOVLB  0
4EC0:  RCALL  4B44
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
4EC2:  MOVLB  1
4EC4:  MOVF   x35,W
4EC6:  SUBLW  03
4EC8:  BC    4F26
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
4ECA:  MOVLB  0
4ECC:  BTFSS  x86.1
4ECE:  BRA    4EF0
....................                { 
....................                     // Discard offered Gateway address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
4ED0:  MOVLB  1
4ED2:  CLRF   x34
4ED4:  MOVF   x34,W
4ED6:  SUBLW  03
4ED8:  BNC   4EEC
....................                         UDPGet(&v); 
4EDA:  MOVLW  01
4EDC:  MOVWF  x3D
4EDE:  MOVLW  33
4EE0:  MOVWF  x3C
4EE2:  MOVLB  0
4EE4:  RCALL  4B44
4EE6:  MOVLB  1
4EE8:  INCF   x34,F
4EEA:  BRA    4ED4
....................                } 
....................                else 
4EEC:  BRA    4F24
4EEE:  MOVLB  0
....................                { 
....................                        UDPGet(&tempGateway.v[0]); 
4EF0:  MOVLB  1
4EF2:  CLRF   x3D
4EF4:  MOVLW  97
4EF6:  MOVWF  x3C
4EF8:  MOVLB  0
4EFA:  RCALL  4B44
....................                        UDPGet(&tempGateway.v[1]); 
4EFC:  MOVLB  1
4EFE:  CLRF   x3D
4F00:  MOVLW  98
4F02:  MOVWF  x3C
4F04:  MOVLB  0
4F06:  RCALL  4B44
....................                        UDPGet(&tempGateway.v[2]); 
4F08:  MOVLB  1
4F0A:  CLRF   x3D
4F0C:  MOVLW  99
4F0E:  MOVWF  x3C
4F10:  MOVLB  0
4F12:  RCALL  4B44
....................                        UDPGet(&tempGateway.v[3]); 
4F14:  MOVLB  1
4F16:  CLRF   x3D
4F18:  MOVLW  9A
4F1A:  MOVWF  x3C
4F1C:  MOVLB  0
4F1E:  RCALL  4B44
....................                   ValidValues.bits.Gateway = 1; 
4F20:  BSF    x9F.1
4F22:  MOVLB  1
....................                } 
....................                 } 
....................                 else 
4F24:  BRA    4F28
....................                     goto UDPInvalid; 
4F26:  BRA    50C2
....................  
....................                 // Discard any other router addresses. 
....................                 j -= 4; 
4F28:  MOVLW  04
4F2A:  SUBWF  x35,F
....................                 while(j--) 
....................                     UDPGet(&v); 
4F2C:  MOVF   x35,W
4F2E:  DECF   x35,F
4F30:  XORLW  00
4F32:  BZ    4F44
4F34:  MOVLW  01
4F36:  MOVWF  x3D
4F38:  MOVLW  33
4F3A:  MOVWF  x3C
4F3C:  MOVLB  0
4F3E:  RCALL  4B44
4F40:  MOVLB  1
4F42:  BRA    4F2C
....................                 break; 
4F44:  MOVLB  0
4F46:  BRA    5068
....................  
.................... #if STACK_USE_DNS 
....................             case DHCP_DNS: 
....................                 UDPGet(&j); 
....................                 // Len must be >= 4. 
....................                 if ( j >= 4u ) 
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
....................                { 
....................                     // Discard offered DNS server address, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
....................                         UDPGet(&v); 
....................                } 
....................                else 
....................                { 
....................                        UDPGet(&tempDNS.v[0]); 
....................                        UDPGet(&tempDNS.v[1]); 
....................                        UDPGet(&tempDNS.v[2]); 
....................                        UDPGet(&tempDNS.v[3]); 
....................                   ValidValues.bits.DNS = 1; 
....................                } 
....................                 } 
....................                 else 
....................                     goto UDPInvalid; 
....................  
....................                 // Discard any other DNS server addresses 
....................                 j -= 4; 
....................                 while(j--) 
....................                     UDPGet(&v); 
....................                 break; 
.................... #endif 
....................  
.................... //            case DHCP_HOST_NAME: 
.................... //                UDPGet(&j); 
.................... //                // Len must be >= 4. 
.................... //                if(j < 1u) 
.................... //               goto UDPInvalid; 
.................... // 
.................... //            // Check to see if this is the first offer 
.................... //            if(DHCPState.bits.bOfferReceived) 
.................... //            { 
.................... //                 // Discard offered host name, we already have an offer 
.................... //                   while(j--) 
.................... //                       UDPGet(&v); 
.................... //            } 
.................... //            else 
.................... //            { 
.................... //               for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
.................... //               { 
.................... //                  UDPGet(&tempHostName[i]); 
.................... //               } 
.................... //               while(j--) 
.................... //               { 
.................... //                  UDPGet(&v); 
.................... //               } 
.................... //               ValidValues.bits.HostName = 1; 
.................... //            } 
.................... // 
.................... //                break; 
....................  
....................             case DHCP_SERVER_IDENTIFIER: 
....................                 UDPGet(&v);                         // Get len 
4F48:  MOVLW  01
4F4A:  MOVLB  1
4F4C:  MOVWF  x3D
4F4E:  MOVLW  33
4F50:  MOVWF  x3C
4F52:  MOVLB  0
4F54:  RCALL  4B44
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
4F56:  MOVLB  1
4F58:  MOVF   x33,W
4F5A:  SUBLW  04
4F5C:  BNZ   4F98
....................                 { 
....................                     UDPGet(&tempServerID.v[3]);   // Get the id 
4F5E:  MOVLW  01
4F60:  MOVWF  x3D
4F62:  MOVLW  3B
4F64:  MOVWF  x3C
4F66:  MOVLB  0
4F68:  RCALL  4B44
....................                     UDPGet(&tempServerID.v[2]); 
4F6A:  MOVLW  01
4F6C:  MOVLB  1
4F6E:  MOVWF  x3D
4F70:  MOVLW  3A
4F72:  MOVWF  x3C
4F74:  MOVLB  0
4F76:  RCALL  4B44
....................                     UDPGet(&tempServerID.v[1]); 
4F78:  MOVLW  01
4F7A:  MOVLB  1
4F7C:  MOVWF  x3D
4F7E:  MOVLW  39
4F80:  MOVWF  x3C
4F82:  MOVLB  0
4F84:  RCALL  4B44
....................                     UDPGet(&tempServerID.v[0]); 
4F86:  MOVLW  01
4F88:  MOVLB  1
4F8A:  MOVWF  x3D
4F8C:  MOVLW  38
4F8E:  MOVWF  x3C
4F90:  MOVLB  0
4F92:  RCALL  4B44
....................                 } 
....................                 else 
4F94:  BRA    4F9C
4F96:  MOVLB  1
....................                     goto UDPInvalid; 
4F98:  BRA    50C2
4F9A:  MOVLB  0
....................                 break; 
4F9C:  BRA    5068
....................  
....................             case DHCP_END_OPTION: 
....................                 lbDone = TRUE; 
4F9E:  MOVLB  1
4FA0:  BSF    x37.0
....................                 break; 
4FA2:  MOVLB  0
4FA4:  BRA    5068
....................  
....................             case DHCP_IP_LEASE_TIME: 
....................                 UDPGet(&v);                         // Get len 
4FA6:  MOVLW  01
4FA8:  MOVLB  1
4FAA:  MOVWF  x3D
4FAC:  MOVLW  33
4FAE:  MOVWF  x3C
4FB0:  MOVLB  0
4FB2:  RCALL  4B44
....................                 // Len must be 4. 
....................                 if ( v == 4u ) 
4FB4:  MOVLB  1
4FB6:  MOVF   x33,W
4FB8:  SUBLW  04
4FBA:  BNZ   503C
....................                 { 
....................                // Check to see if this is the first offer 
....................                if(DHCPState.bits.bOfferReceived) 
4FBC:  MOVLB  0
4FBE:  BTFSS  x86.1
4FC0:  BRA    4FE2
....................                { 
....................                     // Discard offered lease time, we already have an offer 
....................                     for ( i = 0; i < 4u; i++ ) 
4FC2:  MOVLB  1
4FC4:  CLRF   x34
4FC6:  MOVF   x34,W
4FC8:  SUBLW  03
4FCA:  BNC   4FDE
....................                         UDPGet(&v); 
4FCC:  MOVLW  01
4FCE:  MOVWF  x3D
4FD0:  MOVLW  33
4FD2:  MOVWF  x3C
4FD4:  MOVLB  0
4FD6:  RCALL  4B44
4FD8:  MOVLB  1
4FDA:  INCF   x34,F
4FDC:  BRA    4FC6
....................                } 
....................                else 
4FDE:  BRA    503A
4FE0:  MOVLB  0
....................                { 
....................                        UDPGet(&DHCPLeaseTime.v[3]); 
4FE2:  MOVLB  1
4FE4:  CLRF   x3D
4FE6:  MOVLW  92
4FE8:  MOVWF  x3C
4FEA:  MOVLB  0
4FEC:  RCALL  4B44
....................                        UDPGet(&DHCPLeaseTime.v[2]); 
4FEE:  MOVLB  1
4FF0:  CLRF   x3D
4FF2:  MOVLW  91
4FF4:  MOVWF  x3C
4FF6:  MOVLB  0
4FF8:  RCALL  4B44
....................                        UDPGet(&DHCPLeaseTime.v[1]); 
4FFA:  MOVLB  1
4FFC:  CLRF   x3D
4FFE:  MOVLW  90
5000:  MOVWF  x3C
5002:  MOVLB  0
5004:  RCALL  4B44
....................                        UDPGet(&DHCPLeaseTime.v[0]); 
5006:  MOVLB  1
5008:  CLRF   x3D
500A:  MOVLW  8F
500C:  MOVWF  x3C
500E:  MOVLB  0
5010:  RCALL  4B44
....................  
....................                        // Due to possible timing delays, consider actual lease 
....................                        // time less by half hour. 
....................                        if ( DHCPLeaseTime.Val > HALF_HOUR ) 
5012:  MOVF   x92,F
5014:  BNZ   502A
5016:  MOVF   x91,F
5018:  BNZ   502A
501A:  MOVF   x90,W
501C:  SUBLW  06
501E:  BC    5038
5020:  XORLW  FF
5022:  BNZ   502A
5024:  MOVF   x8F,W
5026:  SUBLW  08
5028:  BC    5038
....................                            DHCPLeaseTime.Val = DHCPLeaseTime.Val - HALF_HOUR; 
502A:  MOVLW  08
502C:  SUBWF  x8F,F
502E:  MOVLW  07
5030:  SUBWFB x90,F
5032:  MOVLW  00
5034:  SUBWFB x91,F
5036:  SUBWFB x92,F
5038:  MOVLB  1
....................                } 
....................                 } 
....................                 else 
503A:  BRA    503E
....................                     goto UDPInvalid; 
503C:  BRA    50C2
....................                 break; 
503E:  MOVLB  0
5040:  BRA    5068
....................  
....................             default: 
....................                 // Ignore all unsupport tags. 
....................                 UDPGet(&j);                     // Get option len 
5042:  MOVLW  01
5044:  MOVLB  1
5046:  MOVWF  x3D
5048:  MOVLW  35
504A:  MOVWF  x3C
504C:  MOVLB  0
504E:  RCALL  4B44
....................                 while( j-- )                    // Ignore option values 
....................                     UDPGet(&v); 
5050:  MOVLB  1
5052:  MOVF   x35,W
5054:  DECF   x35,F
5056:  XORLW  00
5058:  BZ    506A
505A:  MOVLW  01
505C:  MOVWF  x3D
505E:  MOVLW  33
5060:  MOVWF  x3C
5062:  MOVLB  0
5064:  RCALL  4B44
5066:  BRA    5050
5068:  MOVLB  1
....................             } 
....................         } while( !lbDone ); 
506A:  BTFSS  x37.0
506C:  BRA    4DBC
....................     } 
....................  
....................     // If this is an OFFER message, remember current server id. 
....................     if ( type == DHCP_OFFER_MESSAGE ) 
506E:  MOVF   x36,W
5070:  SUBLW  02
5072:  BNZ   508C
....................     { 
....................         DHCPServerID.Val = tempServerID.Val; 
5074:  MOVFF  13B,8E
5078:  MOVFF  13A,8D
507C:  MOVFF  139,8C
5080:  MOVFF  138,8B
....................       DHCPState.bits.bOfferReceived = TRUE; 
5084:  MOVLB  0
5086:  BSF    x86.1
....................     } 
....................     else 
5088:  BRA    50B8
508A:  MOVLB  1
....................     { 
....................         // For other types of messages, make sure that received 
....................         // server id matches with our previous one. 
....................         if ( DHCPServerID.Val != tempServerID.Val ) 
508C:  MOVF   x38,W
508E:  MOVLB  0
5090:  SUBWF  x8B,W
5092:  BNZ   50B2
5094:  MOVLB  1
5096:  MOVF   x39,W
5098:  MOVLB  0
509A:  SUBWF  x8C,W
509C:  BNZ   50B2
509E:  MOVLB  1
50A0:  MOVF   x3A,W
50A2:  MOVLB  0
50A4:  SUBWF  x8D,W
50A6:  BNZ   50B2
50A8:  MOVLB  1
50AA:  MOVF   x3B,W
50AC:  MOVLB  0
50AE:  SUBWF  x8E,W
50B0:  BZ    50B8
....................             type = DHCP_UNKNOWN_MESSAGE; 
50B2:  MOVLB  1
50B4:  CLRF   x36
50B6:  MOVLB  0
....................     } 
....................  
....................     UDPDiscard();                             // We are done with this packet 
50B8:  RCALL  4C5E
....................     return type; 
50BA:  MOVLB  1
50BC:  MOVFF  136,01
50C0:  BRA    50CC
....................  
.................... UDPInvalid: 
....................     UDPDiscard(); 
50C2:  MOVLB  0
50C4:  RCALL  4C5E
....................     return DHCP_UNKNOWN_MESSAGE; 
50C6:  MOVLW  00
50C8:  MOVWF  01
50CA:  MOVLB  1
....................  
.................... } 
50CC:  MOVLB  0
50CE:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... static void _DHCPSend(BYTE messageType) 
.................... { 
....................     BYTE  i; 
....................  
....................     UDPPut(BOOT_REQUEST);                       // op 
*
490A:  MOVLW  01
490C:  MOVLB  1
490E:  MOVWF  x35
4910:  MOVLB  0
4912:  RCALL  47D0
....................     UDPPut(HW_TYPE);                            // htype 
4914:  MOVLW  01
4916:  MOVLB  1
4918:  MOVWF  x35
491A:  MOVLB  0
491C:  RCALL  47D0
....................     UDPPut(LEN_OF_HW_TYPE);                     // hlen 
491E:  MOVLW  06
4920:  MOVLB  1
4922:  MOVWF  x35
4924:  MOVLB  0
4926:  RCALL  47D0
....................     UDPPut(0);                                  // hops 
4928:  MOVLB  1
492A:  CLRF   x35
492C:  MOVLB  0
492E:  RCALL  47D0
....................     UDPPut(0x12);                               // xid[0] 
4930:  MOVLW  12
4932:  MOVLB  1
4934:  MOVWF  x35
4936:  MOVLB  0
4938:  RCALL  47D0
....................     UDPPut(0x23);                               // xid[1] 
493A:  MOVLW  23
493C:  MOVLB  1
493E:  MOVWF  x35
4940:  MOVLB  0
4942:  RCALL  47D0
....................     UDPPut(0x34);                               // xid[2] 
4944:  MOVLW  34
4946:  MOVLB  1
4948:  MOVWF  x35
494A:  MOVLB  0
494C:  RCALL  47D0
....................     UDPPut(0x56);                               // xid[3] 
494E:  MOVLW  56
4950:  MOVLB  1
4952:  MOVWF  x35
4954:  MOVLB  0
4956:  RCALL  47D0
....................     UDPPut(0);                                  // secs[0] 
4958:  MOVLB  1
495A:  CLRF   x35
495C:  MOVLB  0
495E:  RCALL  47D0
....................     UDPPut(0);                                  // secs[1] 
4960:  MOVLB  1
4962:  CLRF   x35
4964:  MOVLB  0
4966:  RCALL  47D0
....................     UDPPut(0x80);                               // flags[0] with BF set 
4968:  MOVLW  80
496A:  MOVLB  1
496C:  MOVWF  x35
496E:  MOVLB  0
4970:  RCALL  47D0
....................     UDPPut(0);                                  // flags[1] 
4972:  MOVLB  1
4974:  CLRF   x35
4976:  MOVLB  0
4978:  RCALL  47D0
....................  
....................  
....................      // If this is DHCP REQUEST message, use previously allocated IP address. 
.................... #if 0 
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
....................     { 
....................         UDPPut(tempIPAddress.v[0]); 
....................         UDPPut(tempIPAddress.v[1]); 
....................         UDPPut(tempIPAddress.v[2]); 
....................         UDPPut(tempIPAddress.v[3]); 
....................     } 
....................     else 
.................... #endif 
....................     { 
....................         UDPPut(0x00); 
497A:  MOVLB  1
497C:  CLRF   x35
497E:  MOVLB  0
4980:  RCALL  47D0
....................         UDPPut(0x00); 
4982:  MOVLB  1
4984:  CLRF   x35
4986:  MOVLB  0
4988:  RCALL  47D0
....................         UDPPut(0x00); 
498A:  MOVLB  1
498C:  CLRF   x35
498E:  MOVLB  0
4990:  RCALL  47D0
....................         UDPPut(0x00); 
4992:  MOVLB  1
4994:  CLRF   x35
4996:  MOVLB  0
4998:  RCALL  47D0
....................     } 
....................  
....................     // Set yiaddr, siaddr, giaddr as zeros, 
....................     for ( i = 0; i < 12u; i++ ) 
499A:  MOVLB  1
499C:  CLRF   x34
499E:  MOVF   x34,W
49A0:  SUBLW  0B
49A2:  BNC   49B0
....................         UDPPut(0x00); 
49A4:  CLRF   x35
49A6:  MOVLB  0
49A8:  RCALL  47D0
49AA:  MOVLB  1
49AC:  INCF   x34,F
49AE:  BRA    499E
....................  
....................     // Load chaddr - Client hardware address. 
....................     UDPPut(AppConfig.MyMACAddr.v[0]); 
49B0:  MOVFF  1A,135
49B4:  MOVLB  0
49B6:  RCALL  47D0
....................     UDPPut(AppConfig.MyMACAddr.v[1]); 
49B8:  MOVFF  1B,135
49BC:  RCALL  47D0
....................     UDPPut(AppConfig.MyMACAddr.v[2]); 
49BE:  MOVFF  1C,135
49C2:  RCALL  47D0
....................     UDPPut(AppConfig.MyMACAddr.v[3]); 
49C4:  MOVFF  1D,135
49C8:  RCALL  47D0
....................     UDPPut(AppConfig.MyMACAddr.v[4]); 
49CA:  MOVFF  1E,135
49CE:  RCALL  47D0
....................     UDPPut(AppConfig.MyMACAddr.v[5]); 
49D0:  MOVFF  1F,135
49D4:  RCALL  47D0
....................  
....................     // Set chaddr[6..15], sname and file as zeros. 
....................     for ( i = 0; i < 202u; i++ ) 
49D6:  MOVLB  1
49D8:  CLRF   x34
49DA:  MOVF   x34,W
49DC:  SUBLW  C9
49DE:  BNC   49EC
....................         UDPPut(0); 
49E0:  CLRF   x35
49E2:  MOVLB  0
49E4:  RCALL  47D0
49E6:  MOVLB  1
49E8:  INCF   x34,F
49EA:  BRA    49DA
....................  
....................     // Load magic cookie as per RFC 1533. 
....................     UDPPut(99); 
49EC:  MOVLW  63
49EE:  MOVWF  x35
49F0:  MOVLB  0
49F2:  RCALL  47D0
....................     UDPPut(130); 
49F4:  MOVLW  82
49F6:  MOVLB  1
49F8:  MOVWF  x35
49FA:  MOVLB  0
49FC:  RCALL  47D0
....................     UDPPut(83); 
49FE:  MOVLW  53
4A00:  MOVLB  1
4A02:  MOVWF  x35
4A04:  MOVLB  0
4A06:  RCALL  47D0
....................     UDPPut(99); 
4A08:  MOVLW  63
4A0A:  MOVLB  1
4A0C:  MOVWF  x35
4A0E:  MOVLB  0
4A10:  RCALL  47D0
....................  
....................     // Load message type. 
....................     UDPPut(DHCP_MESSAGE_TYPE); 
4A12:  MOVLW  35
4A14:  MOVLB  1
4A16:  MOVWF  x35
4A18:  MOVLB  0
4A1A:  RCALL  47D0
....................     UDPPut(DHCP_MESSAGE_TYPE_LEN); 
4A1C:  MOVLW  01
4A1E:  MOVLB  1
4A20:  MOVWF  x35
4A22:  MOVLB  0
4A24:  RCALL  47D0
....................     UDPPut(messageType); 
4A26:  MOVFF  133,135
4A2A:  RCALL  47D0
....................  
....................    if(messageType == DHCP_DISCOVER_MESSAGE) 
4A2C:  MOVLB  1
4A2E:  DECFSZ x33,W
4A30:  BRA    4A38
....................    { 
....................       // Reset offered flag so we know to act upon the next valid offer 
....................       DHCPState.bits.bOfferReceived = FALSE; 
4A32:  MOVLB  0
4A34:  BCF    x86.1
4A36:  MOVLB  1
....................    } 
....................  
....................     if ( messageType != DHCP_DISCOVER_MESSAGE && tempIPAddress.Val != 0x0000u ) 
4A38:  DECFSZ x33,W
4A3A:  BRA    4A3E
4A3C:  BRA    4A84
4A3E:  MOVLB  0
4A40:  MOVF   x93,F
4A42:  BNZ   4A56
4A44:  MOVF   x94,F
4A46:  BNZ   4A56
4A48:  MOVF   x95,F
4A4A:  BNZ   4A56
4A4C:  MOVF   x96,F
4A4E:  BTFSS  FD8.2
4A50:  BRA    4A56
4A52:  MOVLB  1
4A54:  BRA    4A84
....................     { 
....................          // DHCP REQUEST message may include server identifier, 
....................          // to identify the server we are talking to. 
....................          // DHCP ACK may include it too.  To simplify logic, 
....................          // we will include server identifier in DHCP ACK message too. 
....................          // _DHCPReceive() would populate "serverID" when it 
....................          // receives DHCP OFFER message. We will simply use that 
....................          // when we are replying to server. 
....................          // If this is a renwal request, do not include server id. 
....................          UDPPut(DHCP_SERVER_IDENTIFIER); 
4A56:  MOVLW  36
4A58:  MOVLB  1
4A5A:  MOVWF  x35
4A5C:  MOVLB  0
4A5E:  RCALL  47D0
....................          UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
4A60:  MOVLW  04
4A62:  MOVLB  1
4A64:  MOVWF  x35
4A66:  MOVLB  0
4A68:  RCALL  47D0
....................          UDPPut(DHCPServerID.v[3]); 
4A6A:  MOVFF  8E,135
4A6E:  RCALL  47D0
....................          UDPPut(DHCPServerID.v[2]); 
4A70:  MOVFF  8D,135
4A74:  RCALL  47D0
....................          UDPPut(DHCPServerID.v[1]); 
4A76:  MOVFF  8C,135
4A7A:  RCALL  47D0
....................          UDPPut(DHCPServerID.v[0]); 
4A7C:  MOVFF  8B,135
4A80:  RCALL  47D0
4A82:  MOVLB  1
....................      } 
....................  
....................     // Load our interested parameters 
....................     // This is hardcoded list.  If any new parameters are desired, 
....................     // new lines must be added here. 
....................     UDPPut(DHCP_PARAM_REQUEST_LIST); 
4A84:  MOVLW  37
4A86:  MOVWF  x35
4A88:  MOVLB  0
4A8A:  RCALL  47D0
....................     UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
4A8C:  MOVLW  04
4A8E:  MOVLB  1
4A90:  MOVWF  x35
4A92:  MOVLB  0
4A94:  RCALL  47D0
....................     UDPPut(DHCP_SUBNET_MASK); 
4A96:  MOVLW  01
4A98:  MOVLB  1
4A9A:  MOVWF  x35
4A9C:  MOVLB  0
4A9E:  RCALL  47D0
....................     UDPPut(DHCP_ROUTER); 
4AA0:  MOVLW  03
4AA2:  MOVLB  1
4AA4:  MOVWF  x35
4AA6:  MOVLB  0
4AA8:  RCALL  47D0
....................     UDPPut(DHCP_DNS); 
4AAA:  MOVLW  06
4AAC:  MOVLB  1
4AAE:  MOVWF  x35
4AB0:  MOVLB  0
4AB2:  RCALL  47D0
....................     UDPPut(DHCP_HOST_NAME); 
4AB4:  MOVLW  0C
4AB6:  MOVLB  1
4AB8:  MOVWF  x35
4ABA:  MOVLB  0
4ABC:  RCALL  47D0
....................  
....................     if ( messageType == DHCP_REQUEST_MESSAGE ) 
4ABE:  MOVLB  1
4AC0:  MOVF   x33,W
4AC2:  SUBLW  03
4AC4:  BNZ   4AF2
....................     { 
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
4AC6:  MOVLW  32
4AC8:  MOVWF  x35
4ACA:  MOVLB  0
4ACC:  RCALL  47D0
....................         UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
4ACE:  MOVLW  04
4AD0:  MOVLB  1
4AD2:  MOVWF  x35
4AD4:  MOVLB  0
4AD6:  RCALL  47D0
....................  
....................         UDPPut(tempIPAddress.v[0]); 
4AD8:  MOVFF  93,135
4ADC:  RCALL  47D0
....................         UDPPut(tempIPAddress.v[1]); 
4ADE:  MOVFF  94,135
4AE2:  RCALL  47D0
....................         UDPPut(tempIPAddress.v[2]); 
4AE4:  MOVFF  95,135
4AE8:  RCALL  47D0
....................         UDPPut(tempIPAddress.v[3]); 
4AEA:  MOVFF  96,135
4AEE:  RCALL  47D0
4AF0:  MOVLB  1
....................     } 
....................  
....................     // Add any new paramter request here. 
....................  
....................     // End of Options. 
....................     UDPPut(DHCP_END_OPTION); 
4AF2:  MOVLW  FF
4AF4:  MOVWF  x35
4AF6:  MOVLB  0
4AF8:  RCALL  47D0
....................  
....................     UDPFlush(); 
4AFA:  RCALL  4682
.................... } 
4AFC:  RETLW  00
....................  
....................  
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
107A:  BCF    56.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
107C:  MOVLW  FF
107E:  MOVWF  xA3
....................     Cache.MACAddr.v[1] = 0xff; 
1080:  MOVWF  xA4
....................     Cache.MACAddr.v[2] = 0xff; 
1082:  MOVWF  xA5
....................     Cache.MACAddr.v[3] = 0xff; 
1084:  MOVWF  xA6
....................     Cache.MACAddr.v[4] = 0xff; 
1086:  MOVWF  xA7
....................     Cache.MACAddr.v[5] = 0xff; 
1088:  MOVWF  xA8
....................  
....................     Cache.IPAddr.Val = 0x0; 
108A:  CLRF   xAC
108C:  CLRF   xAB
108E:  CLRF   xAA
1090:  CLRF   xA9
.................... } 
1092:  GOTO   115C (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
3688:  MOVLW  00
368A:  BTFSC  56.1
368C:  MOVLW  01
368E:  XORLW  00
3690:  BZ    3694
3692:  BRA    36F0
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
3694:  MOVLW  01
3696:  MOVLB  1
3698:  MOVWF  x32
369A:  MOVLW  26
369C:  MOVWF  x31
369E:  MOVLW  01
36A0:  MOVWF  x34
36A2:  MOVLW  30
36A4:  MOVWF  x33
36A6:  MOVLB  0
36A8:  BRA    2FE4
36AA:  MOVF   01,F
36AC:  BNZ   36B0
....................             break; 
36AE:  BRA    3710
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
36B0:  CALL   2CF4
....................  
....................         if ( opCode == ARP_REPLY ) 
36B4:  MOVLB  1
36B6:  MOVF   x30,F
36B8:  BNZ   36EC
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
36BA:  CLRF   FEA
36BC:  MOVLW  A3
36BE:  MOVWF  FE9
36C0:  MOVLW  01
36C2:  MOVWF  FE2
36C4:  MOVLW  26
36C6:  MOVWF  FE1
36C8:  MOVLW  06
36CA:  MOVWF  01
36CC:  MOVFF  FE6,FEE
36D0:  DECFSZ 01,F
36D2:  BRA    36CC
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
36D4:  MOVFF  12F,AC
36D8:  MOVFF  12E,AB
36DC:  MOVFF  12D,AA
36E0:  MOVFF  12C,A9
....................             break; 
36E4:  MOVLB  0
36E6:  BRA    3710
....................         } 
....................         else 
36E8:  BRA    36F0
36EA:  MOVLB  1
....................             smARP = SM_ARP_REPLY; 
36EC:  BSF    56.1
36EE:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
36F0:  MOVLW  01
36F2:  MOVLB  1
36F4:  MOVWF  x32
36F6:  MOVLW  26
36F8:  MOVWF  x31
36FA:  CLRF   x33
36FC:  MOVLB  0
36FE:  RCALL  34FC
3700:  MOVF   01,F
3702:  BZ    3708
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
3704:  BCF    56.1
.................... 		} 
....................         else 
3706:  BRA    370E
....................             return FALSE; 
3708:  MOVLW  00
370A:  MOVWF  01
370C:  BRA    3714
....................         break; 
370E:  BRA    3710
....................  
....................     } 
....................     return TRUE; 
3710:  MOVLW  01
3712:  MOVWF  01
.................... } 
3714:  GOTO   55B4 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
5720:  MOVLB  1
5722:  MOVFF  122,FE9
5726:  MOVFF  123,FEA
572A:  MOVFF  FEF,00
572E:  MOVFF  FEC,01
5732:  MOVFF  FEC,02
5736:  MOVFF  FEC,03
573A:  MOVFF  03,12D
573E:  MOVFF  02,12C
5742:  MOVFF  01,12B
5746:  MOVFF  00,12A
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
574A:  MOVLW  01
574C:  MOVWF  x32
574E:  MOVLW  24
5750:  MOVWF  x31
5752:  MOVLW  01
5754:  MOVWF  x33
5756:  MOVLB  0
5758:  CALL   34FC
.................... } 
575C:  GOTO   5844 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
5760:  MOVLB  1
5762:  MOVFF  122,FE9
5766:  MOVFF  123,FEA
576A:  MOVFF  FEF,00
576E:  MOVFF  FEC,01
5772:  MOVFF  FEC,02
5776:  MOVFF  FEC,03
577A:  MOVF   00,W
577C:  MOVLB  0
577E:  SUBWF  xA9,W
5780:  BNZ   5794
5782:  MOVF   01,W
5784:  SUBWF  xAA,W
5786:  BNZ   5794
5788:  MOVF   02,W
578A:  SUBWF  xAB,W
578C:  BNZ   5794
578E:  MOVF   03,W
5790:  SUBWF  xAC,W
5792:  BZ    57AC
5794:  MOVF   24,W
5796:  SUBWF  xA9,W
5798:  BNZ   57D4
579A:  MOVF   25,W
579C:  SUBWF  xAA,W
579E:  BNZ   57D4
57A0:  MOVF   26,W
57A2:  SUBWF  xAB,W
57A4:  BNZ   57D4
57A6:  MOVF   27,W
57A8:  SUBWF  xAC,W
57AA:  BNZ   57D4
....................     { 
....................         *MACAddr = Cache.MACAddr; 
57AC:  MOVFF  125,03
57B0:  MOVLB  1
57B2:  MOVFF  124,FE9
57B6:  MOVFF  125,FEA
57BA:  CLRF   FE2
57BC:  MOVLW  A3
57BE:  MOVWF  FE1
57C0:  MOVLW  06
57C2:  MOVWF  01
57C4:  MOVFF  FE6,FEE
57C8:  DECFSZ 01,F
57CA:  BRA    57C4
....................         return TRUE; 
57CC:  MOVLW  01
57CE:  MOVWF  01
57D0:  BRA    57DA
57D2:  MOVLB  0
....................     } 
....................     return FALSE; 
57D4:  MOVLW  00
57D6:  MOVWF  01
57D8:  MOVLB  1
.................... } 
57DA:  MOVLB  0
57DC:  GOTO   586C (RETURN)
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
2FE4:  MOVLW  01
2FE6:  MOVLB  1
2FE8:  MOVWF  x8A
2FEA:  MOVLW  35
2FEC:  MOVWF  x89
2FEE:  CLRF   x8C
2FF0:  MOVLW  1C
2FF2:  MOVWF  x8B
2FF4:  MOVLB  0
2FF6:  RCALL  2D60
....................  
....................     MACDiscardRx(); 
2FF8:  RCALL  2CF4
....................  
....................     SwapARPPacket(&packet); 
2FFA:  MOVLW  01
2FFC:  MOVLB  1
2FFE:  MOVWF  x52
3000:  MOVLW  35
3002:  MOVWF  x51
3004:  MOVLB  0
3006:  RCALL  2F10
....................  
....................    debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
3008:  MOVLB  1
300A:  DECFSZ x35,W
300C:  BRA    301E
300E:  MOVF   x36,F
3010:  BNZ   301E
3012:  MOVF   x39,W
3014:  SUBLW  06
3016:  BNZ   301E
3018:  MOVF   x3A,W
301A:  SUBLW  04
301C:  BZ    3024
....................          return FALSE; 
301E:  MOVLW  00
3020:  MOVWF  01
3022:  BRA    30C0
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
3024:  MOVF   x3B,W
3026:  SUBLW  02
3028:  BNZ   303A
302A:  MOVF   x3C,F
302C:  BNZ   303A
....................         *opCode = ARP_REPLY; 
302E:  MOVFF  133,FE9
3032:  MOVFF  134,FEA
3036:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
3038:  BRA    3062
303A:  DECFSZ x3B,W
303C:  BRA    3050
303E:  MOVF   x3C,F
3040:  BNZ   3050
....................         *opCode = ARP_REQUEST; 
3042:  MOVFF  133,FE9
3046:  MOVFF  134,FEA
304A:  MOVLW  01
304C:  MOVWF  FEF
....................     else 
304E:  BRA    3062
....................     { 
....................         *opCode = ARP_UNKNOWN; 
3050:  MOVFF  133,FE9
3054:  MOVFF  134,FEA
3058:  MOVLW  02
305A:  MOVWF  FEF
....................         return FALSE; 
305C:  MOVLW  00
305E:  MOVWF  01
3060:  BRA    30C0
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
3062:  MOVF   16,W
3064:  SUBWF  x4D,W
3066:  BNZ   30BA
3068:  MOVF   17,W
306A:  SUBWF  x4E,W
306C:  BNZ   30BA
306E:  MOVF   18,W
3070:  SUBWF  x4F,W
3072:  BNZ   30BA
3074:  MOVF   19,W
3076:  SUBWF  x50,W
3078:  BNZ   30BA
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
307A:  MOVFF  131,FE9
307E:  MOVFF  132,FEA
3082:  MOVLW  01
3084:  MOVWF  FE2
3086:  MOVLW  3D
3088:  MOVWF  FE1
308A:  MOVLW  06
308C:  MOVWF  01
308E:  MOVFF  FE6,FEE
3092:  DECFSZ 01,F
3094:  BRA    308E
....................         remote->IPAddr      = packet.SenderIPAddr; 
3096:  MOVLW  06
3098:  ADDWF  x31,W
309A:  MOVWF  FE9
309C:  MOVLW  00
309E:  ADDWFC x32,W
30A0:  MOVWF  FEA
30A2:  MOVFF  143,FEF
30A6:  MOVFF  144,FEC
30AA:  MOVFF  145,FEC
30AE:  MOVFF  146,FEC
....................         return TRUE; 
30B2:  MOVLW  01
30B4:  MOVWF  01
30B6:  BRA    30C0
....................     } 
....................     else 
30B8:  BRA    30C0
....................         return FALSE; 
30BA:  MOVLW  00
30BC:  MOVWF  01
30BE:  BRA    30C0
.................... } 
30C0:  MOVLB  0
30C2:  GOTO   36AA (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *					FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
*
34FC:  MOVLW  01
34FE:  MOVLB  1
3500:  MOVWF  x7B
3502:  MOVLB  0
3504:  RCALL  30C6
3506:  MOVFF  01,150
.................... 	 
.................... 	// Do not respond if there is no room to generate the ARP reply 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
350A:  MOVLB  1
350C:  INCFSZ x50,W
350E:  BRA    3516
.................... 		return FALSE; 
3510:  MOVLW  00
3512:  MOVWF  01
3514:  BRA    3684
....................  
.................... 	MACSetTxBuffer(MyTxBuffer, 0); 
3516:  MOVFF  150,196
351A:  CLRF   x98
351C:  CLRF   x97
351E:  MOVLB  0
3520:  RCALL  30F0
.................... 	 
.................... 	 
....................     packet.HardwareType             = HW_ETHERNET; 
3522:  MOVLB  1
3524:  CLRF   x35
3526:  MOVLW  01
3528:  MOVWF  x34
....................     packet.Protocol                 = ARP_IP; 
352A:  MOVLW  08
352C:  MOVWF  x37
352E:  CLRF   x36
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
3530:  MOVLW  06
3532:  MOVWF  x38
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
3534:  MOVLW  04
3536:  MOVWF  x39
....................  
....................     if ( opCode == ARP_REQUEST ) 
3538:  DECFSZ x33,W
353A:  BRA    3552
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
353C:  CLRF   x3B
353E:  MOVLW  01
3540:  MOVWF  x3A
....................         packet.TargetMACAddr.v[0]   = 0xff; 
3542:  MOVLW  FF
3544:  MOVWF  x46
....................         packet.TargetMACAddr.v[1]   = 0xff; 
3546:  MOVWF  x47
....................         packet.TargetMACAddr.v[2]   = 0xff; 
3548:  MOVWF  x48
....................         packet.TargetMACAddr.v[3]   = 0xff; 
354A:  MOVWF  x49
....................         packet.TargetMACAddr.v[4]   = 0xff; 
354C:  MOVWF  x4A
....................         packet.TargetMACAddr.v[5]   = 0xff; 
354E:  MOVWF  x4B
....................     } 
....................     else 
3550:  BRA    3580
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
3552:  CLRF   x3B
3554:  MOVLW  02
3556:  MOVWF  x3A
....................         packet.TargetMACAddr        = remote->MACAddr; 
3558:  MOVFF  132,03
355C:  MOVFF  131,151
3560:  MOVFF  132,152
3564:  MOVLW  01
3566:  MOVWF  FEA
3568:  MOVLW  46
356A:  MOVWF  FE9
356C:  MOVFF  132,FE2
3570:  MOVFF  131,FE1
3574:  MOVLW  06
3576:  MOVWF  01
3578:  MOVFF  FE6,FEE
357C:  DECFSZ 01,F
357E:  BRA    3578
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
3580:  MOVLW  01
3582:  MOVWF  FEA
3584:  MOVLW  3C
3586:  MOVWF  FE9
3588:  CLRF   FE2
358A:  MOVLW  1A
358C:  MOVWF  FE1
358E:  MOVLW  06
3590:  MOVWF  01
3592:  MOVFF  FE6,FEE
3596:  DECFSZ 01,F
3598:  BRA    3592
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
359A:  MOVFF  19,145
359E:  MOVFF  18,144
35A2:  MOVFF  17,143
35A6:  MOVFF  16,142
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
35AA:  MOVLW  06
35AC:  ADDWF  x31,W
35AE:  MOVWF  FE9
35B0:  MOVLW  00
35B2:  ADDWFC x32,W
35B4:  MOVWF  FEA
35B6:  MOVFF  FEF,00
35BA:  MOVFF  FEC,01
35BE:  MOVFF  FEC,02
35C2:  MOVFF  FEC,03
35C6:  MOVF   00,W
35C8:  XORWF  x42,W
35CA:  MOVWF  x51
35CC:  MOVF   01,W
35CE:  XORWF  x43,W
35D0:  MOVWF  x52
35D2:  MOVF   02,W
35D4:  XORWF  x44,W
35D6:  MOVWF  x53
35D8:  MOVF   03,W
35DA:  XORWF  x45,W
35DC:  MOVWF  x54
35DE:  MOVF   x51,W
35E0:  ANDWF  20,W
35E2:  MOVWF  00
35E4:  MOVF   x52,W
35E6:  ANDWF  21,W
35E8:  MOVWF  01
35EA:  MOVF   x53,W
35EC:  ANDWF  22,W
35EE:  MOVWF  02
35F0:  MOVF   x54,W
35F2:  ANDWF  23,W
35F4:  MOVWF  03
35F6:  MOVF   00,F
35F8:  BNZ   3606
35FA:  MOVF   01,F
35FC:  BNZ   3606
35FE:  MOVF   02,F
3600:  BNZ   3606
3602:  MOVF   03,F
3604:  BZ    3618
....................     { 
.................... 		packet.TargetIPAddr = AppConfig.MyGateway; 
3606:  MOVFF  27,14F
360A:  MOVFF  26,14E
360E:  MOVFF  25,14D
3612:  MOVFF  24,14C
....................     } 
....................     else 
3616:  BRA    3644
....................         packet.TargetIPAddr             = remote->IPAddr; 
3618:  MOVLW  06
361A:  ADDWF  x31,W
361C:  MOVWF  FE9
361E:  MOVLW  00
3620:  ADDWFC x32,W
3622:  MOVWF  FEA
3624:  MOVFF  FEF,00
3628:  MOVFF  FEC,01
362C:  MOVFF  FEC,02
3630:  MOVFF  FEC,03
3634:  MOVFF  03,14F
3638:  MOVFF  02,14E
363C:  MOVFF  01,14D
3640:  MOVFF  00,14C
....................  
....................     SwapARPPacket(&packet); 
3644:  MOVLW  01
3646:  MOVWF  x52
3648:  MOVLW  34
364A:  MOVWF  x51
364C:  MOVLB  0
364E:  RCALL  2F10
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
3650:  MOVLW  01
3652:  MOVLB  1
3654:  MOVWF  x9B
3656:  MOVLW  46
3658:  MOVWF  x9A
365A:  MOVLW  06
365C:  MOVWF  x9C
365E:  CLRF   x9E
3660:  MOVLW  1C
3662:  MOVWF  x9D
3664:  MOVLB  0
3666:  RCALL  3206
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
3668:  MOVLW  01
366A:  MOVLB  1
366C:  MOVWF  xA2
366E:  MOVLW  34
3670:  MOVWF  xA1
3672:  CLRF   xA4
3674:  MOVLW  1C
3676:  MOVWF  xA3
3678:  MOVLB  0
367A:  RCALL  31B8
....................  
....................     MACFlush(); 
367C:  RCALL  32D4
.................... 	 
.................... 	return TRUE; 
367E:  MOVLW  01
3680:  MOVWF  01
3682:  MOVLB  1
.................... } 
3684:  MOVLB  0
3686:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
2F10:  MOVLB  1
2F12:  MOVFF  151,01
2F16:  MOVFF  152,03
2F1A:  MOVFF  151,153
2F1E:  MOVFF  152,154
2F22:  MOVFF  151,FE9
2F26:  MOVFF  152,FEA
2F2A:  MOVFF  FEC,156
2F2E:  MOVF   FED,F
2F30:  MOVFF  FEF,155
2F34:  MOVFF  156,19D
2F38:  MOVFF  155,19C
2F3C:  MOVLB  0
2F3E:  RCALL  2DC4
2F40:  MOVFF  154,FEA
2F44:  MOVFF  153,FE9
2F48:  MOVFF  02,FEC
2F4C:  MOVF   FED,F
2F4E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
2F52:  MOVLW  02
2F54:  MOVLB  1
2F56:  ADDWF  x51,W
2F58:  MOVWF  01
2F5A:  MOVLW  00
2F5C:  ADDWFC x52,W
2F5E:  MOVWF  03
2F60:  MOVFF  01,153
2F64:  MOVWF  x54
2F66:  MOVLW  02
2F68:  ADDWF  x51,W
2F6A:  MOVWF  FE9
2F6C:  MOVLW  00
2F6E:  ADDWFC x52,W
2F70:  MOVWF  FEA
2F72:  MOVFF  FEC,156
2F76:  MOVF   FED,F
2F78:  MOVFF  FEF,155
2F7C:  MOVFF  156,19D
2F80:  MOVFF  155,19C
2F84:  MOVLB  0
2F86:  RCALL  2DC4
2F88:  MOVFF  154,FEA
2F8C:  MOVFF  153,FE9
2F90:  MOVFF  02,FEC
2F94:  MOVF   FED,F
2F96:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
2F9A:  MOVLW  06
2F9C:  MOVLB  1
2F9E:  ADDWF  x51,W
2FA0:  MOVWF  01
2FA2:  MOVLW  00
2FA4:  ADDWFC x52,W
2FA6:  MOVWF  03
2FA8:  MOVFF  01,153
2FAC:  MOVWF  x54
2FAE:  MOVLW  06
2FB0:  ADDWF  x51,W
2FB2:  MOVWF  FE9
2FB4:  MOVLW  00
2FB6:  ADDWFC x52,W
2FB8:  MOVWF  FEA
2FBA:  MOVFF  FEC,156
2FBE:  MOVF   FED,F
2FC0:  MOVFF  FEF,155
2FC4:  MOVFF  156,19D
2FC8:  MOVFF  155,19C
2FCC:  MOVLB  0
2FCE:  RCALL  2DC4
2FD0:  MOVFF  154,FEA
2FD4:  MOVFF  153,FE9
2FD8:  MOVFF  02,FEC
2FDC:  MOVF   FED,F
2FDE:  MOVFF  01,FEF
.................... } 
2FE2:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
1152:  CLRF   xAD
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
1154:  BSF    2C.1
.................... #endif 
....................  
....................    TickInit(); 
1156:  BRA    0BBA
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
1158:  BRA    0EAA
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
115A:  BRA    107A
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
115C:  BRA    1114
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
115E:  RCALL  1132
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPInit(); 
.................... #endif 
.................... } 
1160:  GOTO   128E (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
5538:  MOVLB  1
553A:  BCF    x25.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
553C:  BCF    x25.0
....................         switch(smStack) 
....................         { 
553E:  MOVLB  0
5540:  MOVF   xAD,W
5542:  ADDLW  F8
5544:  BTFSC  FD8.0
5546:  BRA    56D8
5548:  ADDLW  08
554A:  GOTO   56EC
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
554E:  MOVLB  1
5550:  CLRF   x27
5552:  MOVLW  AE
5554:  MOVWF  x26
5556:  MOVLW  01
5558:  MOVWF  x29
555A:  MOVLW  24
555C:  MOVWF  x28
555E:  MOVLB  0
5560:  GOTO   2DDA
5564:  MOVF   01,F
5566:  BNZ   5586
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
5568:  MOVF   x85,W
556A:  SUBLW  08
556C:  BZ    5584
....................                     { 
....................                         if ( !MACIsLinked() ) 
556E:  CALL   174A
5572:  MOVF   01,F
5574:  BNZ   5584
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
5576:  CLRF   19
5578:  CLRF   18
557A:  CLRF   17
557C:  CLRF   16
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
557E:  BSF    2C.1
....................                             DHCPReset(); 
5580:  CALL   1132
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
5584:  BRA    56D8
....................             } 
....................  
....................             debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
5586:  MOVLB  1
5588:  BSF    x25.0
....................             if ( type.MACFrameType == MAC_IP ) { 
558A:  MOVF   x24,F
558C:  BNZ   5598
....................                 smStack = SM_STACK_IP; 
558E:  MOVLW  02
5590:  MOVLB  0
5592:  MOVWF  xAD
....................                 debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
5594:  BRA    55AE
5596:  MOVLB  1
5598:  MOVF   x24,W
559A:  SUBLW  06
559C:  BNZ   55A8
....................                 smStack = SM_STACK_ARP; 
559E:  MOVLW  05
55A0:  MOVLB  0
55A2:  MOVWF  xAD
....................                 debug_stack("ARP "); 
....................             } 
....................             else { 
55A4:  BRA    55AE
55A6:  MOVLB  1
....................                 MACDiscardRx(); 
55A8:  MOVLB  0
55AA:  CALL   2CF4
....................                 debug_stack("DISCARD"); 
....................             } 
....................             break; 
55AE:  BRA    56D8
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
55B0:  GOTO   3688
55B4:  MOVF   01,F
55B6:  BZ    55BA
....................                 smStack = SM_STACK_IDLE; 
55B8:  CLRF   xAD
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
55BA:  BRA    56D8
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
55BC:  MOVLW  01
55BE:  MOVLB  1
55C0:  MOVWF  x27
55C2:  MOVLW  20
55C4:  MOVWF  x26
55C6:  CLRF   x29
55C8:  MOVLW  AE
55CA:  MOVWF  x28
55CC:  MOVLW  01
55CE:  MOVWF  x2B
55D0:  MOVLW  24
55D2:  MOVWF  x2A
55D4:  CLRF   x2D
55D6:  MOVLW  B8
55D8:  MOVWF  x2C
55DA:  MOVLB  0
55DC:  GOTO   397C
55E0:  MOVF   01,F
55E2:  BZ    5612
....................             { 
....................                 lbContinue = TRUE; 
55E4:  MOVLB  1
55E6:  BSF    x25.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
55E8:  DECFSZ x24,W
55EA:  BRA    55F6
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
55EC:  MOVLW  03
55EE:  MOVLB  0
55F0:  MOVWF  xAD
....................                     debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
....................                     smStack = SM_STACK_TCP; 
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
55F2:  BRA    5610
55F4:  MOVLB  1
55F6:  MOVF   x24,W
55F8:  SUBLW  11
55FA:  BNZ   5606
....................                     smStack = SM_STACK_UDP; 
55FC:  MOVLW  07
55FE:  MOVLB  0
5600:  MOVWF  xAD
....................                     debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
5602:  BRA    5610
5604:  MOVLB  1
....................                 { 
....................                     lbContinue = FALSE; 
5606:  BCF    x25.0
....................                     MACDiscardRx(); 
5608:  MOVLB  0
560A:  CALL   2CF4
....................  
....................                     smStack = SM_STACK_IDLE; 
560E:  CLRF   xAD
....................                     debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
....................             else 
5610:  BRA    5618
....................             { 
....................                 MACDiscardRx(); 
5612:  CALL   2CF4
....................                 smStack = SM_STACK_IDLE; 
5616:  CLRF   xAD
....................                 debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
5618:  BRA    56D8
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
561A:  MOVLB  1
561C:  CLRF   x27
561E:  MOVLW  AE
5620:  MOVWF  x26
5622:  MOVLW  01
5624:  MOVWF  x29
5626:  MOVLW  20
5628:  MOVWF  x28
562A:  MOVFF  B9,12B
562E:  MOVFF  B8,12A
5632:  MOVLB  0
5634:  GOTO   3E98
5638:  MOVF   01,F
563A:  BZ    563E
....................             { 
....................                 debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
563C:  CLRF   xAD
....................             } 
....................             break; 
563E:  BRA    56D8
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
5640:  CLRF   xAD
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
5642:  MOVF   xB9,F
5644:  BNZ   5690
5646:  MOVF   xB8,W
5648:  SUBLW  48
564A:  BNC   5690
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
564C:  MOVLB  1
564E:  CLRF   x27
5650:  MOVLW  B8
5652:  MOVWF  x26
5654:  MOVLW  01
5656:  MOVWF  x29
5658:  MOVLW  24
565A:  MOVWF  x28
565C:  CLRF   x2B
565E:  MOVLW  BA
5660:  MOVWF  x2A
5662:  MOVFF  127,12D
5666:  MOVFF  126,12C
566A:  CLRF   x2F
566C:  MOVLW  FA
566E:  MOVWF  x2E
5670:  CLRF   x31
5672:  MOVLW  FC
5674:  MOVWF  x30
5676:  MOVLB  0
5678:  GOTO   4182
567C:  MOVF   01,F
567E:  BZ    5690
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
5680:  MOVLB  1
5682:  MOVF   x24,W
5684:  SUBLW  08
5686:  BNZ   5692
....................                     { 
....................                         debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
5688:  BSF    x25.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
568A:  MOVLW  04
568C:  MOVLB  0
568E:  MOVWF  xAD
5690:  MOVLB  1
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
5692:  MOVLB  0
5694:  CALL   2CF4
....................             break; 
5698:  BRA    56D8
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
569A:  MOVLW  01
569C:  MOVLB  1
569E:  MOVWF  x46
56A0:  MOVLB  0
56A2:  CALL   426A
56A6:  MOVF   01,F
56A8:  BZ    56D6
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
56AA:  MOVLB  1
56AC:  CLRF   x27
56AE:  MOVLW  AE
56B0:  MOVWF  x26
56B2:  CLRF   x28
56B4:  CLRF   x2A
56B6:  MOVLW  BA
56B8:  MOVWF  x29
56BA:  MOVFF  B8,12B
56BE:  MOVFF  FB,12D
56C2:  MOVFF  FA,12C
56C6:  MOVFF  FD,12F
56CA:  MOVFF  FC,12E
56CE:  MOVLB  0
56D0:  GOTO   449C
....................  
....................                 debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
56D4:  CLRF   xAD
....................             } 
....................             break; 
56D6:  BRA    56D8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
56D8:  MOVLB  1
56DA:  BTFSC  x25.0
56DC:  BRA    553C
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
56DE:  MOVLB  0
56E0:  BRA    50D0
....................  
....................     if ( DHCPIsBound() ) 
56E2:  BTFSS  x86.0
56E4:  BRA    56E8
....................         AppConfig.Flags.bInConfigMode = FALSE; 
56E6:  BCF    2C.1
....................  
.................... #endif 
.................... } 
56E8:  GOTO   5C92 (RETURN)
....................  
....................  
.................... #define CCS_UDP_EXAMPLE   TRUE 
....................  
.................... #include "ccshelper.c"   //include CCS's PICDEM.net/PICNET helper functions 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         CCSHELPER.C                               //// 
.................... ////                                                                   //// 
.................... //// Helper functions and definitions for using CCS's example programs //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            //// 
.................... ////                                                                   //// 
.................... ////    May 26, 2004: Fixed a bug in read_ext_eeprom_string() to       //// 
.................... ////                  prevent infinite loops when EEPROM is all 0xFF.  //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Settings saved to external EEPROM                //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
....................   #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
....................   #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_PICNET+STACK_USE_CCS_PICENS+STACK_USE_CCS_PICEEC+STACK_USE_CCS_EWL3V+STACK_USE_CCS_EWL5V)==0 
....................    #error You must define one of the prototype boards 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET 
....................    #define ANALOG_PORT_CONFIG    ANALOG_AN0_TO_AN1 
....................    #define ADC_CHAN_0   0 
....................    #define ADC_CHAN_1   1 
....................    #define USER_BUTTON1 PIN_B0 
....................    #define USER_BUTTON2 PIN_B1 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_B2 
....................    #define USER_LED2    PIN_B4 
.................... #elif STACK_USE_CCS_PICENS 
....................    #define ANALOG_PORT_CONFIG    AN0 
....................    #define ADC_CHAN_0   0 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_A5 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #elif STACK_USE_CCS_PICEEC 
....................    #define ANALOG_PORT_CONFIG    AN0_TO_AN2 
....................    #define ADC_CHAN_0   2 
....................    #define USER_BUTTON1 PIN_A4 
....................    #define BUTTON_PRESSED(p)  (!input(p)) 
....................    #define USER_LED1    PIN_B3 
....................    #define USER_LED2    PIN_B4 
....................    #define USER_LED3    PIN_B5 
.................... #elif STACK_USE_CCS_EWL3V 
....................    #if !STACK_USE_PICDEM_LCD 
....................       #define ANALOG_PORT_CONFIG    AN0_TO_AN7 
....................       #define ADC_CHAN_0   6 
....................       #define ADC_CHAN_1   7 
....................       #define USER_LED1 DIGITAL3 
....................       #define USER_LED2 DIGITAL4 
....................    #else 
....................       #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #endif 
....................    #define BUTTON_PRESSED(p)  (input(p)) 
.................... #elif STACK_USE_CCS_EWL5V 
....................    #if !STACK_USE_PICDEM_LCD 
....................       #define ANALOG_PORT_CONFIG    AN0_TO_AN1 
....................       #define ADC_CHAN_0   0 
....................       #define ADC_CHAN_1   1 
....................       #define USER_LED1 DIGITAL3 
....................       #define USER_LED2 DIGITAL4 
....................    #else 
....................       #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #endif 
....................    #define BUTTON_PRESSED(p)  (input(p)) 
.................... #endif 
....................  
.................... #if (STACK_USE_CCS_EWL3V || STACK_USE_CCS_EWL5V) && CCS_EMAIL_EXAMPLE 
....................    #undef ANALOG_PORT_CONFIG 
....................    #define ANALOG_PORT_CONFIG    NO_ANALOGS 
....................    #define USER_BUTTON1 DIGITAL1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_EWL5V 
....................    #define DIGITAL1   PIN_A0    
....................    #define DIGITAL2   PIN_A1 
....................    #define DIGITAL3   PIN_A2 
....................    #define DIGITAL4   PIN_A3 
....................    #define DIGITAL5   PIN_A5 
....................    #define DIGITAL6   PIN_B0 
....................    #define DIGITAL7   PIN_B1 
....................    #define DIGITAL8   PIN_C6 
....................    #define DIGITAL9   PIN_C7 
....................    #define DIGITAL10  PIN_B6 
....................    #define DIGITAL11  PIN_B7 
.................... #elif STACK_USE_CCS_EWL3V 
....................    #define DIGITAL1   PIN_F1 
....................    #define DIGITAL2   PIN_F2 
....................    #define DIGITAL3   PIN_F3 
....................    #define DIGITAL4   PIN_F4 
....................    #define DIGITAL5   PIN_F5 
....................    #define DIGITAL6   PIN_F6 
....................    #define DIGITAL7   PIN_A3 
....................    #define DIGITAL8   PIN_C6 
....................    #define DIGITAL9   PIN_C7 
....................    #define DIGITAL10  PIN_B6 
....................    #define DIGITAL11  PIN_B7 
....................    #define DIGITAL12  PIN_B0 
....................    #define DIGITAL13  PIN_B1 
....................    #define DIGITAL14  PIN_B2 
....................    #define DIGITAL15  PIN_B3 
....................    #define DIGITAL16  PIN_B4 
....................    #define DIGITAL17  PIN_B5 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PICDEM_LCD 
....................    #define STACK_USE_PICDEM_LCD TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SERIAL 
....................    #define STACK_USE_SERIAL TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_EEPROM 
....................    #define STACK_USE_EEPROM   TRUE 
.................... #endif 
....................  
.................... #if STACK_USE_SERIAL 
....................  #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7, STREAM=USER) 
*
1AB2:  BTFSS  F9E.4
1AB4:  BRA    1AB2
1AB6:  MOVWF  FAD
1AB8:  RETLW  00
.................... #endif 
....................  
.................... #if STACK_USE_PICDEM_LCD 
....................    #if STACK_USE_CCS_PICNET 
....................       #include "tcpip/dlcd.c" 
....................    #elif STACK_USE_CCS_PICENS 
....................       #include "tcpip/mlcd.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             MLCD.C                                //// 
.................... ////                Driver for LCD Module on CCS PICENS                //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     E2  enable 
.................... //     E0  rs 
.................... //     E1  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int     empty: 4;         // on PORT D 
....................            int     data : 4; 
....................         } lcd_io,lcd_lat,lcd_tris; 
....................  
.................... #bit lcd_enable=0xF8D.2 
.................... #bit lcd_rs=0xF8D.0 
.................... #bit lcd_rw=0xF8D.1 
....................  
.................... #byte lcd_io = 0xF83                   // This puts the entire structure on PORT D 
.................... #byte lcd_lat = 0xF8C 
.................... #byte lcd_tris = 0xF95 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       lcd_tris.data=0xF;  //set_tris_lcd(LCD_READ); 
*
0680:  MOVLW  0F
0682:  ANDWF  F95,W
0684:  IORLW  F0
0686:  MOVWF  F95
....................       lcd_rw = 1; 
0688:  BSF    F8D.1
....................       delay_us(1); 
068A:  BRA    068C
068C:  BRA    068E
068E:  NOP   
....................       lcd_enable = 1; 
0690:  BSF    F8D.2
....................       delay_us(1); 
0692:  BRA    0694
0694:  BRA    0696
0696:  NOP   
....................       high = lcd_io.data; 
0698:  SWAPF  F83,W
069A:  ANDLW  0F
069C:  MOVLB  1
069E:  MOVWF  x2B
....................       lcd_enable = 0; 
06A0:  BCF    F8D.2
....................       delay_us(1); 
06A2:  BRA    06A4
06A4:  BRA    06A6
06A6:  NOP   
....................       lcd_enable = 1; 
06A8:  BSF    F8D.2
....................       delay_us(1); 
06AA:  BRA    06AC
06AC:  BRA    06AE
06AE:  NOP   
....................       low = lcd_io.data; 
06B0:  SWAPF  F83,W
06B2:  ANDLW  0F
06B4:  MOVWF  x2A
....................       lcd_enable = 0; 
06B6:  BCF    F8D.2
....................       lcd_tris.data=0;  //set_tris_lcd(LCD_WRITE); 
06B8:  MOVLW  0F
06BA:  ANDWF  F95,W
06BC:  MOVWF  F95
....................       return( (high<<4) | low); 
06BE:  SWAPF  x2B,W
06C0:  MOVWF  00
06C2:  MOVLW  F0
06C4:  ANDWF  00,F
06C6:  MOVF   00,W
06C8:  IORWF  x2A,W
06CA:  MOVWF  01
.................... } 
06CC:  MOVLB  0
06CE:  GOTO   06DC (RETURN)
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd_lat.data = n; 
*
065A:  MOVLB  1
065C:  SWAPF  x2B,W
065E:  ANDLW  F0
0660:  MOVWF  00
0662:  MOVLW  0F
0664:  ANDWF  F8C,W
0666:  IORWF  00,W
0668:  MOVWF  F8C
....................       delay_us(1); 
066A:  BRA    066C
066C:  BRA    066E
066E:  NOP   
....................       lcd_enable = 1; 
0670:  BSF    F8D.2
....................       delay_us(2); 
0672:  MOVLW  03
0674:  MOVWF  00
0676:  DECFSZ 00,F
0678:  BRA    0676
....................       lcd_enable = 0; 
067A:  BCF    F8D.2
.................... } 
067C:  MOVLB  0
067E:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd_rs = 0; 
*
06D2:  BCF    F8D.0
....................       delay_us(1); 
06D4:  BRA    06D6
06D6:  BRA    06D8
06D8:  NOP   
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
06DA:  BRA    0680
06DC:  MOVFF  01,12A
06E0:  MOVLB  1
06E2:  BTFSS  01.7
06E4:  BRA    06EA
06E6:  MOVLB  0
06E8:  BRA    06DA
....................       lcd_rs = address; 
06EA:  BCF    F8D.0
06EC:  BTFSC  x28.0
06EE:  BSF    F8D.0
....................       delay_us(1); 
06F0:  BRA    06F2
06F2:  BRA    06F4
06F4:  NOP   
....................       lcd_rw = 0; 
06F6:  BCF    F8D.1
....................       delay_us(1); 
06F8:  BRA    06FA
06FA:  BRA    06FC
06FC:  NOP   
....................       lcd_enable = 0; 
06FE:  BCF    F8D.2
....................       lcd_send_nibble(n >> 4); 
0700:  SWAPF  x29,W
0702:  MOVWF  x2A
0704:  MOVLW  0F
0706:  ANDWF  x2A,F
0708:  MOVFF  12A,12B
070C:  MOVLB  0
070E:  RCALL  065A
....................       lcd_send_nibble(n & 0xf); 
0710:  MOVLB  1
0712:  MOVF   x29,W
0714:  ANDLW  0F
0716:  MOVWF  x2A
0718:  MOVWF  x2B
071A:  MOVLB  0
071C:  RCALL  065A
.................... } 
071E:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     lcd_tris.data=0;    //set_tris_lcd(LCD_WRITE); 
0720:  MOVLW  0F
0722:  ANDWF  F95,W
0724:  MOVWF  F95
....................     lcd_rs = 0; 
0726:  BCF    F8D.0
....................     lcd_rw = 0; 
0728:  BCF    F8D.1
....................     lcd_enable = 0; 
072A:  BCF    F8D.2
....................     *0xF96=*0xF96 & 0xF8; 
072C:  MOVLW  F8
072E:  ANDWF  F96,F
....................     delay_ms(15); 
0730:  MOVLW  0F
0732:  MOVLB  1
0734:  MOVWF  x24
0736:  MOVLB  0
0738:  RCALL  0632
....................     for(i=1;i<=3;++i) { 
073A:  MOVLW  01
073C:  MOVLB  1
073E:  MOVWF  x20
0740:  MOVF   x20,W
0742:  SUBLW  03
0744:  BNC   075E
....................        lcd_send_nibble(3); 
0746:  MOVLW  03
0748:  MOVWF  x2B
074A:  MOVLB  0
074C:  RCALL  065A
....................        delay_ms(5); 
074E:  MOVLW  05
0750:  MOVLB  1
0752:  MOVWF  x24
0754:  MOVLB  0
0756:  RCALL  0632
....................     } 
0758:  MOVLB  1
075A:  INCF   x20,F
075C:  BRA    0740
....................     lcd_send_nibble(2); 
075E:  MOVLW  02
0760:  MOVWF  x2B
0762:  MOVLB  0
0764:  RCALL  065A
....................     delay_ms(5); 
0766:  MOVLW  05
0768:  MOVLB  1
076A:  MOVWF  x24
076C:  MOVLB  0
076E:  RCALL  0632
....................     for(i=0;i<=3;++i) 
0770:  MOVLB  1
0772:  CLRF   x20
0774:  MOVF   x20,W
0776:  SUBLW  03
0778:  BNC   079E
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
077A:  CLRF   03
077C:  MOVF   x20,W
077E:  MOVFF  FF2,121
0782:  BCF    FF2.7
0784:  MOVLB  0
0786:  RCALL  0096
0788:  MOVLB  1
078A:  BTFSC  x21.7
078C:  BSF    FF2.7
078E:  MOVWF  x21
0790:  CLRF   x28
0792:  MOVWF  x29
0794:  MOVLB  0
0796:  RCALL  06D2
0798:  MOVLB  1
079A:  INCF   x20,F
079C:  BRA    0774
.................... } 
079E:  MOVLB  0
07A0:  GOTO   11CA (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0894:  MOVLB  1
0896:  DECFSZ x25,W
0898:  BRA    089C
089A:  BRA    08A2
....................      address=lcd_line_two; 
089C:  MOVLW  40
089E:  MOVWF  x26
....................    else 
08A0:  BRA    08A4
....................      address=0; 
08A2:  CLRF   x26
....................    address+=x-1; 
08A4:  MOVLW  01
08A6:  SUBWF  x24,W
08A8:  ADDWF  x26,F
....................    lcd_send_byte(0,0x80|address); 
08AA:  MOVF   x26,W
08AC:  IORLW  80
08AE:  MOVWF  x27
08B0:  CLRF   x28
08B2:  MOVWF  x29
08B4:  MOVLB  0
08B6:  RCALL  06D2
.................... } 
08B8:  GOTO   0916 (RETURN)
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
08BC:  MOVLB  1
08BE:  MOVF   x23,W
08C0:  XORLW  0C
08C2:  MOVLB  0
08C4:  BZ    08D0
08C6:  XORLW  06
08C8:  BZ    08E8
08CA:  XORLW  02
08CC:  BZ    08F8
08CE:  BRA    0906
....................      case '\f'   : lcd_send_byte(0,1); 
08D0:  MOVLB  1
08D2:  CLRF   x28
08D4:  MOVLW  01
08D6:  MOVWF  x29
08D8:  MOVLB  0
08DA:  RCALL  06D2
....................                    delay_ms(2); 
08DC:  MOVLW  02
08DE:  MOVLB  1
08E0:  MOVWF  x24
08E2:  MOVLB  0
08E4:  RCALL  0632
....................                                            break; 
08E6:  BRA    0916
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
08E8:  MOVLW  01
08EA:  MOVLB  1
08EC:  MOVWF  x24
08EE:  MOVLW  02
08F0:  MOVWF  x25
08F2:  MOVLB  0
08F4:  BRA    0894
08F6:  BRA    0916
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
08F8:  MOVLB  1
08FA:  CLRF   x28
08FC:  MOVLW  10
08FE:  MOVWF  x29
0900:  MOVLB  0
0902:  RCALL  06D2
0904:  BRA    0916
....................      default     : lcd_send_byte(1,c);     break; 
0906:  MOVLW  01
0908:  MOVLB  1
090A:  MOVWF  x28
090C:  MOVFF  123,129
0910:  MOVLB  0
0912:  RCALL  06D2
0914:  BRA    0916
....................    } 
.................... } 
0916:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd_rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd_rs=0; 
....................     return(value); 
.................... } 
....................  
....................    #elif STACK_USE_CCS_PICEEC 
....................       #include "tcpip/elcd.c" 
....................    #elif STACK_USE_CCS_EWL 
....................       #include "tcpip/alcd.c" 
....................    #else 
....................       #error Can't use LCD without specifying which hardware. Or write your own LCD driver. 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICNET 
....................  #ifndef EEPROM_SDA 
....................     #define EEPROM_SDA  PIN_C4 
....................     #define EEPROM_SCL  PIN_C3 
....................     #include "24256.c"   //included with compiler 
....................  #endif 
.................... #elif STACK_USE_CCS_PICENS 
....................  #ifndef EEPROM_SELECT 
....................     #define EEPROM_SELECT PIN_B3 
....................     #define EEPROM_DI     PIN_C5 
....................     #define EEPROM_DO     PIN_C4 
....................     #define EEPROM_CLK    PIN_C3 
....................     #define EEPROM_USE_SPI    ENC_MAC_USE_SPI 
....................     #include "AT25256.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for an ATMEL25128 or ATMEL25256                         //// 
.................... ////    ATMEL25128 has 16,384 (or 13bits of addressing) locations      //// 
.................... ////    ATMEL25256 has 32,768 words of 8 bits                          //// 
.................... ////                                                                   //// 
.................... ////   Uses software (bit banging on the port pins)                    //// 
.................... ////                                                                   //// 
.................... ////                     Pin Layout                                    //// 
.................... ////   ATMEL EEPROM pin     to      Microchip MCU Pin                  //// 
.................... ////   ----------------             -----------------                  //// 
.................... ////   1 (CS)                       PortB 0                            //// 
.................... ////   2 (SO)                       PortC 4                            //// 
.................... ////   3 (WP)                       +5V                                //// 
.................... ////   4 (GND)                      GND                                //// 
.................... ////   5 (SI)                       PortC 5                            //// 
.................... ////   6 (SCK)                      PortC 3                            //// 
.................... ////   7 (HOLD)                     +5V                                //// 
.................... ////   8 (VCC)                      +5V                                //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eerpom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SELECT 
.................... #define EEPROM_SELECT PIN_B0 
.................... #define EEPROM_DI     PIN_C5 
.................... #define EEPROM_DO     PIN_C4 
.................... #define EEPROM_CLK    PIN_C3 
.................... #endif 
....................  
.................... #ifndef EEPROM_ADDRESS 
.................... #define EEPROM_ADDRESS long 
.................... #endif 
....................  
.................... #byte SSPSTAT=0x94 
.................... #byte SSPCON=0x14 
....................  
.................... void init_ext_eeprom() { 
....................    int1 i; 
....................  
....................    output_low(EEPROM_DI); 
*
07C8:  BCF    F8B.5
....................    output_low(EEPROM_CLK); 
07CA:  BCF    F8B.3
....................    output_high(EEPROM_SELECT);   //at25256 is cs active LOW 
07CC:  BSF    F8A.3
....................    i=input(EEPROM_DO); 
07CE:  MOVLB  1
07D0:  BCF    x20.0
07D2:  BTFSC  F82.4
07D4:  BSF    x20.0
.................... } 
07D6:  MOVLB  0
07D8:  GOTO   11D2 (RETURN)
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    BYTE cmd[1],i,data; 
....................  
....................    cmd[0] = 0x05;         //rdsr opcode 
07DC:  MOVLW  05
07DE:  MOVLB  1
07E0:  MOVWF  x3E
....................  
....................    output_low(EEPROM_SELECT); 
07E2:  BCF    F8A.3
....................  
....................    for(i=1;i<=8;++i) { 
07E4:  MOVLW  01
07E6:  MOVWF  x3F
07E8:  MOVF   x3F,W
07EA:  SUBLW  08
07EC:  BNC   0802
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
07EE:  BCF    FD8.0
07F0:  RLCF   x3E,F
07F2:  BC    07F8
07F4:  BCF    F8B.5
07F6:  BRA    07FA
07F8:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
07FA:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
07FC:  BCF    F8B.3
....................    } 
07FE:  INCF   x3F,F
0800:  BRA    07E8
....................  
....................    for(i=1;i<=8;++i) { 
0802:  MOVLW  01
0804:  MOVWF  x3F
0806:  MOVF   x3F,W
0808:  SUBLW  08
080A:  BNC   0820
....................         output_high(EEPROM_CLK);      //data latches 
080C:  BSF    F8B.3
....................         shift_left(&data,1,input(EEPROM_DO)); 
080E:  BTFSC  F82.4
0810:  BRA    0816
0812:  BCF    FD8.0
0814:  BRA    0818
0816:  BSF    FD8.0
0818:  RLCF   x40,F
....................         output_low(EEPROM_CLK);              //back to idle 
081A:  BCF    F8B.3
....................    } 
081C:  INCF   x3F,F
081E:  BRA    0806
....................    output_high(EEPROM_SELECT); 
0820:  BSF    F8A.3
....................    return (!(bit_test(data, 0))); 
0822:  MOVLW  00
0824:  BTFSS  x40.0
0826:  MOVLW  01
0828:  MOVWF  01
.................... } 
082A:  MOVLB  0
082C:  RETLW  00
....................  
....................  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data) { 
....................  
....................    BYTE cmd[4]; 
....................    BYTE i; 
....................    cmd[2]=((address>>8)&(0xFF));   //address msb (16bit addressing) 
*
093A:  MOVLB  1
093C:  MOVFF  137,13B
....................    cmd[1]=address-cmd[2];      //address lsb 
0940:  MOVF   x3B,W
0942:  SUBWF  x36,W
0944:  MOVWF  x3A
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
0946:  MOVLB  0
0948:  RCALL  07DC
094A:  MOVF   01,F
094C:  BZ    0948
....................  
....................    cmd[0]=0x06; 
094E:  MOVLW  06
0950:  MOVLB  1
0952:  MOVWF  x39
....................    output_low(EEPROM_SELECT); //cs is active low 
0954:  BCF    F8A.3
....................    for(i=1;i<=8;++i) { 
0956:  MOVLW  01
0958:  MOVWF  x3D
095A:  MOVF   x3D,W
095C:  SUBLW  08
095E:  BNC   0974
....................       output_bit(EEPROM_DI, shift_left(cmd,1,0)); 
0960:  BCF    FD8.0
0962:  RLCF   x39,F
0964:  BC    096A
0966:  BCF    F8B.5
0968:  BRA    096C
096A:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
096C:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
096E:  BCF    F8B.3
....................    } 
0970:  INCF   x3D,F
0972:  BRA    095A
....................    output_high(EEPROM_SELECT); 
0974:  BSF    F8A.3
....................  
....................    cmd[0]=data; 
0976:  MOVFF  138,139
....................    cmd[3]=0x02;      //write opcode 
097A:  MOVLW  02
097C:  MOVWF  x3C
....................    output_low(EEPROM_SELECT); 
097E:  BCF    F8A.3
....................    for(i=1;i<=32;++i) { 
0980:  MOVLW  01
0982:  MOVWF  x3D
0984:  MOVF   x3D,W
0986:  SUBLW  20
0988:  BNC   09A4
....................       output_bit(EEPROM_DI, shift_left(cmd,4,0)); 
098A:  BCF    FD8.0
098C:  RLCF   x39,F
098E:  RLCF   x3A,F
0990:  RLCF   x3B,F
0992:  RLCF   x3C,F
0994:  BC    099A
0996:  BCF    F8B.5
0998:  BRA    099C
099A:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
099C:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
099E:  BCF    F8B.3
....................    } 
09A0:  INCF   x3D,F
09A2:  BRA    0984
....................  
....................    output_high(EEPROM_SELECT); 
09A4:  BSF    F8A.3
.................... } 
09A6:  MOVLB  0
09A8:  RETLW  00
....................  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address) { 
....................    BYTE i,data; 
....................    BYTE cmd[3]; 
....................    cmd[2]=0x03;            //read opcode 
*
082E:  MOVLW  03
0830:  MOVLB  1
0832:  MOVWF  x3C
....................    cmd[1]=((address>>8)&(0xFF)); 
0834:  MOVFF  137,13B
....................    cmd[0]=address-cmd[1]; 
0838:  MOVF   x3B,W
083A:  SUBWF  x36,W
083C:  MOVWF  x3A
....................  
....................    do {} while (!(ext_eeprom_ready())); //wait until the eeprom is out of the previous write state, if applicable 
083E:  MOVLB  0
0840:  RCALL  07DC
0842:  MOVF   01,F
0844:  BZ    0840
....................    output_low(EEPROM_SELECT); 
0846:  BCF    F8A.3
....................    for(i=1;i<=24;++i) { 
0848:  MOVLW  01
084A:  MOVLB  1
084C:  MOVWF  x38
084E:  MOVF   x38,W
0850:  SUBLW  18
0852:  BNC   086C
....................       output_bit(EEPROM_DI, shift_left(cmd,3,0)); 
0854:  BCF    FD8.0
0856:  RLCF   x3A,F
0858:  RLCF   x3B,F
085A:  RLCF   x3C,F
085C:  BC    0862
085E:  BCF    F8B.5
0860:  BRA    0864
0862:  BSF    F8B.5
....................       output_high(EEPROM_CLK);      //data latches 
0864:  BSF    F8B.3
....................       output_low(EEPROM_CLK);      //back to idle 
0866:  BCF    F8B.3
....................    } 
0868:  INCF   x38,F
086A:  BRA    084E
....................  
....................    for(i=1;i<=8;++i) { 
086C:  MOVLW  01
086E:  MOVWF  x38
0870:  MOVF   x38,W
0872:  SUBLW  08
0874:  BNC   088A
....................         output_high(EEPROM_CLK);      //data latches 
0876:  BSF    F8B.3
....................         shift_left(&data,1,input(EEPROM_DO)); 
0878:  BTFSC  F82.4
087A:  BRA    0880
087C:  BCF    FD8.0
087E:  BRA    0882
0880:  BSF    FD8.0
0882:  RLCF   x39,F
....................         output_low(EEPROM_CLK);              //back to idle 
0884:  BCF    F8B.3
....................    } 
0886:  INCF   x38,F
0888:  BRA    0870
....................  
....................    output_high(EEPROM_SELECT); 
088A:  BSF    F8A.3
....................  
....................    return(data); 
088C:  MOVFF  139,01
.................... } 
0890:  MOVLB  0
0892:  RETLW  00
....................  
....................  #endif     
.................... #elif STACK_USE_CCS_PICEEC 
....................  #ifndef EEPROM_SELECT 
....................     #define EEPROM_SELECT PIN_C1  //o 
....................     #define EEPROM_DI     PIN_C5  //o 
....................     #define EEPROM_DO     PIN_C4  //i 
....................     #define EEPROM_CLK    PIN_C3  //o 
....................     #define EEPROM_USE_SPI   TRUE 
....................     #include "AT25256.C" 
....................  #endif 
.................... #elif STACK_USE_CCS_EWL5V 
....................  #ifndef FLASH_SELECT 
....................     #define FLASH_SELECT PIN_C1 
....................     #define FLASH_CLOCK  PIN_C2 
....................     #define FLASH_DI     PIN_C0 
....................     #define FLASH_DO     PIN_B4 
....................     #define FLASH_BUFFER_SIZE    264     //bytes per page on the flash memory 
....................     #define FLASH_BUFFER_COUNT   4096   //page count 
....................     #include "at45db041.c"   
....................  #endif 
....................  #if STACK_USE_TEMP 
....................     #define DAL_SCL PIN_B6 
....................     #define DAL_SDA PIN_B7 
....................     #include "ds1631.c"   //ds1631 temperature sensor on the d'ment kit 
....................  #endif 
.................... #elif STACK_USE_CCS_EWL3V 
....................  #ifndef FLASH_SELECT 
....................     #define FLASH_SELECT PIN_C2 
....................     #define FLASH_CLOCK  PIN_C3 
....................     #define FLASH_DI     PIN_C5 
....................     #define FLASH_DO     PIN_C4 
....................     #define FLASH_BUFFER_SIZE    264     //bytes per page 
....................     #define FLASH_BUFFER_COUNT   4096   //page count 
....................     #include "at45db041.c" 
....................  #endif 
....................  #if STACK_USE_TEMP 
....................     #define DAL_SCL PIN_B6 
....................     #define DAL_SDA PIN_B7 
....................     #include "ds1631.c"   //ds1631 temperature sensor on the d'ment kit 
....................  #endif 
.................... #endif 
....................  
....................  
....................  
....................  
.................... //if using PPP 
.................... #define EE_ISP_PHONENUMBER 0      //size=64 
.................... #define EE_ISP_USERNAME    64      //size=64 
.................... #define EE_ISP_PASSWORD    128      //size=64 
.................... //if using ETHERNET 
.................... #define EE_NIC_DHCP        192   //size=1 
.................... #define EE_NIC_GATEWAY     193   //size=4 
.................... #define EE_NIC_IP          197   //size=4 
.................... #define EE_NIC_NETMASK     201   //size=4 
.................... #define EE_NIC_MAC         205   //size=6 
.................... #define EE_DNS             211   //size=4 
.................... //if using CCS E-Mail Example 
.................... #define EE_SMTP_PORT       215   //size=2   [TCP Port] 
.................... #define EE_SMTP_HOSTNAME   217   //size=64  [E-mail SMTP server hostname] 
.................... #define EE_SMTP_TO         281   //size=64  [E-mail To address] 
.................... #define EE_SMTP_FROM       345   //size=64  [E-mail From address] 
.................... #define EE_SMTP_SUBJECT    409   //size=64  [E-mail Subject] 
.................... #define EE_SMTP_BODY       473   //size=64  [E-mail Body] 
.................... //if using CCS UDP Example 
.................... #define EE_UDP_DEST_IP     537   //size=4   [destination IP address for UDP example] 
.................... #define EE_UDP_DEST_PORT   541   //size=2   [destination port for UDP example] 
.................... #define EE_UDP_SRC_PORT    543   //size=2    [source port for UDP example] 
....................  
.................... #define EE_MAGIC           545 
.................... #define EE_LAST            546 
.................... #define EE_MAX             0x7FFF 
....................  
.................... #define MPFS_START_POSITION EE_LAST+2 
....................  
.................... //global variables holding PPP information 
.................... //PPP stack requires these to be global 
.................... #if STACK_USE_PPP 
.................... char ppp_phonenumber[64]; 
.................... char ppp_username[64]; 
.................... char ppp_password[64]; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP && STACK_USE_SERIAL 
.................... //Displays modem AT command result to LCD and RS232 serial output 
.................... void display_modem_result(MODEM_RESP err) { 
....................    char str[15]; 
....................    str[0]=0; 
....................  
....................    switch (err) { 
....................       case MODEM_OK:          sprintf(str,"OK");          break; 
....................       case MODEM_CONNECTED:   sprintf(str,"CONNECTED");   break; 
....................       case MODEM_BUSY:        sprintf(str,"BUSY");        break; 
....................       case MODEM_NO_RESPONSE: sprintf(str,"NO RESPONSE"); break; 
....................       case MODEM_NO_CARRIER:  sprintf(str,"NO CARRIER");  break; 
....................       case MODEM_NO_DIALTONE: sprintf(str,"NO DIALTONE"); break; 
....................       default:                sprintf(str,"ERR %U", err); break; 
....................    } 
....................  #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\n                "); 
....................    printf(lcd_putc,"\n%s",str); 
....................    delay_ms(3000); 
....................  #endif 
....................  fprintf(USER,"\r\nMODEM RESP: %s",str); 
.................... } 
.................... #endif 
....................  
.................... //Display's current IP address on the LCD and/or RS232 serial output 
.................... void display_ip_lcd(void) { 
.................... #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\n                    "); 
....................        #if STACK_USE_DHCP 
....................         #if STACK_USE_EEPROM 
....................           if (MACIsLinked() && ((DHCPIsBound() && read_ext_eeprom(EE_NIC_DHCP))||(!read_ext_eeprom(EE_NIC_DHCP)))) 
....................         #else 
....................           if (MACIsLinked() && (DHCPIsBound())) 
....................         #endif 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................           else if (MACIsLinked()) 
....................              printf(lcd_putc,"\nDHCP NOT BOUND"); 
....................           else 
....................             printf(lcd_putc,"\nNO ETHERNET LINK"); 
....................  
....................        #elif STACK_USE_PPP 
....................          if (ppp_is_connected()) { 
....................             printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................          } 
....................          else { 
....................             printf(lcd_putc,"\nNOT CONNECTED"); 
....................          } 
....................        #else 
....................         if (MACIsLinked()) { 
....................            printf(lcd_putc,"\n%U.%U.%U.%U",MY_IP_BYTE1,MY_IP_BYTE2,MY_IP_BYTE3,MY_IP_BYTE4); 
....................         } 
....................         else { 
....................            printf(lcd_putc,"\nNO ETHERNET LINK"); 
....................         } 
....................        #endif 
.................... #endif 
.................... } 
....................  
.................... //a simple routine to make a PPP connection 
.................... #if STACK_USE_PPP 
.................... void picdem_ppp_connect(void) { 
....................    MODEM_RESP ec; 
....................    int8 retries=5; 
....................  
....................    while (!ppp_is_connected() && retries--) { 
....................      #if STACK_USE_PICDEM_LCD 
....................       printf(lcd_putc,"\nDialing ISP     "); 
....................      #endif 
....................      fprintf(USER,"\r\n\nDialing ISP"); 
....................  
....................       ec=ppp_connect(ppp_username, ppp_password, ppp_phonenumber); 
....................       display_modem_result(ec); 
....................  
....................       if (connected_baudrate) { 
....................         #if STACK_USE_PICDEM_LCD 
....................          printf(lcd_putc,"\fConnect %LUbps    ", connected_baudrate); 
....................          printf(lcd_putc,"\nNegotiating PPP "); 
....................         #endif 
....................          fprintf(USER,"\r\nConnected %LU\r\nNegotiating PPP...", connected_baudrate); 
....................  
....................          while (connected_baudrate && !MY_IP.Val) { 
....................             restart_wdt(); 
....................             ppp_handle();    //keep calling the ppp task until we get assigned an IP address 
....................             //BUG: if it gets stuck, it should hang-up and redial. 
....................             //     (Many ISPs will do this for you though) 
....................          } 
....................          if (MY_IP.Val) { 
....................             display_ip_lcd();     //we got a connection, show the IP address on the LCD screen 
....................             fprintf(USER,"\r\nConnected to ISP, IP Address is %U.%U.%U.%U\r\n",MY_IP.v[0],MY_IP.v[1],MY_IP.v[2],MY_IP.v[3]); 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... #if STACK_USE_EEPROM 
....................  
.................... //null terminated 
.................... void write_ext_eeprom_string(int16 address, char *str) { 
....................    while(*str) { 
....................       write_ext_eeprom(address,*str); 
....................       address++; 
....................       str++; 
....................    } 
....................    write_ext_eeprom(address,0); 
.................... } 
....................  
.................... void write_ext_eeprom16(int16 address, int16 data) 
.................... { 
....................    write_ext_eeprom(address++, make8(data,0)); 
*
09AA:  MOVLB  1
09AC:  MOVFF  124,03
09B0:  MOVF   x23,W
09B2:  INCF   x23,F
09B4:  BTFSC  FD8.2
09B6:  INCF   x24,F
09B8:  MOVWF  x27
09BA:  MOVFF  03,128
09BE:  MOVFF  125,129
09C2:  MOVFF  03,137
09C6:  MOVWF  x36
09C8:  MOVFF  125,138
09CC:  MOVLB  0
09CE:  RCALL  093A
....................    write_ext_eeprom(address, make8(data,1)); 
09D0:  MOVFF  126,127
09D4:  MOVFF  124,137
09D8:  MOVFF  123,136
09DC:  MOVFF  126,138
09E0:  RCALL  093A
.................... } 
09E2:  RETLW  00
....................  
.................... int16 read_ext_eeprom16(int16 address) 
.................... { 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 val; 
....................    } result; 
....................  
....................    result.b[0]=read_ext_eeprom(address++); 
*
142A:  MOVLB  1
142C:  MOVFF  127,03
1430:  MOVF   x26,W
1432:  INCF   x26,F
1434:  BTFSC  FD8.2
1436:  INCF   x27,F
1438:  MOVWF  x2A
143A:  MOVFF  03,12B
143E:  MOVFF  03,137
1442:  MOVWF  x36
1444:  MOVLB  0
1446:  CALL   082E
144A:  MOVFF  01,128
....................    result.b[1]=read_ext_eeprom(address); 
144E:  MOVFF  127,137
1452:  MOVFF  126,136
1456:  CALL   082E
145A:  MOVFF  01,129
....................  
....................    return(result.val); 
145E:  MOVLB  1
1460:  MOVFF  128,01
1464:  MOVFF  129,02
.................... } 
1468:  MOVLB  0
146A:  RETLW  00
....................  
.................... void read_ext_eeprom_string(int16 address, char *str, int8 max) { 
....................    char c; 
....................    do { 
....................       c=read_ext_eeprom(address++); 
....................       *str=c; 
....................       str++; 
....................    } while ((c)&&(max--)); 
....................    *str=0; 
.................... } 
....................  
.................... void read_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.v[0]=read_ext_eeprom(address++); 
*
0B28:  MOVLB  1
0B2A:  MOVFF  12D,03
0B2E:  MOVF   x2C,W
0B30:  INCF   x2C,F
0B32:  BTFSC  FD8.2
0B34:  INCF   x2D,F
0B36:  MOVWF  x34
0B38:  MOVFF  03,135
0B3C:  MOVFF  03,137
0B40:  MOVWF  x36
0B42:  MOVLB  0
0B44:  RCALL  082E
0B46:  MOVFF  01,130
....................    temp.v[1]=read_ext_eeprom(address++); 
0B4A:  MOVLB  1
0B4C:  MOVFF  12D,03
0B50:  MOVF   x2C,W
0B52:  INCF   x2C,F
0B54:  BTFSC  FD8.2
0B56:  INCF   x2D,F
0B58:  MOVWF  x34
0B5A:  MOVFF  03,135
0B5E:  MOVFF  03,137
0B62:  MOVWF  x36
0B64:  MOVLB  0
0B66:  RCALL  082E
0B68:  MOVFF  01,131
....................    temp.v[2]=read_ext_eeprom(address++); 
0B6C:  MOVLB  1
0B6E:  MOVFF  12D,03
0B72:  MOVF   x2C,W
0B74:  INCF   x2C,F
0B76:  BTFSC  FD8.2
0B78:  INCF   x2D,F
0B7A:  MOVWF  x34
0B7C:  MOVFF  03,135
0B80:  MOVFF  03,137
0B84:  MOVWF  x36
0B86:  MOVLB  0
0B88:  RCALL  082E
0B8A:  MOVFF  01,132
....................    temp.v[3]=read_ext_eeprom(address); 
0B8E:  MOVFF  12D,137
0B92:  MOVFF  12C,136
0B96:  RCALL  082E
0B98:  MOVFF  01,133
....................    ip->Val=temp.Val; 
0B9C:  MOVLB  1
0B9E:  MOVFF  12E,FE9
0BA2:  MOVFF  12F,FEA
0BA6:  MOVFF  130,FEF
0BAA:  MOVFF  131,FEC
0BAE:  MOVFF  132,FEC
0BB2:  MOVFF  133,FEC
.................... } 
0BB6:  MOVLB  0
0BB8:  RETLW  00
....................  
.................... void write_ext_eeprom_ip(int16 address, IP_ADDR *ip) { 
....................    IP_ADDR temp; 
....................    temp.Val=ip->Val; 
*
1DEA:  MOVLB  1
1DEC:  MOVFF  12E,FE9
1DF0:  MOVFF  12F,FEA
1DF4:  MOVFF  FEF,00
1DF8:  MOVFF  FEC,01
1DFC:  MOVFF  FEC,02
1E00:  MOVFF  FEC,03
1E04:  MOVFF  03,133
1E08:  MOVFF  02,132
1E0C:  MOVFF  01,131
1E10:  MOVFF  00,130
....................    write_ext_eeprom(address++,temp.v[0]); 
1E14:  MOVFF  12D,03
1E18:  MOVF   x2C,W
1E1A:  INCF   x2C,F
1E1C:  BTFSC  FD8.2
1E1E:  INCF   x2D,F
1E20:  MOVWF  x34
1E22:  MOVFF  03,135
1E26:  MOVFF  03,137
1E2A:  MOVWF  x36
1E2C:  MOVFF  130,138
1E30:  MOVLB  0
1E32:  CALL   093A
....................    write_ext_eeprom(address++,temp.v[1]); 
1E36:  MOVLB  1
1E38:  MOVFF  12D,03
1E3C:  MOVF   x2C,W
1E3E:  INCF   x2C,F
1E40:  BTFSC  FD8.2
1E42:  INCF   x2D,F
1E44:  MOVWF  x34
1E46:  MOVFF  03,135
1E4A:  MOVFF  03,137
1E4E:  MOVWF  x36
1E50:  MOVFF  131,138
1E54:  MOVLB  0
1E56:  CALL   093A
....................    write_ext_eeprom(address++,temp.v[2]); 
1E5A:  MOVLB  1
1E5C:  MOVFF  12D,03
1E60:  MOVF   x2C,W
1E62:  INCF   x2C,F
1E64:  BTFSC  FD8.2
1E66:  INCF   x2D,F
1E68:  MOVWF  x34
1E6A:  MOVFF  03,135
1E6E:  MOVFF  03,137
1E72:  MOVWF  x36
1E74:  MOVFF  132,138
1E78:  MOVLB  0
1E7A:  CALL   093A
....................    write_ext_eeprom(address,temp.v[3]); 
1E7E:  MOVFF  12D,137
1E82:  MOVFF  12C,136
1E86:  MOVFF  133,138
1E8A:  CALL   093A
.................... } 
1E8E:  GOTO   1F4C (RETURN)
....................  
.................... //clears the EEPROM where ISP settings are saved to prevent others from getting your ISP configuration 
.................... void clear_ee(void) { 
....................    int16 i; 
....................   #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\fResetting EEPROM"); 
*
09E4:  MOVLW  0C
09E6:  MOVWF  FF6
09E8:  MOVLW  01
09EA:  MOVWF  FF7
09EC:  RCALL  0918
....................   #endif 
....................   #if STACK_USE_SERIAL 
....................    fprintf(USER,"\r\n\n\nResetting EEPROM..."); 
09EE:  MOVLW  1E
09F0:  MOVWF  FF6
09F2:  MOVLW  01
09F4:  MOVWF  FF7
09F6:  RCALL  0928
....................   #endif 
....................    for (i=0;i<MPFS_RESERVE_BLOCK;i++) { 
09F8:  MOVLB  1
09FA:  CLRF   x22
09FC:  CLRF   x21
09FE:  MOVF   x22,W
0A00:  SUBLW  02
0A02:  BNC   0A24
0A04:  BNZ   0A0C
0A06:  MOVF   x21,W
0A08:  SUBLW  27
0A0A:  BNC   0A24
....................       write_ext_eeprom(i,0); 
0A0C:  MOVFF  122,137
0A10:  MOVFF  121,136
0A14:  CLRF   x38
0A16:  MOVLB  0
0A18:  RCALL  093A
....................    } 
0A1A:  MOVLB  1
0A1C:  INCF   x21,F
0A1E:  BTFSC  FD8.2
0A20:  INCF   x22,F
0A22:  BRA    09FE
....................    write_ext_eeprom(EE_NIC_DHCP, 1); 
0A24:  CLRF   x37
0A26:  MOVLW  C0
0A28:  MOVWF  x36
0A2A:  MOVLW  01
0A2C:  MOVWF  x38
0A2E:  MOVLB  0
0A30:  RCALL  093A
....................  
....................    write_ext_eeprom(EE_NIC_MAC + 0, 0x00); 
0A32:  MOVLB  1
0A34:  CLRF   x37
0A36:  MOVLW  CD
0A38:  MOVWF  x36
0A3A:  CLRF   x38
0A3C:  MOVLB  0
0A3E:  RCALL  093A
....................    write_ext_eeprom(EE_NIC_MAC + 1, 0x03); 
0A40:  MOVLB  1
0A42:  CLRF   x37
0A44:  MOVLW  CE
0A46:  MOVWF  x36
0A48:  MOVLW  03
0A4A:  MOVWF  x38
0A4C:  MOVLB  0
0A4E:  RCALL  093A
....................    write_ext_eeprom(EE_NIC_MAC + 2, 0x04); 
0A50:  MOVLB  1
0A52:  CLRF   x37
0A54:  MOVLW  CF
0A56:  MOVWF  x36
0A58:  MOVLW  04
0A5A:  MOVWF  x38
0A5C:  MOVLB  0
0A5E:  RCALL  093A
....................    write_ext_eeprom(EE_NIC_MAC + 3, 0x05); 
0A60:  MOVLB  1
0A62:  CLRF   x37
0A64:  MOVLW  D0
0A66:  MOVWF  x36
0A68:  MOVLW  05
0A6A:  MOVWF  x38
0A6C:  MOVLB  0
0A6E:  RCALL  093A
....................    write_ext_eeprom(EE_NIC_MAC + 4, 0x06); 
0A70:  MOVLB  1
0A72:  CLRF   x37
0A74:  MOVLW  D1
0A76:  MOVWF  x36
0A78:  MOVLW  06
0A7A:  MOVWF  x38
0A7C:  MOVLB  0
0A7E:  RCALL  093A
....................    write_ext_eeprom(EE_NIC_MAC + 5, 0x07); 
0A80:  MOVLB  1
0A82:  CLRF   x37
0A84:  MOVLW  D2
0A86:  MOVWF  x36
0A88:  MOVLW  07
0A8A:  MOVWF  x38
0A8C:  MOVLB  0
0A8E:  RCALL  093A
....................  
....................    write_ext_eeprom16(EE_SMTP_PORT, 25); 
0A90:  MOVLB  1
0A92:  CLRF   x24
0A94:  MOVLW  D7
0A96:  MOVWF  x23
0A98:  CLRF   x26
0A9A:  MOVLW  19
0A9C:  MOVWF  x25
0A9E:  MOVLB  0
0AA0:  RCALL  09AA
....................  
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, 5000); 
0AA2:  MOVLW  02
0AA4:  MOVLB  1
0AA6:  MOVWF  x24
0AA8:  MOVLW  1D
0AAA:  MOVWF  x23
0AAC:  MOVLW  13
0AAE:  MOVWF  x26
0AB0:  MOVLW  88
0AB2:  MOVWF  x25
0AB4:  MOVLB  0
0AB6:  RCALL  09AA
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, 5000); 
0AB8:  MOVLW  02
0ABA:  MOVLB  1
0ABC:  MOVWF  x24
0ABE:  MOVLW  1F
0AC0:  MOVWF  x23
0AC2:  MOVLW  13
0AC4:  MOVWF  x26
0AC6:  MOVLW  88
0AC8:  MOVWF  x25
0ACA:  MOVLB  0
0ACC:  RCALL  09AA
....................  
....................    write_ext_eeprom(EE_MAGIC, 0x55); 
0ACE:  MOVLW  02
0AD0:  MOVLB  1
0AD2:  MOVWF  x37
0AD4:  MOVLW  21
0AD6:  MOVWF  x36
0AD8:  MOVLW  55
0ADA:  MOVWF  x38
0ADC:  MOVLB  0
0ADE:  RCALL  093A
....................  
....................   #if STACK_USE_SERIAL 
....................    fprintf(USER,"\r\nEEPROM Cleared. Resetting.\r\n"); 
0AE0:  MOVLW  36
0AE2:  MOVWF  FF6
0AE4:  MOVLW  01
0AE6:  MOVWF  FF7
0AE8:  RCALL  0928
....................   #endif 
....................  
....................   #if STACK_USE_PICDEM_LCD 
....................    printf(lcd_putc,"\fEEPROM Cleared"); 
0AEA:  MOVLW  56
0AEC:  MOVWF  FF6
0AEE:  MOVLW  01
0AF0:  MOVWF  FF7
0AF2:  RCALL  0918
....................    delay_ms(5000); 
0AF4:  MOVLW  14
0AF6:  MOVLB  1
0AF8:  MOVWF  x23
0AFA:  MOVLW  FA
0AFC:  MOVWF  x24
0AFE:  MOVLB  0
0B00:  RCALL  0632
0B02:  MOVLB  1
0B04:  DECFSZ x23,F
0B06:  BRA    0AFA
....................   #endif 
....................  
....................    reset_cpu(); 
0B08:  RESET
.................... } 
0B0A:  MOVLB  0
0B0C:  RETLW  00
....................  
.................... void init_eeprom_defaults(void) 
.................... { 
....................    if (read_ext_eeprom(EE_MAGIC) != 0x55) 
0B0E:  MOVLW  02
0B10:  MOVLB  1
0B12:  MOVWF  x37
0B14:  MOVLW  21
0B16:  MOVWF  x36
0B18:  MOVLB  0
0B1A:  RCALL  082E
0B1C:  MOVF   01,W
0B1E:  SUBLW  55
0B20:  BZ    0B24
....................       clear_ee(); 
0B22:  RCALL  09E4
.................... } 
0B24:  GOTO   11D4 (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... int16 SMTP_PORT; 
.................... char SMTP_HOST_NAME[64]; 
.................... char SMTP_TO_ADDR[64];     //To address of your e-mail 
.................... char SMTP_FROM_ADDR[64];       //From address of your e-mail 
.................... char SMTP_SUBJECT[64];                 //Subject of your e-mail 
.................... char SMTP_BODY[64];      //Body of your e-mail 
....................  
.................... void init_smtp_settings(void) { 
....................  read_ext_eeprom_string(EE_SMTP_HOSTNAME,SMTP_HOST_NAME,64); 
....................  SMTP_PORT=read_ext_eeprom16(EE_SMTP_PORT); 
....................  read_ext_eeprom_string(EE_SMTP_TO,SMTP_TO_ADDR,64); 
....................  read_ext_eeprom_string(EE_SMTP_FROM,SMTP_FROM_ADDR,64); 
....................  read_ext_eeprom_string(EE_SMTP_SUBJECT,SMTP_SUBJECT,64); 
....................  read_ext_eeprom_string(EE_SMTP_BODY,SMTP_BODY,64); 
.................... } 
.................... #endif 
....................  
.................... //Initializes hardware, stack, default IP address and MAC address. 
.................... void init(void) { 
....................    setup_wdt(WDT_OFF); 
*
1164:  BCF    FD1.0
....................    set_tris_a(0xFF); 
1166:  MOVLW  FF
1168:  MOVWF  F92
....................    set_tris_b(0xFF); 
116A:  MOVWF  F93
....................    set_tris_c(0xFF); 
116C:  MOVWF  F94
.................... #if !STACK_USE_CCS_EWL5V 
....................    set_tris_d(0xFF); 
116E:  MOVWF  F95
....................    set_tris_e(0xFF); 
1170:  BSF    F96.0
1172:  BSF    F96.1
1174:  BSF    F96.2
....................  #if STACK_USE_CCS_PICNET 
....................    set_tris_f(0xFF); 
....................  #endif 
.................... #endif 
....................  
....................    #if !STACK_USE_CCS_EWL5V 
....................    setup_comparator(NC_NC_NC_NC); 
1176:  MOVLW  07
1178:  MOVWF  FB4
117A:  MOVF   F95,W
117C:  MOVWF  F95
117E:  MOVF   F96,W
1180:  MOVWF  F96
1182:  MOVLW  10
1184:  MOVWF  00
1186:  DECFSZ 00,F
1188:  BRA    1186
118A:  NOP   
118C:  MOVF   FB4,W
118E:  BCF    FA1.6
....................    #endif 
....................  
....................    setup_adc_ports(ANALOG_PORT_CONFIG); 
1190:  BCF    FC1.0
1192:  BSF    FC1.1
1194:  BSF    FC1.2
1196:  BSF    FC1.3
....................   
....................    setup_adc(ADC_CLOCK_INTERNAL); 
1198:  BCF    FC1.6
119A:  BSF    FC2.6
119C:  BSF    FC2.7
119E:  BCF    FC1.7
11A0:  BSF    FC2.0
....................  #if STACK_USE_CCS_PICEEC||STACK_USE_CCS_EWL3V 
....................    bit_clear(*0xFC2,7); //temporary fix to a CCS bug 
....................  #endif 
....................   
....................  #if defined(ADC_CHAN_0) 
....................    set_adc_channel(ADC_CHAN_0); 
11A2:  MOVLW  00
11A4:  MOVWF  01
11A6:  MOVF   FC2,W
11A8:  ANDLW  C7
11AA:  IORWF  01,W
11AC:  MOVWF  FC2
....................  #endif 
....................  
....................    OUTPUT_DRIVE_MACRO(PIN_C6); 
11AE:  BCF    F94.6
....................    //OUTPUT_FLOAT_MACRO(PIN_C7); 
....................  
....................  #if defined(USER_LED1) 
....................    OUTPUT_DRIVE_MACRO(USER_LED1); 
11B0:  BCF    F92.5
....................    output_high(USER_LED1); 
11B2:  BSF    F89.5
....................  #endif 
....................  
....................  #if defined(USER_LED2) 
....................    OUTPUT_DRIVE_MACRO(USER_LED2); 
11B4:  BCF    F93.4
....................    output_high(USER_LED2); 
11B6:  BSF    F8A.4
....................  #endif 
....................  
....................   #if defined(USER_LED3) 
....................    OUTPUT_DRIVE_MACRO(USER_LED3); 
11B8:  BCF    F93.5
....................    output_high(USER_LED3); 
11BA:  BSF    F8A.5
....................   #endif 
....................  
....................   #if defined(USER_BUTTON1) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON1); 
11BC:  BSF    F92.4
....................   #endif 
....................  
....................   #if defined(USER_BUTTON2) 
....................    OUTPUT_FLOAT_MACRO(USER_BUTTON2); 
....................   #endif 
....................  
....................  #if defined(EEPROM_SELECT) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_SELECT); 
11BE:  BCF    F93.3
....................  #endif 
....................  
....................  #if defined(EEPROM_DI) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_DI); 
11C0:  BCF    F94.5
....................  #endif 
....................  
....................  #if defined(EEPROM_DO) 
....................   OUTPUT_FLOAT_MACRO(EEPROM_DO); 
11C2:  BSF    F94.4
....................  #endif 
....................  
....................  #if defined(EEPROM_CLK) 
....................   OUTPUT_DRIVE_MACRO(EEPROM_CLK); 
11C4:  BCF    F94.3
....................  #endif 
....................  
....................  #if defined(MMC_SELECT) 
....................   OUTPUT_DRIVE_MACRO(MMC_SELECT); 
....................  #endif 
....................   
....................  #if defined(FLASH_SELECT) 
....................   OUTPUT_DRIVE_MACRO(FLASH_SELECT); 
....................  #endif 
....................   
....................  #if defined(FLASH_CLOCK) 
....................   OUTPUT_DRIVE_MACRO(FLASH_CLOCK); 
....................  #endif 
....................   
....................  #if defined(FLASH_DI) 
....................   OUTPUT_DRIVE_MACRO(FLASH_DI); 
....................  #endif 
....................   
....................  #if defined(FLASH_DO) 
....................   OUTPUT_FLOAT_MACRO(FLASH_DO); 
....................  #endif 
....................   
....................  #if defined(DAL_SCL) 
....................   OUTPUT_DRIVE_MACRO(DAL_SCL); 
....................   output_high(DAL_SCL); 
....................  #endif 
....................   
....................  #if defined(DAL_SDA) 
....................   OUTPUT_DRIVE_MACRO(DAL_SDA); 
....................   output_high(DAL_SCL); 
....................  #endif 
....................   
....................  #if defined(DIGITAL1) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL1); 
....................  #endif 
....................  #if defined(DIGITAL2) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL2); 
....................  #endif 
....................  #if defined(DIGITAL3) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL3); 
....................  #endif 
....................  #if defined(DIGITAL4) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL4); 
....................  #endif 
....................  #if defined(DIGITAL5) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL5); 
....................  #endif 
....................  #if defined(DIGITAL6) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL6); 
....................  #endif 
....................  #if defined(DIGITAL7) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL7); 
....................  #endif 
....................  #if defined(DIGITAL8) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL8); 
....................  #endif 
....................  #if defined(DIGITAL9) 
....................   OUTPUT_FLOAT_MACRO(DIGITAL9); 
....................  #endif 
....................  #if defined(DIGITAL10) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL10); 
....................  #endif 
....................  #if defined(DIGITAL11) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL11); 
....................  #endif 
....................  #if defined(DIGITAL12) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL12); 
....................  #endif 
....................  #if defined(DIGITAL13) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL13); 
....................  #endif 
....................  #if defined(DIGITAL14) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL14); 
....................  #endif 
....................  #if defined(DIGITAL15) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL15); 
....................  #endif 
....................  #if defined(DIGITAL16) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL16); 
....................  #endif 
....................  #if defined(DIGITAL17) 
....................   OUTPUT_DRIVE_MACRO(DIGITAL17); 
....................  #endif 
....................   
.................... #if STACK_USE_PICDEM_LCD 
....................    lcd_init(); 
11C6:  GOTO   0720
.................... #endif 
....................  
.................... #if STACK_USE_TEMP 
....................    init_temp(); 
.................... #endif 
....................   #if STACK_USE_MCPENC 
....................    //Normally StackInit() will call this, but since we are sharing the same 
....................    //SPI pins for the ENC and EEPROM, we need to call it now so we can use 
....................    //the EEPROM before we do a StackInit(). 
....................    ENCSPIInit(); 
11CA:  CALL   07A4
....................   #endif 
....................    
....................  #if STACK_USE_EEPROM 
....................    init_ext_eeprom(); 
11CE:  GOTO   07C8
....................    init_eeprom_defaults(); 
11D2:  BRA    0B0E
....................    // 
....................    // Load default configuration into RAM. 
....................    // 
....................  
....................  #if STACK_USE_PPP 
....................  read_ext_eeprom_string(EE_ISP_PHONENUMBER,ppp_phonenumber,64); 
....................  read_ext_eeprom_string(EE_ISP_USERNAME,ppp_username,64); 
....................  read_ext_eeprom_string(EE_ISP_PASSWORD,ppp_password,64); 
....................  #elif STACK_USE_MAC 
....................    read_ext_eeprom_ip(EE_NIC_IP, &AppConfig.MyIPAddr); 
11D4:  MOVLB  1
11D6:  CLRF   x2D
11D8:  MOVLW  C5
11DA:  MOVWF  x2C
11DC:  CLRF   x2F
11DE:  MOVLW  16
11E0:  MOVWF  x2E
11E2:  MOVLB  0
11E4:  RCALL  0B28
....................    read_ext_eeprom_ip(EE_NIC_NETMASK, &AppConfig.MyMask); 
11E6:  MOVLB  1
11E8:  CLRF   x2D
11EA:  MOVLW  C9
11EC:  MOVWF  x2C
11EE:  CLRF   x2F
11F0:  MOVLW  20
11F2:  MOVWF  x2E
11F4:  MOVLB  0
11F6:  RCALL  0B28
....................    read_ext_eeprom_ip(EE_NIC_GATEWAY, &AppConfig.MyGateway); 
11F8:  MOVLB  1
11FA:  CLRF   x2D
11FC:  MOVLW  C1
11FE:  MOVWF  x2C
1200:  CLRF   x2F
1202:  MOVLW  24
1204:  MOVWF  x2E
1206:  MOVLB  0
1208:  RCALL  0B28
....................   #if STACK_USE_DNS 
....................    read_ext_eeprom_ip(EE_DNS, &AppConfig.PrimaryDNSServer); 
....................   #endif 
....................  
....................    AppConfig.MyMACAddr.v[0]    = read_ext_eeprom(EE_NIC_MAC + 0); 
120A:  MOVLB  1
120C:  CLRF   x37
120E:  MOVLW  CD
1210:  MOVWF  x36
1212:  MOVLB  0
1214:  CALL   082E
1218:  MOVFF  01,1A
....................    AppConfig.MyMACAddr.v[1]    = read_ext_eeprom(EE_NIC_MAC + 1); 
121C:  MOVLB  1
121E:  CLRF   x37
1220:  MOVLW  CE
1222:  MOVWF  x36
1224:  MOVLB  0
1226:  CALL   082E
122A:  MOVFF  01,1B
....................    AppConfig.MyMACAddr.v[2]    = read_ext_eeprom(EE_NIC_MAC + 2); 
122E:  MOVLB  1
1230:  CLRF   x37
1232:  MOVLW  CF
1234:  MOVWF  x36
1236:  MOVLB  0
1238:  CALL   082E
123C:  MOVFF  01,1C
....................    AppConfig.MyMACAddr.v[3]    = read_ext_eeprom(EE_NIC_MAC + 3); 
1240:  MOVLB  1
1242:  CLRF   x37
1244:  MOVLW  D0
1246:  MOVWF  x36
1248:  MOVLB  0
124A:  CALL   082E
124E:  MOVFF  01,1D
....................    AppConfig.MyMACAddr.v[4]    = read_ext_eeprom(EE_NIC_MAC + 4); 
1252:  MOVLB  1
1254:  CLRF   x37
1256:  MOVLW  D1
1258:  MOVWF  x36
125A:  MOVLB  0
125C:  CALL   082E
1260:  MOVFF  01,1E
....................    AppConfig.MyMACAddr.v[5]    = read_ext_eeprom(EE_NIC_MAC + 5); 
1264:  MOVLB  1
1266:  CLRF   x37
1268:  MOVLW  D2
126A:  MOVWF  x36
126C:  MOVLB  0
126E:  CALL   082E
1272:  MOVFF  01,1F
....................  
....................    #if STACK_USE_DHCP 
....................    if (!read_ext_eeprom(EE_NIC_DHCP)) 
1276:  MOVLB  1
1278:  CLRF   x37
127A:  MOVLW  C0
127C:  MOVWF  x36
127E:  MOVLB  0
1280:  CALL   082E
1284:  MOVF   01,F
1286:  BNZ   128C
....................       DHCPDisable(); 
1288:  MOVLW  08
128A:  MOVWF  x85
....................    #endif 
....................  #endif 
.................... #else //no eeprom 
....................    AppConfig.MyMACAddr.v[0] = 2; 
....................    AppConfig.MyMACAddr.v[1] = 2; 
....................    AppConfig.MyMACAddr.v[2] = 2; 
....................    AppConfig.MyMACAddr.v[3] = 2; 
....................    AppConfig.MyMACAddr.v[4] = 2; 
....................    AppConfig.MyMACAddr.v[5] = 2; 
.................... #endif 
....................  
....................  #if STACK_USE_ANNOUNCE 
....................   #if STACK_USE_CCS_PICNET 
....................    InitAnnounce("PICNET"); 
....................   #elif STACK_USE_CCS_PICENS 
....................    InitAnnounce("PICENS"); 
....................   #elif STACK_USE_CCS_PICEEC 
....................    InitAnnounce("PICEEC"); 
....................   #elif STACK_USE_CCS_EWL 
....................    InitAnnounce("EZ WEB LYNX"); 
....................   #endif 
....................  #endif 
....................  
....................  #if STACK_USE_MPFS 
....................    MPFSInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    fat_init(); 
.................... #endif 
....................   
....................    StackInit(); 
128C:  BRA    1152
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................    init_smtp_settings(); 
.................... #endif 
.................... } 
128E:  GOTO   5C64 (RETURN)
....................  
.................... int1 set_port_bit(int8 *ptr, int16 fullPin, int1 new) 
.................... { 
....................    int port, pin; 
....................    int1 old; 
....................  
....................    fullPin -=  (int16)PIN_A0; 
*
2140:  MOVLW  00
2142:  MOVLB  1
2144:  SUBWF  x34,F
2146:  MOVLW  7C
2148:  SUBWFB x35,F
....................    port = fullPin / 8; 
214A:  RRCF   x35,W
214C:  MOVWF  03
214E:  RRCF   x34,W
2150:  MOVWF  02
2152:  RRCF   03,F
2154:  RRCF   02,F
2156:  RRCF   03,F
2158:  RRCF   02,F
215A:  MOVFF  02,137
....................    pin = fullPin % 8; 
215E:  MOVF   x34,W
2160:  ANDLW  07
2162:  MOVWF  x38
....................  
....................    ptr += port; 
2164:  MOVF   x37,W
2166:  ADDWF  x32,F
2168:  MOVLW  00
216A:  ADDWFC x33,F
....................  
....................    port = *ptr; 
216C:  MOVFF  132,FE9
2170:  MOVFF  133,FEA
2174:  MOVFF  FEF,137
....................    old = bit_test(port, pin); 
2178:  MOVFF  137,00
217C:  MOVF   x38,W
217E:  MOVWF  01
2180:  BZ    218A
2182:  BCF    FD8.0
2184:  RRCF   00,F
2186:  DECFSZ 01,F
2188:  BRA    2182
218A:  BCF    x39.0
218C:  BTFSC  00.0
218E:  BSF    x39.0
....................    if (new) 
2190:  MOVF   x36,F
2192:  BZ    21AC
....................       bit_set(port, pin); 
2194:  MOVLW  01
2196:  MOVWF  00
2198:  MOVF   x38,W
219A:  MOVWF  01
219C:  BZ    21A6
219E:  BCF    FD8.0
21A0:  RLCF   00,F
21A2:  DECFSZ 01,F
21A4:  BRA    219E
21A6:  MOVF   00,W
21A8:  IORWF  x37,F
....................    else 
21AA:  BRA    21C4
....................       bit_clear(port, pin); 
21AC:  MOVLW  01
21AE:  MOVWF  00
21B0:  MOVF   x38,W
21B2:  MOVWF  01
21B4:  BZ    21BE
21B6:  BCF    FD8.0
21B8:  RLCF   00,F
21BA:  DECFSZ 01,F
21BC:  BRA    21B6
21BE:  MOVF   00,W
21C0:  XORLW  FF
21C2:  ANDWF  x37,F
....................  
....................    *ptr = port; 
21C4:  MOVFF  132,FE9
21C8:  MOVFF  133,FEA
21CC:  MOVFF  137,FEF
....................  
....................    return(old); 
21D0:  MOVLW  00
21D2:  BTFSC  x39.0
21D4:  MOVLW  01
21D6:  MOVWF  01
.................... } 
21D8:  MOVLB  0
21DA:  RETLW  00
....................  
.................... int1 get_port_bit(int8 *ptr, int16 fullPin) 
.................... { 
....................    int port, pin; 
....................  
....................    fullPin -=  (int16)PIN_A0; 
21DC:  MOVLW  00
21DE:  MOVLB  1
21E0:  SUBWF  x33,F
21E2:  MOVLW  7C
21E4:  SUBWFB x34,F
....................    port = fullPin / 8; 
21E6:  RRCF   x34,W
21E8:  MOVWF  03
21EA:  RRCF   x33,W
21EC:  MOVWF  02
21EE:  RRCF   03,F
21F0:  RRCF   02,F
21F2:  RRCF   03,F
21F4:  RRCF   02,F
21F6:  MOVFF  02,135
....................    pin = fullPin % 8; 
21FA:  MOVF   x33,W
21FC:  ANDLW  07
21FE:  MOVWF  x36
....................  
....................    ptr += port; 
2200:  MOVF   x35,W
2202:  ADDWF  x31,F
2204:  MOVLW  00
2206:  ADDWFC x32,F
....................  
....................    port = *ptr; 
2208:  MOVFF  131,FE9
220C:  MOVFF  132,FEA
2210:  MOVFF  FEF,135
....................  
....................    return(bit_test(port, pin)); 
2214:  MOVFF  135,00
2218:  MOVF   x36,W
221A:  MOVWF  01
221C:  BZ    2226
221E:  BCF    FD8.0
2220:  RRCF   00,F
2222:  DECFSZ 01,F
2224:  BRA    221E
2226:  MOVLW  00
2228:  BTFSC  00.0
222A:  MOVLW  01
222C:  MOVWF  01
.................... } 
222E:  MOVLB  0
2230:  RETLW  00
....................  
.................... #if defined(__PCH__) 
....................  #define set_tris_variable(fullPin, new) set_port_bit(0xF92, fullPin, new) 
....................  #define set_lat_variable(fullPin, new) set_port_bit(0xF89, fullPin, new) 
....................  #define input_variable(fullPin) get_port_bit(0xF80, fullPin) 
.................... #else 
....................  #define set_tris_variable(fullPin, new) set_port_bit(0x85, fullPin, new) 
....................  #define set_lat_variable(fullPin, new) set_port_bit(0x05, fullPin, new) 
....................  #define input_variable(fullPin) get_port_bit(0x05, fullPin) 
.................... #endif 
....................  
.................... #define output_float_variable(x) set_tris_variable(x,1) 
.................... #define output_drive_variable(x) set_tris_variable(x,0) 
....................  
.................... #define output_low_variable(x) set_lat_variable(x,0) 
.................... #define output_high_variable(x) set_lat_variable(x,1) 
....................  
.................... void get_pin_string(int16 fullPin, char *str) 
.................... { 
....................    int port,pin; 
....................    fullPin -=  (int16)PIN_A0; 
*
2246:  MOVLW  00
2248:  MOVLB  1
224A:  SUBWF  x31,F
224C:  MOVLW  7C
224E:  SUBWFB x32,F
....................    port = fullPin / 8; 
2250:  RRCF   x32,W
2252:  MOVWF  03
2254:  RRCF   x31,W
2256:  MOVWF  02
2258:  RRCF   03,F
225A:  RRCF   02,F
225C:  RRCF   03,F
225E:  RRCF   02,F
2260:  MOVFF  02,135
....................    pin = fullPin % 8; 
2264:  MOVF   x31,W
2266:  ANDLW  07
2268:  MOVWF  x36
....................    sprintf(str, "PIN_"); 
226A:  MOVFF  134,FF
226E:  MOVFF  133,FE
2272:  MOVLW  66
2274:  MOVWF  FF6
2276:  MOVLW  01
2278:  MOVWF  FF7
227A:  MOVLB  0
227C:  BRA    2232
....................    port += 'A'; 
227E:  MOVLW  41
2280:  MOVLB  1
2282:  ADDWF  x35,F
....................    pin += '0'; 
2284:  MOVLW  30
2286:  ADDWF  x36,F
....................    str[4]=port; 
2288:  MOVLW  04
228A:  ADDWF  x33,W
228C:  MOVWF  FE9
228E:  MOVLW  00
2290:  ADDWFC x34,W
2292:  MOVWF  FEA
2294:  MOVFF  135,FEF
....................    str[5]=pin; 
2298:  MOVLW  05
229A:  ADDWF  x33,W
229C:  MOVWF  FE9
229E:  MOVLW  00
22A0:  ADDWFC x34,W
22A2:  MOVWF  FEA
22A4:  MOVFF  136,FEF
....................    str[6]=0; 
22A8:  MOVLW  06
22AA:  ADDWF  x33,W
22AC:  MOVWF  FE9
22AE:  MOVLW  00
22B0:  ADDWFC x34,W
22B2:  MOVWF  FEA
22B4:  CLRF   FEF
.................... } 
22B6:  MOVLB  0
22B8:  RETLW  00
....................  
.................... int1 hardware_io_test_pin(int16 pin1, int16 pin2) 
.................... { 
....................    int fail=0; 
*
22D0:  MOVLB  1
22D2:  CLRF   x27
....................    char str[8]; 
....................    int1 oldTRIS1, oldTRIS2, oldLAT1, oldLAT2; 
....................    oldLAT1=output_low_variable(pin1); 
22D4:  MOVLW  0F
22D6:  MOVWF  x33
22D8:  MOVLW  89
22DA:  MOVWF  x32
22DC:  MOVFF  124,135
22E0:  MOVFF  123,134
22E4:  CLRF   x36
22E6:  MOVLB  0
22E8:  RCALL  2140
22EA:  MOVLB  1
22EC:  BCF    x30.2
22EE:  BTFSC  01.0
22F0:  BSF    x30.2
....................    oldLAT2=output_low_variable(pin2); 
22F2:  MOVLW  0F
22F4:  MOVWF  x33
22F6:  MOVLW  89
22F8:  MOVWF  x32
22FA:  MOVFF  126,135
22FE:  MOVFF  125,134
2302:  CLRF   x36
2304:  MOVLB  0
2306:  RCALL  2140
2308:  MOVLB  1
230A:  BCF    x30.3
230C:  BTFSC  01.0
230E:  BSF    x30.3
....................    oldTRIS1=output_drive_variable(pin1); 
2310:  MOVLW  0F
2312:  MOVWF  x33
2314:  MOVLW  92
2316:  MOVWF  x32
2318:  MOVFF  124,135
231C:  MOVFF  123,134
2320:  CLRF   x36
2322:  MOVLB  0
2324:  RCALL  2140
2326:  MOVLB  1
2328:  BCF    x30.0
232A:  BTFSC  01.0
232C:  BSF    x30.0
....................    oldTRIS2=output_float_variable(pin2); 
232E:  MOVLW  0F
2330:  MOVWF  x33
2332:  MOVLW  92
2334:  MOVWF  x32
2336:  MOVFF  126,135
233A:  MOVFF  125,134
233E:  MOVLW  01
2340:  MOVWF  x36
2342:  MOVLB  0
2344:  RCALL  2140
2346:  MOVLB  1
2348:  BCF    x30.1
234A:  BTFSC  01.0
234C:  BSF    x30.1
....................    delay_us(100); 
234E:  MOVLW  A6
2350:  MOVWF  00
2352:  DECFSZ 00,F
2354:  BRA    2352
2356:  NOP   
....................    if (input_variable(pin2)) 
2358:  MOVLW  0F
235A:  MOVWF  x32
235C:  MOVLW  80
235E:  MOVWF  x31
2360:  MOVFF  126,134
2364:  MOVFF  125,133
2368:  MOVLB  0
236A:  RCALL  21DC
236C:  MOVF   01,F
236E:  BZ    2374
....................       fail |= 1; 
2370:  MOVLB  1
2372:  BSF    x27.0
....................  
....................    output_high_variable(pin1); 
2374:  MOVLW  0F
2376:  MOVLB  1
2378:  MOVWF  x33
237A:  MOVLW  89
237C:  MOVWF  x32
237E:  MOVFF  124,135
2382:  MOVFF  123,134
2386:  MOVLW  01
2388:  MOVWF  x36
238A:  MOVLB  0
238C:  RCALL  2140
....................    delay_us(100); 
238E:  MOVLW  A6
2390:  MOVWF  00
2392:  DECFSZ 00,F
2394:  BRA    2392
2396:  NOP   
....................    if (!input_variable(pin2)) 
2398:  MOVLW  0F
239A:  MOVLB  1
239C:  MOVWF  x32
239E:  MOVLW  80
23A0:  MOVWF  x31
23A2:  MOVFF  126,134
23A6:  MOVFF  125,133
23AA:  MOVLB  0
23AC:  RCALL  21DC
23AE:  MOVF   01,F
23B0:  BNZ   23B6
....................       fail |= 2; 
23B2:  MOVLB  1
23B4:  BSF    x27.1
....................  
....................    output_low_variable(pin2); 
23B6:  MOVLW  0F
23B8:  MOVLB  1
23BA:  MOVWF  x33
23BC:  MOVLW  89
23BE:  MOVWF  x32
23C0:  MOVFF  126,135
23C4:  MOVFF  125,134
23C8:  CLRF   x36
23CA:  MOVLB  0
23CC:  RCALL  2140
....................    output_float_variable(pin1); 
23CE:  MOVLW  0F
23D0:  MOVLB  1
23D2:  MOVWF  x33
23D4:  MOVLW  92
23D6:  MOVWF  x32
23D8:  MOVFF  124,135
23DC:  MOVFF  123,134
23E0:  MOVLW  01
23E2:  MOVWF  x36
23E4:  MOVLB  0
23E6:  RCALL  2140
....................    output_drive_variable(pin2); 
23E8:  MOVLW  0F
23EA:  MOVLB  1
23EC:  MOVWF  x33
23EE:  MOVLW  92
23F0:  MOVWF  x32
23F2:  MOVFF  126,135
23F6:  MOVFF  125,134
23FA:  CLRF   x36
23FC:  MOVLB  0
23FE:  RCALL  2140
....................    delay_us(100); 
2400:  MOVLW  A6
2402:  MOVWF  00
2404:  DECFSZ 00,F
2406:  BRA    2404
2408:  NOP   
....................    if (input_variable(pin1)) 
240A:  MOVLW  0F
240C:  MOVLB  1
240E:  MOVWF  x32
2410:  MOVLW  80
2412:  MOVWF  x31
2414:  MOVFF  124,134
2418:  MOVFF  123,133
241C:  MOVLB  0
241E:  RCALL  21DC
2420:  MOVF   01,F
2422:  BZ    2428
....................       fail |= 4; 
2424:  MOVLB  1
2426:  BSF    x27.2
....................  
....................    output_high_variable(pin2); 
2428:  MOVLW  0F
242A:  MOVLB  1
242C:  MOVWF  x33
242E:  MOVLW  89
2430:  MOVWF  x32
2432:  MOVFF  126,135
2436:  MOVFF  125,134
243A:  MOVLW  01
243C:  MOVWF  x36
243E:  MOVLB  0
2440:  RCALL  2140
....................    delay_us(100); 
2442:  MOVLW  A6
2444:  MOVWF  00
2446:  DECFSZ 00,F
2448:  BRA    2446
244A:  NOP   
....................    if (!input_variable(pin1)) 
244C:  MOVLW  0F
244E:  MOVLB  1
2450:  MOVWF  x32
2452:  MOVLW  80
2454:  MOVWF  x31
2456:  MOVFF  124,134
245A:  MOVFF  123,133
245E:  MOVLB  0
2460:  RCALL  21DC
2462:  MOVF   01,F
2464:  BNZ   246A
....................       fail |= 8; 
2466:  MOVLB  1
2468:  BSF    x27.3
....................  
....................    set_lat_variable(pin1, oldLAT1); 
246A:  MOVLW  00
246C:  MOVLB  1
246E:  BTFSC  x30.2
2470:  MOVLW  01
2472:  MOVWF  x31
2474:  MOVLW  0F
2476:  MOVWF  x33
2478:  MOVLW  89
247A:  MOVWF  x32
247C:  MOVFF  124,135
2480:  MOVFF  123,134
2484:  MOVFF  131,136
2488:  MOVLB  0
248A:  RCALL  2140
....................    set_lat_variable(pin2, oldLAT2); 
248C:  MOVLW  00
248E:  MOVLB  1
2490:  BTFSC  x30.3
2492:  MOVLW  01
2494:  MOVWF  x31
2496:  MOVLW  0F
2498:  MOVWF  x33
249A:  MOVLW  89
249C:  MOVWF  x32
249E:  MOVFF  126,135
24A2:  MOVFF  125,134
24A6:  MOVFF  131,136
24AA:  MOVLB  0
24AC:  RCALL  2140
....................    set_tris_variable(pin1, oldTRIS1); 
24AE:  MOVLW  00
24B0:  MOVLB  1
24B2:  BTFSC  x30.0
24B4:  MOVLW  01
24B6:  MOVWF  x31
24B8:  MOVLW  0F
24BA:  MOVWF  x33
24BC:  MOVLW  92
24BE:  MOVWF  x32
24C0:  MOVFF  124,135
24C4:  MOVFF  123,134
24C8:  MOVFF  131,136
24CC:  MOVLB  0
24CE:  RCALL  2140
....................    set_tris_variable(pin2, oldTRIS2); 
24D0:  MOVLW  00
24D2:  MOVLB  1
24D4:  BTFSC  x30.1
24D6:  MOVLW  01
24D8:  MOVWF  x31
24DA:  MOVLW  0F
24DC:  MOVWF  x33
24DE:  MOVLW  92
24E0:  MOVWF  x32
24E2:  MOVFF  126,135
24E6:  MOVFF  125,134
24EA:  MOVFF  131,136
24EE:  MOVLB  0
24F0:  RCALL  2140
....................  
....................  #if STACK_USE_SERIAL 
....................    if (fail) 
24F2:  MOVLB  1
24F4:  MOVF   x27,F
24F6:  BZ    25AA
....................    { 
....................       get_pin_string(pin1, str); 
24F8:  MOVFF  124,132
24FC:  MOVFF  123,131
2500:  MOVLW  01
2502:  MOVWF  x34
2504:  MOVLW  28
2506:  MOVWF  x33
2508:  MOVLB  0
250A:  RCALL  2246
....................       fprintf(USER,"%s <-> ", str); 
250C:  MOVLW  01
250E:  MOVWF  FEA
2510:  MOVLW  28
2512:  MOVWF  FE9
2514:  RCALL  22BA
2516:  MOVLW  6E
2518:  MOVWF  FF6
251A:  MOVLW  01
251C:  MOVWF  FF7
251E:  MOVLW  05
2520:  MOVLB  1
2522:  MOVWF  x31
2524:  MOVLB  0
2526:  CALL   1292
....................       get_pin_string(pin2, str); 
252A:  MOVFF  126,132
252E:  MOVFF  125,131
2532:  MOVLW  01
2534:  MOVLB  1
2536:  MOVWF  x34
2538:  MOVLW  28
253A:  MOVWF  x33
253C:  MOVLB  0
253E:  RCALL  2246
....................       fprintf(USER,"%s ", str); 
2540:  MOVLW  01
2542:  MOVWF  FEA
2544:  MOVLW  28
2546:  MOVWF  FE9
2548:  RCALL  22BA
254A:  MOVLW  20
254C:  BTFSS  F9E.4
254E:  BRA    254C
2550:  MOVWF  FAD
....................       if (fail) 
2552:  MOVLB  1
2554:  MOVF   x27,F
2556:  BZ    2586
....................          fprintf(USER,"FAIL [%X]", fail); 
2558:  MOVLW  74
255A:  MOVWF  FF6
255C:  MOVLW  01
255E:  MOVWF  FF7
2560:  MOVLW  06
2562:  MOVWF  x31
2564:  MOVLB  0
2566:  CALL   1292
256A:  MOVFF  127,131
256E:  MOVLW  37
2570:  MOVLB  1
2572:  MOVWF  x32
2574:  MOVLB  0
2576:  CALL   12AC
257A:  MOVLW  5D
257C:  BTFSS  F9E.4
257E:  BRA    257C
2580:  MOVWF  FAD
....................       else 
2582:  BRA    2598
2584:  MOVLB  1
....................          fprintf(USER,"OK"); 
2586:  MOVLW  4F
2588:  BTFSS  F9E.4
258A:  BRA    2588
258C:  MOVWF  FAD
258E:  MOVLW  4B
2590:  BTFSS  F9E.4
2592:  BRA    2590
2594:  MOVWF  FAD
2596:  MOVLB  0
....................       fprintf(USER,"\r\n"); 
2598:  MOVLW  0D
259A:  BTFSS  F9E.4
259C:  BRA    259A
259E:  MOVWF  FAD
25A0:  MOVLW  0A
25A2:  BTFSS  F9E.4
25A4:  BRA    25A2
25A6:  MOVWF  FAD
25A8:  MOVLB  1
....................    } 
....................  #endif 
....................  
....................    return(fail != 0); 
25AA:  MOVF   x27,F
25AC:  BNZ   25B2
25AE:  MOVLW  00
25B0:  BRA    25B4
25B2:  MOVLW  01
25B4:  MOVWF  01
.................... } 
25B6:  MOVLB  0
25B8:  RETLW  00
....................  
.................... #if STACK_USE_SERIAL 
.................... #if STACK_USE_CCS_PICENS 
.................... void hardware_test(void) 
.................... { 
....................    int1 fail_nic=0,fail_ee=0; 
25BA:  MOVLB  1
25BC:  BCF    x21.0
25BE:  BCF    x21.1
....................    int1 fail_pins=0; 
25C0:  BCF    x21.2
....................  
....................    fprintf(USER,"\r\n\n\nENC28J60 Test: "); 
25C2:  MOVLW  7E
25C4:  MOVWF  FF6
25C6:  MOVLW  01
25C8:  MOVWF  FF7
25CA:  MOVLB  0
25CC:  CALL   0928
....................    SPISelectEthernet(); 
25D0:  BCF    F95.1
25D2:  BCF    F8C.1
....................    BankSel(MAADR1); 
25D4:  MOVLW  03
25D6:  MOVLB  1
25D8:  MOVWF  xA0
25DA:  MOVLW  04
25DC:  MOVWF  x9F
25DE:  MOVLB  0
25E0:  CALL   0C7A
....................    WriteReg(MAADR1 + 0, 0x15); 
25E4:  MOVLW  04
25E6:  MOVLB  1
25E8:  MOVWF  xA2
25EA:  MOVLW  15
25EC:  MOVWF  xA3
25EE:  MOVLB  0
25F0:  CALL   0C20
....................    WriteReg(MAADR1 + 1, 0x26); 
25F4:  MOVLW  05
25F6:  MOVLB  1
25F8:  MOVWF  xA2
25FA:  MOVLW  26
25FC:  MOVWF  xA3
25FE:  MOVLB  0
2600:  CALL   0C20
....................    WriteReg(MAADR1 + 2, 0x37); 
2604:  MOVLW  06
2606:  MOVLB  1
2608:  MOVWF  xA2
260A:  MOVLW  37
260C:  MOVWF  xA3
260E:  MOVLB  0
2610:  CALL   0C20
....................    if (ReadMACReg(MAADR1 + 1).Val != 0x26) 
2614:  MOVLW  05
2616:  MOVLB  1
2618:  MOVWF  x29
261A:  MOVLB  0
261C:  CALL   0CB0
2620:  MOVFF  01,122
2624:  MOVLB  1
2626:  MOVF   01,W
2628:  SUBLW  26
262A:  BZ    262E
....................       fail_nic = TRUE; 
262C:  BSF    x21.0
....................    SPIUnselectEthernet(); 
262E:  BCF    F95.1
2630:  BSF    F8C.1
....................    if (fail_nic) 
2632:  BTFSS  x21.0
2634:  BRA    2648
....................       fprintf(USER,"FAIL"); 
2636:  MOVLW  92
2638:  MOVWF  FF6
263A:  MOVLW  01
263C:  MOVWF  FF7
263E:  MOVLB  0
2640:  CALL   0928
....................    else 
2644:  BRA    2656
2646:  MOVLB  1
....................       fprintf(USER,"PASS"); 
2648:  MOVLW  98
264A:  MOVWF  FF6
264C:  MOVLW  01
264E:  MOVWF  FF7
2650:  MOVLB  0
2652:  CALL   0928
....................  
....................    write_ext_eeprom(5000,0x55); 
2656:  MOVLW  13
2658:  MOVLB  1
265A:  MOVWF  x37
265C:  MOVLW  88
265E:  MOVWF  x36
2660:  MOVLW  55
2662:  MOVWF  x38
2664:  MOVLB  0
2666:  CALL   093A
....................    write_ext_eeprom(5001,0x66); 
266A:  MOVLW  13
266C:  MOVLB  1
266E:  MOVWF  x37
2670:  MOVLW  89
2672:  MOVWF  x36
2674:  MOVLW  66
2676:  MOVWF  x38
2678:  MOVLB  0
267A:  CALL   093A
....................    write_ext_eeprom(5002,0x77); 
267E:  MOVLW  13
2680:  MOVLB  1
2682:  MOVWF  x37
2684:  MOVLW  8A
2686:  MOVWF  x36
2688:  MOVLW  77
268A:  MOVWF  x38
268C:  MOVLB  0
268E:  CALL   093A
....................    fprintf(USER,"\r\nAT25256 Test: "); 
2692:  MOVLW  9E
2694:  MOVWF  FF6
2696:  MOVLW  01
2698:  MOVWF  FF7
269A:  CALL   0928
....................    if (read_ext_eeprom(5001)==0x66) 
269E:  MOVLW  13
26A0:  MOVLB  1
26A2:  MOVWF  x37
26A4:  MOVLW  89
26A6:  MOVWF  x36
26A8:  MOVLB  0
26AA:  CALL   082E
26AE:  MOVF   01,W
26B0:  SUBLW  66
26B2:  BNZ   26C2
....................       fprintf(USER,"PASS"); 
26B4:  MOVLW  B0
26B6:  MOVWF  FF6
26B8:  MOVLW  01
26BA:  MOVWF  FF7
26BC:  CALL   0928
....................    else 
26C0:  BRA    26D2
....................    { 
....................       fprintf(USER,"FAIL !!!"); 
26C2:  MOVLW  B6
26C4:  MOVWF  FF6
26C6:  MOVLW  01
26C8:  MOVWF  FF7
26CA:  CALL   0928
....................       fail_ee=TRUE; 
26CE:  MOVLB  1
26D0:  BSF    x21.1
....................    } 
....................  
....................    if (fail_nic && fail_ee) 
26D2:  MOVLB  1
26D4:  BTFSS  x21.0
26D6:  BRA    26EC
26D8:  BTFSS  x21.1
26DA:  BRA    26EC
....................       fprintf(USER,"\r\nBoth ENC28J60 and AT25256 fail!!!"); 
26DC:  MOVLW  C0
26DE:  MOVWF  FF6
26E0:  MOVLW  01
26E2:  MOVWF  FF7
26E4:  MOVLB  0
26E6:  CALL   0928
26EA:  MOVLB  1
....................  
....................    fprintf(USER,"\r\n\nBlinking LEDs. Press A4 when LEDs are verified working.\r\n"); 
26EC:  MOVLW  E4
26EE:  MOVWF  FF6
26F0:  MOVLW  01
26F2:  MOVWF  FF7
26F4:  MOVLB  0
26F6:  CALL   0928
....................    output_high(USER_LED1); 
26FA:  BSF    F89.5
....................    output_high(USER_LED2); 
26FC:  BSF    F8A.4
....................    output_high(USER_LED3); 
26FE:  BSF    F8A.5
....................    while(input(PIN_A4)) 
....................    { 
2700:  BTFSS  F80.4
2702:  BRA    2718
....................       output_toggle(USER_LED1); 
2704:  BTG    F89.5
....................       output_toggle(USER_LED2); 
2706:  BTG    F8A.4
....................       output_toggle(USER_LED3); 
2708:  BTG    F8A.5
....................       delay_ms(250); 
270A:  MOVLW  FA
270C:  MOVLB  1
270E:  MOVWF  x24
2710:  MOVLB  0
2712:  CALL   0632
....................    } 
2716:  BRA    2700
....................  
....................    fprintf(USER, "\r\nTurn the POT completely to the right."); 
2718:  MOVLW  22
271A:  MOVWF  FF6
271C:  MOVLW  02
271E:  MOVWF  FF7
2720:  CALL   0928
....................    set_adc_channel(ADC_CHAN_0); 
2724:  MOVLW  00
2726:  MOVWF  01
2728:  MOVF   FC2,W
272A:  ANDLW  C7
272C:  IORWF  01,W
272E:  MOVWF  FC2
....................    delay_ms(1); 
2730:  MOVLW  01
2732:  MOVLB  1
2734:  MOVWF  x24
2736:  MOVLB  0
2738:  CALL   0632
....................    while (read_adc() < 0xF8) { } 
273C:  BSF    FC2.2
273E:  BTFSC  FC2.2
2740:  BRA    273E
2742:  MOVF   FC4,W
2744:  SUBLW  F7
2746:  BNC   274A
2748:  BRA    273C
....................    fprintf(USER, "\r\nTurn the POT completely to the left."); 
274A:  MOVLW  4A
274C:  MOVWF  FF6
274E:  MOVLW  02
2750:  MOVWF  FF7
2752:  CALL   0928
....................    while (read_adc() > 0x08) { } 
2756:  BSF    FC2.2
2758:  BTFSC  FC2.2
275A:  BRA    2758
275C:  MOVF   FC4,W
275E:  SUBLW  08
2760:  BC    2764
2762:  BRA    2756
....................    fprintf(USER, "\r\nPOT Test: PASS\r\n"); 
2764:  MOVLW  72
2766:  MOVWF  FF6
2768:  MOVLW  02
276A:  MOVWF  FF7
276C:  CALL   0928
....................  
....................    setup_adc_ports(NO_ANALOGS); 
2770:  BSF    FC1.0
2772:  BSF    FC1.1
2774:  BSF    FC1.2
2776:  BCF    FC1.3
....................    setup_spi(SPI_SS_DISABLED); 
2778:  BCF    FC6.5
277A:  MOVLW  01
277C:  MOVWF  FC6
277E:  MOVLW  00
2780:  MOVWF  FC7
....................  
....................    fprintf(USER, "\r\nInsert test header now.  Press T when ready."); 
2782:  MOVLW  86
2784:  MOVWF  FF6
2786:  MOVLW  02
2788:  MOVWF  FF7
278A:  CALL   0928
....................    while(toupper(fgetc(USER))!='T') { } 
278E:  BTFSS  F9E.5
2790:  BRA    278E
2792:  MOVF   FAE,W
2794:  MOVLB  1
2796:  MOVWF  x22
2798:  SUBLW  60
279A:  BC    27A8
279C:  MOVF   x22,W
279E:  SUBLW  7A
27A0:  BNC   27A8
27A2:  MOVF   x22,W
27A4:  ANDLW  DF
27A6:  BRA    27AA
27A8:  MOVF   x22,W
27AA:  SUBLW  54
27AC:  BZ    27B4
27AE:  MOVLB  0
27B0:  BRA    278E
27B2:  MOVLB  1
....................  
....................    fprintf(USER, "\r\nTesting I/O header: \r\n"); 
27B4:  MOVLW  B6
27B6:  MOVWF  FF6
27B8:  MOVLW  02
27BA:  MOVWF  FF7
27BC:  MOVLB  0
27BE:  CALL   0928
....................    fail_pins |= hardware_io_test_pin(PIN_B7, PIN_B6); 
27C2:  MOVLW  00
27C4:  MOVLB  1
27C6:  BTFSC  x21.2
27C8:  MOVLW  01
27CA:  MOVWF  x22
27CC:  MOVLW  7C
27CE:  MOVWF  x24
27D0:  MOVLW  0F
27D2:  MOVWF  x23
27D4:  MOVLW  7C
27D6:  MOVWF  x26
27D8:  MOVLW  0E
27DA:  MOVWF  x25
27DC:  MOVLB  0
27DE:  RCALL  22D0
27E0:  MOVLB  1
27E2:  MOVF   x22,W
27E4:  IORWF  01,W
27E6:  BCF    x21.2
27E8:  BTFSC  FE8.0
27EA:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_B5, PIN_B4); 
27EC:  MOVLW  00
27EE:  BTFSC  x21.2
27F0:  MOVLW  01
27F2:  MOVWF  x22
27F4:  MOVLW  7C
27F6:  MOVWF  x24
27F8:  MOVLW  0D
27FA:  MOVWF  x23
27FC:  MOVLW  7C
27FE:  MOVWF  x26
2800:  MOVLW  0C
2802:  MOVWF  x25
2804:  MOVLB  0
2806:  RCALL  22D0
2808:  MOVLB  1
280A:  MOVF   x22,W
280C:  IORWF  01,W
280E:  BCF    x21.2
2810:  BTFSC  FE8.0
2812:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_B3, PIN_B2); 
2814:  MOVLW  00
2816:  BTFSC  x21.2
2818:  MOVLW  01
281A:  MOVWF  x22
281C:  MOVLW  7C
281E:  MOVWF  x24
2820:  MOVLW  0B
2822:  MOVWF  x23
2824:  MOVLW  7C
2826:  MOVWF  x26
2828:  MOVLW  0A
282A:  MOVWF  x25
282C:  MOVLB  0
282E:  RCALL  22D0
2830:  MOVLB  1
2832:  MOVF   x22,W
2834:  IORWF  01,W
2836:  BCF    x21.2
2838:  BTFSC  FE8.0
283A:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_B1, PIN_B0); 
283C:  MOVLW  00
283E:  BTFSC  x21.2
2840:  MOVLW  01
2842:  MOVWF  x22
2844:  MOVLW  7C
2846:  MOVWF  x24
2848:  MOVLW  09
284A:  MOVWF  x23
284C:  MOVLW  7C
284E:  MOVWF  x26
2850:  MOVLW  08
2852:  MOVWF  x25
2854:  MOVLB  0
2856:  RCALL  22D0
2858:  MOVLB  1
285A:  MOVF   x22,W
285C:  IORWF  01,W
285E:  BCF    x21.2
2860:  BTFSC  FE8.0
2862:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_D7, PIN_D6); 
2864:  MOVLW  00
2866:  BTFSC  x21.2
2868:  MOVLW  01
286A:  MOVWF  x22
286C:  MOVLW  7C
286E:  MOVWF  x24
2870:  MOVLW  1F
2872:  MOVWF  x23
2874:  MOVLW  7C
2876:  MOVWF  x26
2878:  MOVLW  1E
287A:  MOVWF  x25
287C:  MOVLB  0
287E:  RCALL  22D0
2880:  MOVLB  1
2882:  MOVF   x22,W
2884:  IORWF  01,W
2886:  BCF    x21.2
2888:  BTFSC  FE8.0
288A:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_D5, PIN_D4); 
288C:  MOVLW  00
288E:  BTFSC  x21.2
2890:  MOVLW  01
2892:  MOVWF  x22
2894:  MOVLW  7C
2896:  MOVWF  x24
2898:  MOVLW  1D
289A:  MOVWF  x23
289C:  MOVLW  7C
289E:  MOVWF  x26
28A0:  MOVLW  1C
28A2:  MOVWF  x25
28A4:  MOVLB  0
28A6:  RCALL  22D0
28A8:  MOVLB  1
28AA:  MOVF   x22,W
28AC:  IORWF  01,W
28AE:  BCF    x21.2
28B0:  BTFSC  FE8.0
28B2:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_D3, PIN_D2); 
28B4:  MOVLW  00
28B6:  BTFSC  x21.2
28B8:  MOVLW  01
28BA:  MOVWF  x22
28BC:  MOVLW  7C
28BE:  MOVWF  x24
28C0:  MOVLW  1B
28C2:  MOVWF  x23
28C4:  MOVLW  7C
28C6:  MOVWF  x26
28C8:  MOVLW  1A
28CA:  MOVWF  x25
28CC:  MOVLB  0
28CE:  RCALL  22D0
28D0:  MOVLB  1
28D2:  MOVF   x22,W
28D4:  IORWF  01,W
28D6:  BCF    x21.2
28D8:  BTFSC  FE8.0
28DA:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_D1, PIN_D0); 
28DC:  MOVLW  00
28DE:  BTFSC  x21.2
28E0:  MOVLW  01
28E2:  MOVWF  x22
28E4:  MOVLW  7C
28E6:  MOVWF  x24
28E8:  MOVLW  19
28EA:  MOVWF  x23
28EC:  MOVLW  7C
28EE:  MOVWF  x26
28F0:  MOVLW  18
28F2:  MOVWF  x25
28F4:  MOVLB  0
28F6:  RCALL  22D0
28F8:  MOVLB  1
28FA:  MOVF   x22,W
28FC:  IORWF  01,W
28FE:  BCF    x21.2
2900:  BTFSC  FE8.0
2902:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_C5, PIN_C4); 
2904:  MOVLW  00
2906:  BTFSC  x21.2
2908:  MOVLW  01
290A:  MOVWF  x22
290C:  MOVLW  7C
290E:  MOVWF  x24
2910:  MOVLW  15
2912:  MOVWF  x23
2914:  MOVLW  7C
2916:  MOVWF  x26
2918:  MOVLW  14
291A:  MOVWF  x25
291C:  MOVLB  0
291E:  RCALL  22D0
2920:  MOVLB  1
2922:  MOVF   x22,W
2924:  IORWF  01,W
2926:  BCF    x21.2
2928:  BTFSC  FE8.0
292A:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_C3, PIN_C2); 
292C:  MOVLW  00
292E:  BTFSC  x21.2
2930:  MOVLW  01
2932:  MOVWF  x22
2934:  MOVLW  7C
2936:  MOVWF  x24
2938:  MOVLW  13
293A:  MOVWF  x23
293C:  MOVLW  7C
293E:  MOVWF  x26
2940:  MOVLW  12
2942:  MOVWF  x25
2944:  MOVLB  0
2946:  RCALL  22D0
2948:  MOVLB  1
294A:  MOVF   x22,W
294C:  IORWF  01,W
294E:  BCF    x21.2
2950:  BTFSC  FE8.0
2952:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_C1, PIN_C0); 
2954:  MOVLW  00
2956:  BTFSC  x21.2
2958:  MOVLW  01
295A:  MOVWF  x22
295C:  MOVLW  7C
295E:  MOVWF  x24
2960:  MOVLW  11
2962:  MOVWF  x23
2964:  MOVLW  7C
2966:  MOVWF  x26
2968:  MOVLW  10
296A:  MOVWF  x25
296C:  MOVLB  0
296E:  RCALL  22D0
2970:  MOVLB  1
2972:  MOVF   x22,W
2974:  IORWF  01,W
2976:  BCF    x21.2
2978:  BTFSC  FE8.0
297A:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_A5, PIN_A4); 
297C:  MOVLW  00
297E:  BTFSC  x21.2
2980:  MOVLW  01
2982:  MOVWF  x22
2984:  MOVLW  7C
2986:  MOVWF  x24
2988:  MOVLW  05
298A:  MOVWF  x23
298C:  MOVLW  7C
298E:  MOVWF  x26
2990:  MOVLW  04
2992:  MOVWF  x25
2994:  MOVLB  0
2996:  RCALL  22D0
2998:  MOVLB  1
299A:  MOVF   x22,W
299C:  IORWF  01,W
299E:  BCF    x21.2
29A0:  BTFSC  FE8.0
29A2:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_A3, PIN_A2); 
29A4:  MOVLW  00
29A6:  BTFSC  x21.2
29A8:  MOVLW  01
29AA:  MOVWF  x22
29AC:  MOVLW  7C
29AE:  MOVWF  x24
29B0:  MOVLW  03
29B2:  MOVWF  x23
29B4:  MOVLW  7C
29B6:  MOVWF  x26
29B8:  MOVLW  02
29BA:  MOVWF  x25
29BC:  MOVLB  0
29BE:  RCALL  22D0
29C0:  MOVLB  1
29C2:  MOVF   x22,W
29C4:  IORWF  01,W
29C6:  BCF    x21.2
29C8:  BTFSC  FE8.0
29CA:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_A1, PIN_E2); 
29CC:  MOVLW  00
29CE:  BTFSC  x21.2
29D0:  MOVLW  01
29D2:  MOVWF  x22
29D4:  MOVLW  7C
29D6:  MOVWF  x24
29D8:  MOVLW  01
29DA:  MOVWF  x23
29DC:  MOVLW  7C
29DE:  MOVWF  x26
29E0:  MOVLW  22
29E2:  MOVWF  x25
29E4:  MOVLB  0
29E6:  RCALL  22D0
29E8:  MOVLB  1
29EA:  MOVF   x22,W
29EC:  IORWF  01,W
29EE:  BCF    x21.2
29F0:  BTFSC  FE8.0
29F2:  BSF    x21.2
....................    fail_pins |= hardware_io_test_pin(PIN_E1, PIN_E0); 
29F4:  MOVLW  00
29F6:  BTFSC  x21.2
29F8:  MOVLW  01
29FA:  MOVWF  x22
29FC:  MOVLW  7C
29FE:  MOVWF  x24
2A00:  MOVLW  21
2A02:  MOVWF  x23
2A04:  MOVLW  7C
2A06:  MOVWF  x26
2A08:  MOVLW  20
2A0A:  MOVWF  x25
2A0C:  MOVLB  0
2A0E:  RCALL  22D0
2A10:  MOVLB  1
2A12:  MOVF   x22,W
2A14:  IORWF  01,W
2A16:  BCF    x21.2
2A18:  BTFSC  FE8.0
2A1A:  BSF    x21.2
....................    if (fail_pins) 
2A1C:  BTFSS  x21.2
2A1E:  BRA    2A32
....................       fprintf(USER, "\r\nI/O header FAIL !!!"); 
2A20:  MOVLW  D0
2A22:  MOVWF  FF6
2A24:  MOVLW  02
2A26:  MOVWF  FF7
2A28:  MOVLB  0
2A2A:  CALL   0928
....................    else 
2A2E:  BRA    2A40
2A30:  MOVLB  1
....................       fprintf(USER, "PASS"); 
2A32:  MOVLW  E6
2A34:  MOVWF  FF6
2A36:  MOVLW  02
2A38:  MOVWF  FF7
2A3A:  MOVLB  0
2A3C:  CALL   0928
....................  
....................    fprintf(USER, "\r\n\nRemove test header.  Press T when ready."); 
2A40:  MOVLW  EC
2A42:  MOVWF  FF6
2A44:  MOVLW  02
2A46:  MOVWF  FF7
2A48:  CALL   0928
....................    while(toupper(fgetc(USER))!='T') { } 
2A4C:  BTFSS  F9E.5
2A4E:  BRA    2A4C
2A50:  MOVF   FAE,W
2A52:  MOVLB  1
2A54:  MOVWF  x22
2A56:  SUBLW  60
2A58:  BC    2A66
2A5A:  MOVF   x22,W
2A5C:  SUBLW  7A
2A5E:  BNC   2A66
2A60:  MOVF   x22,W
2A62:  ANDLW  DF
2A64:  BRA    2A68
2A66:  MOVF   x22,W
2A68:  SUBLW  54
2A6A:  BZ    2A72
2A6C:  MOVLB  0
2A6E:  BRA    2A4C
2A70:  MOVLB  1
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
2A72:  MOVLW  18
2A74:  MOVWF  FF6
2A76:  MOVLW  03
2A78:  MOVWF  FF7
2A7A:  MOVLB  0
2A7C:  CALL   0928
....................    reset_cpu(); 
2A80:  RESET
.................... } 
2A82:  GOTO   2CEC (RETURN)
.................... #elif STACK_USE_CCS_PICNET 
.................... void hardware_test(void) 
.................... { 
....................    char modemStr[]="AT"; 
....................  
....................    fprintf(USER, "\r\n\n"); 
....................  
.................... #if STACK_USE_MAC 
....................    fprintf(USER, "\r\nNIC RTL8019AS (U603) TEST: "); 
....................    NICPut(CMDR, 0x61); // CMDR = ; Select Page 1 
....................    NICPut(PAR0, 0x15);  //PAR0 = 0x01 
....................    NICPut(PAR0+1, 0x26); 
....................    NICPut(PAR0+2, 0x37); 
....................    NICPut(PAR0+3, 0x48); 
....................    NICPut(PAR0+4, 0x59); 
....................    NICPut(PAR0+5, 0x6A); 
....................    if (NICGet(0x01+3) == 0x48) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nMODEM (U1 & U7) TEST: "); 
....................    if (modem_at_command(modemStr, 2000) == MODEM_OK) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
.................... #endif 
....................  
....................    fprintf(USER,"\r\n24LC256 (U103) TEST: "); 
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................       fprintf(USER,"FAIL"); 
....................  
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B0 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B0)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL BUTTON B1 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    while(input(PIN_B1)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       delay_ms(250); 
....................    } 
....................  
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
....................    reset_cpu(); 
.................... } 
.................... #elif STACK_USE_CCS_PICEEC   //PICEEC 
.................... void hardware_test(void) 
.................... { 
....................    int8 i; 
....................    int1 fail_ee=0; 
....................    int1 fail_pins=0; 
....................  
....................    write_ext_eeprom(5000,0x55); 
....................    write_ext_eeprom(5001,0x66); 
....................    write_ext_eeprom(5002,0x77); 
....................    fprintf(USER,"\r\n\n\nAT25256 (U7) TEST: "); 
....................    if (read_ext_eeprom(5001)==0x66) 
....................       fprintf(USER,"PASS"); 
....................    else 
....................    { 
....................       fprintf(USER,"FAIL"); 
....................       fail_ee=TRUE; 
....................    } 
....................  
....................    set_adc_channel(ADC_CHAN_0); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE LEFT."); 
....................    while(read_adc() > 0x08); 
....................    fprintf(USER, "\r\nTURN POT ALL THE WAY TO THE RIGHT."); 
....................    while(read_adc() < 0xF8); 
....................  
....................    fprintf(USER,"\r\nBLINKING LEDS UNTIL A4 IS PRESSED"); 
....................    output_high(USER_LED1); 
....................    output_high(USER_LED2); 
....................    output_high(USER_LED3); 
....................    while(input(PIN_A4)) 
....................    { 
....................       output_toggle(USER_LED1); 
....................       output_toggle(USER_LED2); 
....................       output_toggle(USER_LED3); 
....................       delay_ms(250); 
....................    } 
....................    while(!input(PIN_A4)); 
....................    delay_ms(250); 
....................  
....................    fprintf(USER, "\r\nTESTING I/O HEADER (J4):\r\n"); 
....................    fail_pins |= hardware_io_test_pin(PIN_D1, PIN_D0); 
....................    fail_pins |= hardware_io_test_pin(PIN_G4, PIN_D2); 
....................    fail_pins |= hardware_io_test_pin(PIN_E1, PIN_E0); 
....................    fail_pins |= hardware_io_test_pin(PIN_E3, PIN_E2); 
....................    fail_pins |= hardware_io_test_pin(PIN_E5, PIN_E4); 
....................    fail_pins |= hardware_io_test_pin(PIN_B1, PIN_B0); 
....................    fail_pins |= hardware_io_test_pin(PIN_B3, PIN_B2); 
....................    fail_pins |= hardware_io_test_pin(PIN_B5, PIN_B4); 
....................    fail_pins |= hardware_io_test_pin(PIN_A5, PIN_A4); 
....................    //fail_pins |= hardware_io_test_pin(PIN_A3, PIN_C0); 
....................    if (fail_pins) 
....................       fprintf(USER, "\r\nI/O HEADER (J4): FAIL!!!"); 
....................    else 
....................       fprintf(USER, "PASS"); 
....................  
....................    if (fail_ee || fail_pins) 
....................       fprintf(USER,"\r\n\n!!!! BOARD DOES NOT PASS !!!!"); 
....................    else 
....................       fprintf(USER,"\r\n\n++++ BOARD PASS ++++"); 
....................  
....................    fprintf(USER,"\r\n\nRESETTING BOARD\r\n\n"); 
....................    delay_ms(15); 
....................    reset_cpu(); 
.................... } 
.................... #else 
.................... void hardware_test(void) 
.................... { 
....................    fprintf(USER,"\r\n\nNO HARDWARE TEST!\r\n\nRESETTING BOARD\r\n\n"); 
....................    delay_ms(15); 
....................    reset_cpu(); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include "ccshelperui.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                       CCSHELPERUI.C                               //// 
.................... ////                                                                   //// 
.................... //// More Helper functions and definitions for using CCS's example     //// 
.................... //// programs   These routines are more focused on the user interface  //// 
.................... //// needed to get and save setting from the user.                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 20th, 2006 -                                             //// 
.................... ////    Added support for EX_ST_UDP.C example                          //// 
.................... ////    Added DNS                                                      //// 
.................... ////    SMTP Example uses DNS to resolve IP                            //// 
.................... ////                                                                   //// 
.................... ////    May 24, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if STACK_USE_SERIAL 
....................  
.................... void ui_disp_ip_user(IP_ADDR *ip) { 
....................    fprintf(USER,"%U.%U.%U.%U",ip->v[0],ip->v[1],ip->v[2],ip->v[3]); 
*
139C:  MOVLB  1
139E:  MOVFF  126,FE9
13A2:  MOVFF  127,FEA
13A6:  MOVFF  FEF,128
13AA:  MOVLW  01
13AC:  ADDWF  x26,W
13AE:  MOVWF  FE9
13B0:  MOVLW  00
13B2:  ADDWFC x27,W
13B4:  MOVWF  FEA
13B6:  MOVFF  FEF,129
13BA:  MOVLW  02
13BC:  ADDWF  x26,W
13BE:  MOVWF  FE9
13C0:  MOVLW  00
13C2:  ADDWFC x27,W
13C4:  MOVWF  FEA
13C6:  MOVFF  FEF,12A
13CA:  MOVLW  03
13CC:  ADDWF  x26,W
13CE:  MOVWF  FE9
13D0:  MOVLW  00
13D2:  ADDWFC x27,W
13D4:  MOVWF  FEA
13D6:  MOVFF  FEF,12B
13DA:  MOVFF  128,12C
13DE:  MOVLW  1B
13E0:  MOVWF  x2D
13E2:  MOVLB  0
13E4:  RCALL  131E
13E6:  MOVLW  2E
13E8:  BTFSS  F9E.4
13EA:  BRA    13E8
13EC:  MOVWF  FAD
13EE:  MOVFF  129,12C
13F2:  MOVLW  1B
13F4:  MOVLB  1
13F6:  MOVWF  x2D
13F8:  MOVLB  0
13FA:  RCALL  131E
13FC:  MOVLW  2E
13FE:  BTFSS  F9E.4
1400:  BRA    13FE
1402:  MOVWF  FAD
1404:  MOVFF  12A,12C
1408:  MOVLW  1B
140A:  MOVLB  1
140C:  MOVWF  x2D
140E:  MOVLB  0
1410:  RCALL  131E
1412:  MOVLW  2E
1414:  BTFSS  F9E.4
1416:  BRA    1414
1418:  MOVWF  FAD
141A:  MOVFF  12B,12C
141E:  MOVLW  1B
1420:  MOVLB  1
1422:  MOVWF  x2D
1424:  MOVLB  0
1426:  RCALL  131E
.................... } 
1428:  RETLW  00
....................  
.................... void ui_disp_mac_user(MAC_ADDR *mac) 
.................... { 
....................    fprintf(USER,"%X:%X:%X:%X:%X:%X", 
....................          mac->v[0], 
....................          mac->v[1], 
....................          mac->v[2], 
....................          mac->v[3], 
....................          mac->v[4], 
....................          mac->v[5] 
....................       ); 
.................... } 
....................  
.................... void ui_settings(void) { 
.................... #if STACK_USE_MAC 
....................    int1 disp=TRUE; 
*
1516:  MOVLB  1
1518:  BSF    x21.0
.................... #endif 
.................... #if STACK_USE_TELNET 
....................    int8 i; 
.................... #endif 
.................... #ifdef CCS_UDP_EXAMPLE 
....................    IP_ADDR scratchIP; 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    if (ppp_is_connected()) 
....................    { 
....................       fprintf(USER,"\r\n\nIP Address: "); ui_disp_ip_user(&AppConfig.MyIPAddr); 
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
....................      #endif 
....................       fprintf(USER,"\r\nBaud Rate: %LU",connected_baudrate); 
....................    } 
....................    else { 
....................       fprintf(USER,"\r\n\nNot connected to ISP"); 
....................    } 
....................    fprintf(USER,"\r\nISP Username: %s",ppp_username); 
....................    fprintf(USER,"\r\nISP Password: %s",ppp_password); 
....................    fprintf(USER,"\r\nISP Phonenumber: %s", ppp_phonenumber); 
.................... #elif STACK_USE_MAC 
....................    fprintf(USER,"\r\n\nMAC Address: %X:%X:%X:%X:%X:%X",AppConfig.MyMACAddr.v[0],AppConfig.MyMACAddr.v[1],AppConfig.MyMACAddr.v[2],AppConfig.MyMACAddr.v[3],AppConfig.MyMACAddr.v[4],AppConfig.MyMACAddr.v[5]); 
151A:  MOVLW  2E
151C:  MOVWF  FF6
151E:  MOVLW  03
1520:  MOVWF  FF7
1522:  MOVLW  10
1524:  MOVWF  x31
1526:  MOVLB  0
1528:  RCALL  1292
152A:  MOVFF  1A,131
152E:  MOVLW  37
1530:  MOVLB  1
1532:  MOVWF  x32
1534:  MOVLB  0
1536:  RCALL  12AC
1538:  MOVLW  3A
153A:  BTFSS  F9E.4
153C:  BRA    153A
153E:  MOVWF  FAD
1540:  MOVFF  1B,131
1544:  MOVLW  37
1546:  MOVLB  1
1548:  MOVWF  x32
154A:  MOVLB  0
154C:  RCALL  12AC
154E:  MOVLW  3A
1550:  BTFSS  F9E.4
1552:  BRA    1550
1554:  MOVWF  FAD
1556:  MOVFF  1C,131
155A:  MOVLW  37
155C:  MOVLB  1
155E:  MOVWF  x32
1560:  MOVLB  0
1562:  RCALL  12AC
1564:  MOVLW  3A
1566:  BTFSS  F9E.4
1568:  BRA    1566
156A:  MOVWF  FAD
156C:  MOVFF  1D,131
1570:  MOVLW  37
1572:  MOVLB  1
1574:  MOVWF  x32
1576:  MOVLB  0
1578:  RCALL  12AC
157A:  MOVLW  3A
157C:  BTFSS  F9E.4
157E:  BRA    157C
1580:  MOVWF  FAD
1582:  MOVFF  1E,131
1586:  MOVLW  37
1588:  MOVLB  1
158A:  MOVWF  x32
158C:  MOVLB  0
158E:  RCALL  12AC
1590:  MOVLW  3A
1592:  BTFSS  F9E.4
1594:  BRA    1592
1596:  MOVWF  FAD
1598:  MOVFF  1F,131
159C:  MOVLW  37
159E:  MOVLB  1
15A0:  MOVWF  x32
15A2:  MOVLB  0
15A4:  RCALL  12AC
....................   #if STACK_USE_DHCP 
....................    fprintf(USER,"\r\nDHCP Enabled: "); 
15A6:  MOVLW  50
15A8:  MOVWF  FF6
15AA:  MOVLW  03
15AC:  MOVWF  FF7
15AE:  CALL   0928
....................   #if STACK_USE_EEPROM 
....................    if (read_ext_eeprom(EE_NIC_DHCP)) 
15B2:  MOVLB  1
15B4:  CLRF   x37
15B6:  MOVLW  C0
15B8:  MOVWF  x36
15BA:  MOVLB  0
15BC:  CALL   082E
15C0:  MOVF   01,F
15C2:  BZ    1602
....................   #else 
....................    if (TRUE) 
....................   #endif 
....................    { 
....................       fprintf(USER,"TRUE"); 
15C4:  MOVLW  62
15C6:  MOVWF  FF6
15C8:  MOVLW  03
15CA:  MOVWF  FF7
15CC:  CALL   0928
....................       fprintf(USER,"\r\nDHCP Bound: "); 
15D0:  MOVLW  68
15D2:  MOVWF  FF6
15D4:  MOVLW  03
15D6:  MOVWF  FF7
15D8:  CALL   0928
....................       if (DHCPIsBound()) {fprintf(USER,"TRUE");} 
15DC:  BTFSS  x86.0
15DE:  BRA    15EE
15E0:  MOVLW  78
15E2:  MOVWF  FF6
15E4:  MOVLW  03
15E6:  MOVWF  FF7
15E8:  CALL   0928
....................       else {fprintf(USER,"FALSE"); disp=FALSE;} 
15EC:  BRA    1600
15EE:  MOVLW  7E
15F0:  MOVWF  FF6
15F2:  MOVLW  03
15F4:  MOVWF  FF7
15F6:  CALL   0928
15FA:  MOVLB  1
15FC:  BCF    x21.0
15FE:  MOVLB  0
....................    } 
....................    else { 
1600:  BRA    160E
....................       fprintf(USER,"FALSE"); 
1602:  MOVLW  84
1604:  MOVWF  FF6
1606:  MOVLW  03
1608:  MOVWF  FF7
160A:  CALL   0928
....................    } 
....................   #else 
....................    disp=TRUE; 
....................   #endif 
....................    if (disp) { 
160E:  MOVLB  1
1610:  BTFSS  x21.0
1612:  BRA    1660
....................       fprintf(USER,"\r\nIP Address: ");  ui_disp_ip_user(&AppConfig.MyIPAddr); 
1614:  MOVLW  8A
1616:  MOVWF  FF6
1618:  MOVLW  03
161A:  MOVWF  FF7
161C:  MOVLB  0
161E:  CALL   0928
1622:  MOVLB  1
1624:  CLRF   x27
1626:  MOVLW  16
1628:  MOVWF  x26
162A:  MOVLB  0
162C:  RCALL  139C
....................       fprintf(USER,"\r\nGateway: ");  ui_disp_ip_user(&AppConfig.MyGateway); 
162E:  MOVLW  9A
1630:  MOVWF  FF6
1632:  MOVLW  03
1634:  MOVWF  FF7
1636:  CALL   0928
163A:  MOVLB  1
163C:  CLRF   x27
163E:  MOVLW  24
1640:  MOVWF  x26
1642:  MOVLB  0
1644:  RCALL  139C
....................       fprintf(USER,"\r\nNetmask: "); ui_disp_ip_user(&AppConfig.MyMask); 
1646:  MOVLW  A6
1648:  MOVWF  FF6
164A:  MOVLW  03
164C:  MOVWF  FF7
164E:  CALL   0928
1652:  MOVLB  1
1654:  CLRF   x27
1656:  MOVLW  20
1658:  MOVWF  x26
165A:  MOVLB  0
165C:  RCALL  139C
165E:  MOVLB  1
....................      #if STACK_USE_DNS 
....................       fprintf(USER,"\r\nDNS: "); ui_disp_ip_user(&AppConfig.PrimaryDNSServer); 
....................      #endif 
....................    } 
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
....................   fprintf(USER,"\r\nSMTP Server Hostname: %s", SMTP_HOST_NAME); 
....................   fprintf(USER,"\r\nSMTP Server Port: %LU",SMTP_PORT); 
....................   fprintf(USER,"\r\nE-Mail To: %s", SMTP_TO_ADDR); 
....................   fprintf(USER,"\r\nE-Mail From: %s", SMTP_FROM_ADDR); 
....................   fprintf(USER,"\r\nE-Mail Subject: %s", SMTP_SUBJECT); 
....................   fprintf(USER,"\r\nE-Mail Body: %s", SMTP_BODY); 
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
....................    read_ext_eeprom_ip(EE_UDP_DEST_IP, &scratchIP); 
1660:  MOVLW  02
1662:  MOVWF  x2D
1664:  MOVLW  19
1666:  MOVWF  x2C
1668:  MOVLW  01
166A:  MOVWF  x2F
166C:  MOVLW  22
166E:  MOVWF  x2E
1670:  MOVLB  0
1672:  CALL   0B28
....................    fprintf(USER,"\r\nUDP Destination IP: ");  ui_disp_ip_user(&scratchIP); 
1676:  MOVLW  B2
1678:  MOVWF  FF6
167A:  MOVLW  03
167C:  MOVWF  FF7
167E:  CALL   0928
1682:  MOVLW  01
1684:  MOVLB  1
1686:  MOVWF  x27
1688:  MOVLW  22
168A:  MOVWF  x26
168C:  MOVLB  0
168E:  RCALL  139C
....................    fprintf(USER,"\r\nUDP Destination Port: %LU", read_ext_eeprom16(EE_UDP_DEST_PORT)); 
1690:  MOVLW  02
1692:  MOVLB  1
1694:  MOVWF  x27
1696:  MOVLW  1D
1698:  MOVWF  x26
169A:  MOVLB  0
169C:  RCALL  142A
169E:  MOVFF  02,127
16A2:  MOVFF  01,126
16A6:  MOVLW  CA
16A8:  MOVWF  FF6
16AA:  MOVLW  03
16AC:  MOVWF  FF7
16AE:  MOVLW  18
16B0:  MOVLB  1
16B2:  MOVWF  x31
16B4:  MOVLB  0
16B6:  RCALL  1292
16B8:  MOVLW  10
16BA:  MOVWF  FE9
16BC:  MOVFF  127,129
16C0:  MOVFF  126,128
16C4:  RCALL  146C
....................    fprintf(USER,"\r\nUDP Source Port: %LU", read_ext_eeprom16(EE_UDP_SRC_PORT)); 
16C6:  MOVLW  02
16C8:  MOVLB  1
16CA:  MOVWF  x27
16CC:  MOVLW  1F
16CE:  MOVWF  x26
16D0:  MOVLB  0
16D2:  RCALL  142A
16D4:  MOVFF  02,127
16D8:  MOVFF  01,126
16DC:  MOVLW  E6
16DE:  MOVWF  FF6
16E0:  MOVLW  03
16E2:  MOVWF  FF7
16E4:  MOVLW  13
16E6:  MOVLB  1
16E8:  MOVWF  x31
16EA:  MOVLB  0
16EC:  RCALL  1292
16EE:  MOVLW  10
16F0:  MOVWF  FE9
16F2:  MOVFF  127,129
16F6:  MOVFF  126,128
16FA:  RCALL  146C
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    for (i=0;i<TELNET_MAX_CONNECTIONS;i++) { 
....................       fprintf(USER,"\r\nTelnet %U: ",i); 
....................       if (TelnetIsOpen(i)) { 
....................          fprintf(USER,"OPEN ST=%X S=%U IP=",TCB[telnet_active_socket[i]].smState,telnet_active_socket[i]); 
....................          ui_disp_ip_user(&TCB[telnet_active_socket[i]].remote.IPAddr); 
....................          fprintf(USER," RP=%LU",TCB[telnet_active_socket[i]].remotePort); 
....................       } 
....................       else { 
....................          fprintf(USER,"LISTENING ST=%X",TCB[telnet_active_socket[i]].smState); 
....................       } 
....................    } 
.................... #endif 
.................... } 
16FC:  RETLW  00
....................  
.................... void fget_string(char* s, int max) { 
....................    int len=0; 
*
1ABA:  MOVLB  1
1ABC:  CLRF   x38
....................    char c; 
....................  
....................    --max; 
1ABE:  DECF   x37,F
....................  
....................    while ((c=*s)!=0) 
....................    { 
1AC0:  MOVFF  136,03
1AC4:  MOVFF  135,FE9
1AC8:  MOVFF  136,FEA
1ACC:  MOVFF  FEF,139
1AD0:  MOVF   x39,F
1AD2:  BZ    1AE6
....................       fputc(c, USER); 
1AD4:  MOVF   x39,W
1AD6:  MOVLB  0
1AD8:  RCALL  1AB2
....................       len++; 
1ADA:  MOVLB  1
1ADC:  INCF   x38,F
....................       s++; 
1ADE:  INCF   x35,F
1AE0:  BTFSC  FD8.2
1AE2:  INCF   x36,F
....................    } 
1AE4:  BRA    1AC0
....................  
....................    do { 
....................      c=fgetc(USER); 
1AE6:  BTFSS  F9E.5
1AE8:  BRA    1AE6
1AEA:  MOVFF  FAE,139
....................      if(c==8) {  // Backspace 
1AEE:  MOVF   x39,W
1AF0:  SUBLW  08
1AF2:  BNZ   1B18
....................         if(len>0) { 
1AF4:  MOVF   x38,F
1AF6:  BZ    1B16
....................           len--; 
1AF8:  DECF   x38,F
....................           s--; 
1AFA:  MOVF   x35,W
1AFC:  BTFSC  FD8.2
1AFE:  DECF   x36,F
1B00:  DECF   x35,F
....................           fputc(c,USER); 
1B02:  MOVF   x39,W
1B04:  MOVLB  0
1B06:  RCALL  1AB2
....................           fputc(' ',USER); 
1B08:  MOVLW  20
1B0A:  RCALL  1AB2
....................           fputc(c,USER); 
1B0C:  MOVLB  1
1B0E:  MOVF   x39,W
1B10:  MOVLB  0
1B12:  RCALL  1AB2
1B14:  MOVLB  1
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
1B16:  BRA    1B4A
1B18:  MOVF   x39,W
1B1A:  SUBLW  1F
1B1C:  BC    1B4A
1B1E:  MOVF   x39,W
1B20:  SUBLW  7E
1B22:  BNC   1B4A
....................        if(len<max) { 
1B24:  MOVF   x37,W
1B26:  SUBWF  x38,W
1B28:  BC    1B4A
....................          *s++ = c; 
1B2A:  MOVFF  136,03
1B2E:  MOVF   x35,W
1B30:  INCF   x35,F
1B32:  BTFSC  FD8.2
1B34:  INCF   x36,F
1B36:  MOVWF  FE9
1B38:  MOVFF  03,FEA
1B3C:  MOVFF  139,FEF
....................          len++; 
1B40:  INCF   x38,F
....................          fputc(c,USER); 
1B42:  MOVF   x39,W
1B44:  MOVLB  0
1B46:  RCALL  1AB2
1B48:  MOVLB  1
....................        } 
....................    } while(c!=13); 
1B4A:  MOVF   x39,W
1B4C:  SUBLW  0D
1B4E:  BNZ   1AE6
....................    *s = 0; 
1B50:  MOVFF  135,FE9
1B54:  MOVFF  136,FEA
1B58:  CLRF   FEF
.................... } 
1B5A:  MOVLB  0
1B5C:  RETLW  00
....................  
.................... int fget_int(int8 initial) { 
....................   char s[4]; 
....................   signed int i; 
....................  
....................   sprintf(s, "%U", initial); 
*
1DA4:  MOVLW  01
1DA6:  MOVWF  xFF
1DA8:  MOVLW  30
1DAA:  MOVWF  xFE
1DAC:  MOVFF  12F,135
1DB0:  MOVLW  1B
1DB2:  MOVLB  1
1DB4:  MOVWF  x36
1DB6:  MOVLB  0
1DB8:  BRA    1A34
....................  
....................   fget_string(s, 4); 
1DBA:  MOVLW  01
1DBC:  MOVLB  1
1DBE:  MOVWF  x36
1DC0:  MOVLW  30
1DC2:  MOVWF  x35
1DC4:  MOVLW  04
1DC6:  MOVWF  x37
1DC8:  MOVLB  0
1DCA:  RCALL  1ABA
....................  
....................   i=atol(s); 
1DCC:  MOVLW  01
1DCE:  MOVLB  1
1DD0:  MOVWF  x36
1DD2:  MOVLW  30
1DD4:  MOVWF  x35
1DD6:  MOVLB  0
1DD8:  RCALL  1BB4
1DDA:  MOVFF  01,134
....................   return(i); 
1DDE:  MOVLB  1
1DE0:  MOVFF  134,01
.................... } 
1DE4:  MOVLB  0
1DE6:  GOTO   1F16 (RETURN)
....................  
.................... int16 fget_long(int16 initial) { 
....................    char s[6]; 
....................    int16 i; 
....................  
....................    sprintf(s, "%LU", initial); 
*
200C:  MOVLW  01
200E:  MOVWF  xFF
2010:  MOVLW  27
2012:  MOVWF  xFE
2014:  MOVLW  10
2016:  MOVWF  FE9
2018:  MOVFF  126,130
201C:  MOVFF  125,12F
2020:  BRA    1F4E
....................  
....................    fget_string(s, 6); 
2022:  MOVLW  01
2024:  MOVLB  1
2026:  MOVWF  x36
2028:  MOVLW  27
202A:  MOVWF  x35
202C:  MOVLW  06
202E:  MOVWF  x37
2030:  MOVLB  0
2032:  RCALL  1ABA
....................  
....................    i=atol(s); 
2034:  MOVLW  01
2036:  MOVLB  1
2038:  MOVWF  x36
203A:  MOVLW  27
203C:  MOVWF  x35
203E:  MOVLB  0
2040:  RCALL  1BB4
2042:  MOVFF  02,12E
2046:  MOVFF  01,12D
....................    return(i); 
204A:  MOVLB  1
204C:  MOVFF  12D,01
2050:  MOVFF  12E,02
.................... } 
2054:  MOVLB  0
2056:  RETLW  00
....................  
.................... BYTE fgethex(int initial) { 
....................    char hex[5]; 
....................    int8 ret; 
....................  
....................    hex[0]='0'; 
*
2AD2:  MOVLW  30
2AD4:  MOVLB  1
2AD6:  MOVWF  x27
....................    hex[1]='x'; 
2AD8:  MOVLW  78
2ADA:  MOVWF  x28
....................  
....................    sprintf(&hex[2], "%X", initial); 
2ADC:  MOVLW  01
2ADE:  MOVLB  0
2AE0:  MOVWF  xFF
2AE2:  MOVLW  29
2AE4:  MOVWF  xFE
2AE6:  MOVFF  126,12D
2AEA:  MOVLW  37
2AEC:  MOVLB  1
2AEE:  MOVWF  x2E
2AF0:  MOVLB  0
2AF2:  BRA    2A86
....................  
....................    fget_string(&hex[2],3); 
2AF4:  MOVLW  01
2AF6:  MOVLB  1
2AF8:  MOVWF  x36
2AFA:  MOVLW  29
2AFC:  MOVWF  x35
2AFE:  MOVLW  03
2B00:  MOVWF  x37
2B02:  MOVLB  0
2B04:  CALL   1ABA
....................    ret=atol(hex); 
2B08:  MOVLW  01
2B0A:  MOVLB  1
2B0C:  MOVWF  x36
2B0E:  MOVLW  27
2B10:  MOVWF  x35
2B12:  MOVLB  0
2B14:  CALL   1BB4
2B18:  MOVFF  01,12C
....................    return(ret); 
2B1C:  MOVLB  1
2B1E:  MOVFF  12C,01
.................... } 
2B22:  MOVLB  0
2B24:  GOTO   2B8C (RETURN)
....................  
.................... void ui_ip_to_ee(int16 address) { 
....................    IP_ADDR ip; 
....................    int i; 
....................  #if STACK_USE_EEPROM 
....................    read_ext_eeprom_ip(address, &ip); 
*
1E92:  MOVFF  126,12D
1E96:  MOVFF  125,12C
1E9A:  MOVLW  01
1E9C:  MOVLB  1
1E9E:  MOVWF  x2F
1EA0:  MOVLW  27
1EA2:  MOVWF  x2E
1EA4:  MOVLB  0
1EA6:  CALL   0B28
....................  #endif 
....................    for (i=0;i<4;i++) { 
1EAA:  MOVLB  1
1EAC:  CLRF   x2B
1EAE:  MOVF   x2B,W
1EB0:  SUBLW  03
1EB2:  BNC   1F38
....................       fprintf(USER, "  BYTE%U: ",i); 
1EB4:  MOVLW  FE
1EB6:  MOVWF  FF6
1EB8:  MOVLW  03
1EBA:  MOVWF  FF7
1EBC:  MOVLW  06
1EBE:  MOVWF  x31
1EC0:  MOVLB  0
1EC2:  CALL   1292
1EC6:  MOVFF  12B,12C
1ECA:  MOVLW  1B
1ECC:  MOVLB  1
1ECE:  MOVWF  x2D
1ED0:  MOVLB  0
1ED2:  CALL   131E
1ED6:  MOVLW  3A
1ED8:  BTFSS  F9E.4
1EDA:  BRA    1ED8
1EDC:  MOVWF  FAD
1EDE:  MOVLW  20
1EE0:  BTFSS  F9E.4
1EE2:  BRA    1EE0
1EE4:  MOVWF  FAD
....................       ip.v[i]=fget_int(ip.v[i]); 
1EE6:  CLRF   03
1EE8:  MOVLB  1
1EEA:  MOVF   x2B,W
1EEC:  ADDLW  27
1EEE:  MOVWF  01
1EF0:  MOVLW  01
1EF2:  ADDWFC 03,F
1EF4:  MOVFF  01,12C
1EF8:  MOVFF  03,12D
1EFC:  CLRF   03
1EFE:  MOVF   x2B,W
1F00:  ADDLW  27
1F02:  MOVWF  FE9
1F04:  MOVLW  01
1F06:  ADDWFC 03,W
1F08:  MOVWF  FEA
1F0A:  MOVFF  FEF,12E
1F0E:  MOVFF  12E,12F
1F12:  MOVLB  0
1F14:  BRA    1DA4
1F16:  MOVFF  12D,FEA
1F1A:  MOVFF  12C,FE9
1F1E:  MOVFF  01,FEF
....................       fprintf(USER,"\r\n"); 
1F22:  MOVLW  0D
1F24:  BTFSS  F9E.4
1F26:  BRA    1F24
1F28:  MOVWF  FAD
1F2A:  MOVLW  0A
1F2C:  BTFSS  F9E.4
1F2E:  BRA    1F2C
1F30:  MOVWF  FAD
....................    } 
....................  #if STACK_USE_EEPROM 
1F32:  MOVLB  1
1F34:  INCF   x2B,F
1F36:  BRA    1EAE
....................    write_ext_eeprom_ip(address, &ip); 
1F38:  MOVFF  126,12D
1F3C:  MOVFF  125,12C
1F40:  MOVLW  01
1F42:  MOVWF  x2F
1F44:  MOVLW  27
1F46:  MOVWF  x2E
1F48:  MOVLB  0
1F4A:  BRA    1DEA
....................  #endif 
.................... } 
1F4C:  RETLW  00
....................  
.................... #if STACK_USE_PPP 
.................... void ui_setup(void) { 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nISP USERNAME: "); 
....................    read_ext_eeprom_string(EE_ISP_USERNAME, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_USERNAME, str); 
....................  
....................    fprintf(USER,"\r\nISP PASSWORD: "); 
....................    read_ext_eeprom_string(EE_ISP_PASSWORD, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PASSWORD,str); 
....................  
....................    fprintf(USER,"\r\nISP PHONENUMBER: "); 
....................    read_ext_eeprom_string(EE_ISP_PHONENUMBER, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_ISP_PHONENUMBER,str); 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
....................  
....................    reset_cpu(); 
.................... } 
.................... #elif STACK_USE_MAC 
.................... void ui_setup(void) { 
....................    char dhcp; 
....................    int8 i; 
....................    int16 addy; 
....................  
....................  #if STACK_USE_EEPROM 
....................  
....................    fprintf(USER,"\r\n\nMAC ADDRESS:"); 
*
2B28:  MOVLW  0A
2B2A:  MOVWF  FF6
2B2C:  MOVLW  04
2B2E:  MOVWF  FF7
2B30:  CALL   0928
....................    addy=EE_NIC_MAC; 
2B34:  MOVLB  1
2B36:  CLRF   x24
2B38:  MOVLW  CD
2B3A:  MOVWF  x23
....................    for(i=0;i<6;i++) { 
2B3C:  CLRF   x22
2B3E:  MOVF   x22,W
2B40:  SUBLW  05
2B42:  BNC   2BBA
....................      fprintf(USER, "\r\n  BYTE%U: ",i); 
2B44:  MOVLW  1A
2B46:  MOVWF  FF6
2B48:  MOVLW  04
2B4A:  MOVWF  FF7
2B4C:  MOVLW  08
2B4E:  MOVWF  x31
2B50:  MOVLB  0
2B52:  CALL   1292
2B56:  MOVFF  122,12C
2B5A:  MOVLW  1B
2B5C:  MOVLB  1
2B5E:  MOVWF  x2D
2B60:  MOVLB  0
2B62:  CALL   131E
2B66:  MOVLW  3A
2B68:  BTFSS  F9E.4
2B6A:  BRA    2B68
2B6C:  MOVWF  FAD
2B6E:  MOVLW  20
2B70:  BTFSS  F9E.4
2B72:  BRA    2B70
2B74:  MOVWF  FAD
....................      dhcp=fgethex(read_ext_eeprom(addy)); 
2B76:  MOVFF  124,137
2B7A:  MOVFF  123,136
2B7E:  CALL   082E
2B82:  MOVFF  01,125
2B86:  MOVFF  01,126
2B8A:  BRA    2AD2
2B8C:  MOVFF  01,121
....................      write_ext_eeprom(addy++,dhcp); 
2B90:  MOVLB  1
2B92:  MOVFF  124,03
2B96:  MOVF   x23,W
2B98:  INCF   x23,F
2B9A:  BTFSC  FD8.2
2B9C:  INCF   x24,F
2B9E:  MOVWF  x25
2BA0:  MOVFF  03,126
2BA4:  MOVFF  03,137
2BA8:  MOVWF  x36
2BAA:  MOVFF  121,138
2BAE:  MOVLB  0
2BB0:  CALL   093A
....................    } 
2BB4:  MOVLB  1
2BB6:  INCF   x22,F
2BB8:  BRA    2B3E
....................  
....................  
....................    fprintf(USER,"\r\n\nUSE DHCP? (Y/N): "); 
2BBA:  MOVLW  28
2BBC:  MOVWF  FF6
2BBE:  MOVLW  04
2BC0:  MOVWF  FF7
2BC2:  MOVLB  0
2BC4:  CALL   0928
....................    do { 
....................       dhcp=fgetc(USER); 
2BC8:  BTFSS  F9E.5
2BCA:  BRA    2BC8
2BCC:  MOVFF  FAE,121
2BD0:  MOVLB  1
....................       dhcp=toupper(dhcp); 
2BD2:  MOVF   x21,W
2BD4:  SUBLW  60
2BD6:  BC    2BE4
2BD8:  MOVF   x21,W
2BDA:  SUBLW  7A
2BDC:  BNC   2BE4
2BDE:  MOVF   x21,W
2BE0:  ANDLW  DF
2BE2:  BRA    2BE6
2BE4:  MOVF   x21,W
2BE6:  MOVWF  x21
....................    } while ((dhcp!='Y')&&(dhcp!='N')); 
2BE8:  MOVF   x21,W
2BEA:  SUBLW  59
2BEC:  BZ    2BFA
2BEE:  MOVF   x21,W
2BF0:  SUBLW  4E
2BF2:  BTFSC  FD8.2
2BF4:  BRA    2BFA
2BF6:  MOVLB  0
2BF8:  BRA    2BC8
....................    fputc(dhcp,USER); 
2BFA:  MOVF   x21,W
2BFC:  MOVLB  0
2BFE:  CALL   1AB2
....................  
....................    if (dhcp=='N') { 
2C02:  MOVLB  1
2C04:  MOVF   x21,W
2C06:  SUBLW  4E
2C08:  BNZ   2C6A
....................       write_ext_eeprom(EE_NIC_DHCP,0); 
2C0A:  CLRF   x37
2C0C:  MOVLW  C0
2C0E:  MOVWF  x36
2C10:  CLRF   x38
2C12:  MOVLB  0
2C14:  CALL   093A
....................  
....................       fprintf(USER,"\r\n\nIP ADDRESS:\r\n"); 
2C18:  MOVLW  3E
2C1A:  MOVWF  FF6
2C1C:  MOVLW  04
2C1E:  MOVWF  FF7
2C20:  CALL   0928
....................       ui_ip_to_ee(EE_NIC_IP); 
2C24:  MOVLB  1
2C26:  CLRF   x26
2C28:  MOVLW  C5
2C2A:  MOVWF  x25
2C2C:  MOVLB  0
2C2E:  CALL   1E92
....................  
....................       fprintf(USER,"\r\nGATEWAY:\r\n"); 
2C32:  MOVLW  50
2C34:  MOVWF  FF6
2C36:  MOVLW  04
2C38:  MOVWF  FF7
2C3A:  CALL   0928
....................       ui_ip_to_ee(EE_NIC_GATEWAY); 
2C3E:  MOVLB  1
2C40:  CLRF   x26
2C42:  MOVLW  C1
2C44:  MOVWF  x25
2C46:  MOVLB  0
2C48:  CALL   1E92
....................  
....................       fprintf(USER,"\r\nNETMASK:\r\n"); 
2C4C:  MOVLW  5E
2C4E:  MOVWF  FF6
2C50:  MOVLW  04
2C52:  MOVWF  FF7
2C54:  CALL   0928
....................       ui_ip_to_ee(EE_NIC_NETMASK); 
2C58:  MOVLB  1
2C5A:  CLRF   x26
2C5C:  MOVLW  C9
2C5E:  MOVWF  x25
2C60:  MOVLB  0
2C62:  CALL   1E92
....................  
....................      #if STACK_USE_DNS 
....................       fprintf(USER, "\r\nDNS:\r\n"); 
....................       ui_ip_to_ee(EE_DNS); 
....................      #endif 
....................    } 
....................    else { 
2C66:  BRA    2C7A
2C68:  MOVLB  1
....................       write_ext_eeprom(EE_NIC_DHCP,1); 
2C6A:  CLRF   x37
2C6C:  MOVLW  C0
2C6E:  MOVWF  x36
2C70:  MOVLW  01
2C72:  MOVWF  x38
2C74:  MOVLB  0
2C76:  CALL   093A
....................    } 
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
2C7A:  MOVLW  6C
2C7C:  MOVWF  FF6
2C7E:  MOVLW  04
2C80:  MOVWF  FF7
2C82:  CALL   0928
....................  
....................    reset_cpu(); 
2C86:  RESET
.................... #endif 
.................... } 
2C88:  GOTO   2CEC (RETURN)
.................... #endif 
....................  
.................... #ifdef CCS_EMAIL_EXAMPLE 
.................... void ui_mail_settings(void) { 
....................    int16 port; 
....................    char str[64]; 
....................  
....................    fprintf(USER,"\r\n\nSMTP HOST NAME: "); 
....................    read_ext_eeprom_string(EE_SMTP_HOSTNAME, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_HOSTNAME, str); 
....................  
....................    fprintf(USER,"\r\nSMTP PORT (USUALLY 25): "); 
....................    port=fget_long(read_ext_eeprom16(EE_SMTP_PORT)); 
....................    write_ext_eeprom16(EE_SMTP_PORT, port); 
....................    fprintf(USER,"\r\n"); 
....................  
....................    fprintf(USER,"\r\nTo: "); 
....................    read_ext_eeprom_string(EE_SMTP_TO, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_TO,str); 
....................  
....................    fprintf(USER,"\r\nFrom: "); 
....................    read_ext_eeprom_string(EE_SMTP_FROM, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_FROM,str); 
....................  
....................    fprintf(USER,"\r\nSubject: "); 
....................    read_ext_eeprom_string(EE_SMTP_SUBJECT, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_SUBJECT,str); 
....................  
....................    fprintf(USER,"\r\nBody: "); 
....................    read_ext_eeprom_string(EE_SMTP_BODY, str, sizeof(str)-1); 
....................    fget_string(str,64); 
....................    write_ext_eeprom_string(EE_SMTP_BODY,str); 
....................  
....................    init_smtp_settings(); 
.................... } 
.................... #endif 
....................  
.................... #ifdef CCS_UDP_EXAMPLE 
.................... void ui_udp_settings(void) 
.................... { 
....................    int16 port; 
....................  
....................    fprintf(USER,"\r\n\nUDP Destination IP:\r\n"); 
*
2058:  MOVLW  8E
205A:  MOVWF  FF6
205C:  MOVLW  04
205E:  MOVWF  FF7
2060:  CALL   0928
....................    ui_ip_to_ee(EE_UDP_DEST_IP); 
2064:  MOVLW  02
2066:  MOVLB  1
2068:  MOVWF  x26
206A:  MOVLW  19
206C:  MOVWF  x25
206E:  MOVLB  0
2070:  RCALL  1E92
....................  
....................    fprintf(USER,"\r\nUDP Destination Port (I will transmit to this port): "); 
2072:  MOVLW  A8
2074:  MOVWF  FF6
2076:  MOVLW  04
2078:  MOVWF  FF7
207A:  CALL   0928
....................    port=fget_long(read_ext_eeprom16(EE_UDP_DEST_PORT)); 
207E:  MOVLW  02
2080:  MOVLB  1
2082:  MOVWF  x27
2084:  MOVLW  1D
2086:  MOVWF  x26
2088:  MOVLB  0
208A:  CALL   142A
208E:  MOVFF  02,124
2092:  MOVFF  01,123
2096:  MOVFF  02,126
209A:  MOVFF  01,125
209E:  RCALL  200C
20A0:  MOVFF  02,122
20A4:  MOVFF  01,121
....................    write_ext_eeprom16(EE_UDP_DEST_PORT, port); 
20A8:  MOVLW  02
20AA:  MOVLB  1
20AC:  MOVWF  x24
20AE:  MOVLW  1D
20B0:  MOVWF  x23
20B2:  MOVFF  122,126
20B6:  MOVFF  121,125
20BA:  MOVLB  0
20BC:  CALL   09AA
....................    fprintf(USER,"\r\n"); 
20C0:  MOVLW  0D
20C2:  BTFSS  F9E.4
20C4:  BRA    20C2
20C6:  MOVWF  FAD
20C8:  MOVLW  0A
20CA:  BTFSS  F9E.4
20CC:  BRA    20CA
20CE:  MOVWF  FAD
....................  
....................    fprintf(USER,"\r\nUDP Source Port (I will listen to this port): "); 
20D0:  MOVLW  E0
20D2:  MOVWF  FF6
20D4:  MOVLW  04
20D6:  MOVWF  FF7
20D8:  CALL   0928
....................    port=fget_long(read_ext_eeprom16(EE_UDP_SRC_PORT)); 
20DC:  MOVLW  02
20DE:  MOVLB  1
20E0:  MOVWF  x27
20E2:  MOVLW  1F
20E4:  MOVWF  x26
20E6:  MOVLB  0
20E8:  CALL   142A
20EC:  MOVFF  02,124
20F0:  MOVFF  01,123
20F4:  MOVFF  02,126
20F8:  MOVFF  01,125
20FC:  RCALL  200C
20FE:  MOVFF  02,122
2102:  MOVFF  01,121
....................    write_ext_eeprom16(EE_UDP_SRC_PORT, port); 
2106:  MOVLW  02
2108:  MOVLB  1
210A:  MOVWF  x24
210C:  MOVLW  1F
210E:  MOVWF  x23
2110:  MOVFF  122,126
2114:  MOVFF  121,125
2118:  MOVLB  0
211A:  CALL   09AA
....................    fprintf(USER,"\r\n"); 
211E:  MOVLW  0D
2120:  BTFSS  F9E.4
2122:  BRA    2120
2124:  MOVWF  FAD
2126:  MOVLW  0A
2128:  BTFSS  F9E.4
212A:  BRA    2128
212C:  MOVWF  FAD
....................  
....................    fprintf(USER,"\r\n\nSaved to EEPROM.  Resetting..."); 
212E:  MOVLW  12
2130:  MOVWF  FF6
2132:  MOVLW  05
2134:  MOVWF  FF7
2136:  CALL   0928
....................  
....................    reset_cpu(); 
213A:  RESET
.................... } 
213C:  GOTO   2CEC (RETURN)
.................... #endif 
....................  
.................... void ui_menu(void) { 
....................    fprintf(USER,"\r\n\nD) Display Settings"); 
*
16FE:  MOVLW  34
1700:  MOVWF  FF6
1702:  MOVLW  05
1704:  MOVWF  FF7
1706:  CALL   0928
....................    #if STACK_USE_PPP 
....................    fprintf(USER,"\r\nC) Connect Modem / PPP"); 
....................    fprintf(USER,"\r\nH) Hangup Modem / PPP"); 
....................    fprintf(USER,"\r\nA) AT Command Mode"); 
....................    #endif 
....................    fprintf(USER,"\r\nS) Configure TCP/IP (Reset)"); 
170A:  MOVLW  4C
170C:  MOVWF  FF6
170E:  MOVLW  05
1710:  MOVWF  FF7
1712:  CALL   0928
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................    fprintf(USER,"\r\nM) Configure SMTP"); 
....................    fprintf(USER,"\r\nE) Send E-Mail"); 
....................    #endif 
....................    #ifdef CCS_UDP_EXAMPLE 
....................    fprintf(USER,"\r\nU) Configure UDP"); 
1716:  MOVLW  6A
1718:  MOVWF  FF6
171A:  MOVLW  05
171C:  MOVWF  FF7
171E:  CALL   0928
....................    #endif 
....................    fprintf(USER,"\r\nZ) Clear EEPROM (!!!)"); 
1722:  MOVLW  7E
1724:  MOVWF  FF6
1726:  MOVLW  05
1728:  MOVWF  FF7
172A:  CALL   0928
.................... } 
172E:  RETLW  00
....................  
.................... #if STACK_USE_PPP 
.................... void ATCommandMode(void) 
.................... { 
....................    char c; 
....................     
....................    fprintf(USER,"\r\n\nAT Command Mode\r\n(power cycle to stop)\r\n\n"); 
....................     
....................    while(TRUE) 
....................    { 
....................       restart_wdt(); 
....................       if (kbhit(USER))  
....................       { 
....................          c = fgetc(USER); 
....................          fputc(c, MODEM); 
....................       } 
....................       if (modem_kbhit) 
....................       { 
....................          c = modem_getb(); 
....................          fputc(c, USER); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... void ui_handle(void) 
.................... { 
....................    char c; 
....................     
....................    c=fgetc(USER); 
*
2C8C:  BTFSS  F9E.5
2C8E:  BRA    2C8C
2C90:  MOVFF  FAE,120
2C94:  MOVLB  1
....................    c=toupper(c); 
2C96:  MOVF   x20,W
2C98:  SUBLW  60
2C9A:  BC    2CA8
2C9C:  MOVF   x20,W
2C9E:  SUBLW  7A
2CA0:  BNC   2CA8
2CA2:  MOVF   x20,W
2CA4:  ANDLW  DF
2CA6:  BRA    2CAA
2CA8:  MOVF   x20,W
2CAA:  MOVWF  x20
....................     
....................    switch(c) {      
2CAC:  MOVF   x20,W
2CAE:  XORLW  55
2CB0:  MOVLB  0
2CB2:  BZ    2CC6
2CB4:  XORLW  01
2CB6:  BZ    2CCC
2CB8:  XORLW  10
2CBA:  BZ    2CD0
2CBC:  XORLW  17
2CBE:  BZ    2CD6
2CC0:  XORLW  09
2CC2:  BZ    2CDA
2CC4:  BRA    2CEC
....................       #if STACK_USE_PPP 
....................       case 'H':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nHanging up\r\n"); 
....................                      ppp_init(); //ppp_init() will reset the PPP and the MODEM forcing a hangup 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nNot Connected\r\n"); 
....................                   } 
....................                   break; 
....................  
....................       case 'C':   if (ppp_is_connected()) { 
....................                      fprintf(USER,"\r\n\nAlready connected!\r\n"); 
....................                   } 
....................                   else { 
....................                      fprintf(USER,"\r\n\nConnecting\r\n"); 
....................                      picdem_ppp_connect(); 
....................                   } 
....................                   break; 
....................       case 'A':   ATCommandMode(); 
....................                   break; 
....................       #endif 
....................  
....................    #ifdef CCS_EMAIL_EXAMPLE 
....................       case 'M':   ui_mail_settings(); 
....................                   break; 
....................  
....................       case 'E':   my_smtp_send(); 
....................                   fprintf(USER, "\r\n\nSending E-Mail.  Watch LCD for status.\r\n\n"); 
....................                   break; 
....................    #endif 
....................  
....................    #ifdef CCS_UDP_EXAMPLE 
....................       case 'U':   ui_udp_settings(); 
2CC6:  GOTO   2058
....................                   break; 
2CCA:  BRA    2CEC
....................    #endif 
....................  
....................  
....................       case 'T':   hardware_test(); 
2CCC:  BRA    25BA
....................                   break; 
2CCE:  BRA    2CEC
....................  
....................       case 'D':   ui_settings(); 
2CD0:  CALL   1516
....................                   break; 
2CD4:  BRA    2CEC
....................  
....................       case 'S':   ui_setup(); 
2CD6:  BRA    2B28
....................                   break; 
2CD8:  BRA    2CEC
....................  
....................   #if STACK_USE_EEPROM 
....................       case 'Z':   clear_ee(); 
2CDA:  CALL   09E4
....................                   fprintf(USER,"\r\nEEPROM Cleared\r\n"); 
2CDE:  MOVLW  96
2CE0:  MOVWF  FF6
2CE2:  MOVLW  05
2CE4:  MOVWF  FF7
2CE6:  CALL   0928
....................                   break; 
2CEA:  BRA    2CEC
....................   #endif 
....................    } 
....................    ui_menu(); 
2CEC:  CALL   16FE
.................... } 
2CF0:  GOTO   5C8E (RETURN)
.................... #endif 
....................  
....................  
.................... enum 
.................... { 
....................    UDP_TX_SM_ARP_REQ=0, 
....................    UDP_TX_SM_ARP_RES, 
....................    UDP_TX_SM_CONNECT, 
....................    UDP_TX_SM_CONNECTED, 
....................    UDP_TX_SM_5S_DELAY 
.................... } ge_UDPTXSM = 0; 
....................  
.................... UDP_SOCKET g_UDPRXSocket = INVALID_UDP_SOCKET; 
....................  
.................... struct 
.................... { 
....................    int8 adc; 
....................    int8 button; 
....................    int1 isValid; 
.................... } UDPRXPacket = {0}; 
....................  
....................  
.................... void LCDTask(void) 
.................... { 
.................... #if STACK_USE_PICDEM_LCD 
....................    static TICKTYPE lastTick; 
....................    if (TickGetDiff(TickGet(), lastTick) > (TICKS_PER_SECOND/2)) 
*
1862:  RCALL  1730
1864:  MOVFF  02,121
1868:  MOVFF  01,120
186C:  MOVLB  1
186E:  MOVF   02,W
1870:  SUBWF  x06,W
1872:  BNC   187C
1874:  BNZ   1880
1876:  MOVF   x05,W
1878:  SUBWF  x20,W
187A:  BNC   1880
187C:  MOVLW  00
187E:  BRA    1882
1880:  MOVLW  01
1882:  CLRF   03
1884:  IORWF  03,W
1886:  BZ    18B4
1888:  MOVLW  FF
188A:  BSF    FD8.0
188C:  SUBFWB x05,W
188E:  MOVWF  x20
1890:  MOVLW  FF
1892:  SUBFWB x06,W
1894:  MOVWF  x21
1896:  MOVLB  0
1898:  RCALL  1730
189A:  MOVF   01,W
189C:  MOVLB  1
189E:  ADDWF  x20,F
18A0:  MOVF   02,W
18A2:  ADDWFC x21,F
18A4:  MOVLW  01
18A6:  ADDWF  x20,W
18A8:  MOVWF  01
18AA:  MOVLW  00
18AC:  ADDWFC x21,W
18AE:  MOVWF  03
18B0:  MOVF   01,W
18B2:  BRA    18D0
18B4:  MOVLB  0
18B6:  RCALL  1730
18B8:  MOVFF  02,121
18BC:  MOVFF  01,120
18C0:  MOVLB  1
18C2:  MOVF   x05,W
18C4:  SUBWF  01,W
18C6:  MOVWF  00
18C8:  MOVF   x06,W
18CA:  SUBWFB 02,W
18CC:  MOVWF  03
18CE:  MOVF   00,W
18D0:  SUBLW  05
18D2:  BTFSC  FD8.0
18D4:  BRA    19F4
....................    { 
....................       lastTick = TickGet(); 
18D6:  MOVLB  0
18D8:  RCALL  1730
18DA:  MOVFF  02,106
18DE:  MOVFF  01,105
....................       if (!MACIsLinked()) 
18E2:  RCALL  174A
18E4:  MOVF   01,F
18E6:  BNZ   18F6
....................       { 
....................         #if STACK_USE_MAC 
....................          printf(lcd_putc,"\fNO ETHERNET"); 
18E8:  MOVLW  AA
18EA:  MOVWF  FF6
18EC:  MOVLW  05
18EE:  MOVWF  FF7
18F0:  CALL   0918
....................         #else 
....................          printf(lcd_putc,"\fNO PPP"); 
....................         #endif 
....................       } 
....................      #if STACK_USE_DHCP 
....................       else if (read_ext_eeprom(EE_NIC_DHCP) && !DHCPIsBound()) 
18F4:  BRA    19F2
18F6:  MOVLB  1
18F8:  CLRF   x37
18FA:  MOVLW  C0
18FC:  MOVWF  x36
18FE:  MOVLB  0
1900:  CALL   082E
1904:  MOVF   01,F
1906:  BZ    191A
1908:  BTFSC  x86.0
190A:  BRA    191A
....................       { 
....................          printf(lcd_putc,"\fDHCP NOT BOUND"); 
190C:  MOVLW  B8
190E:  MOVWF  FF6
1910:  MOVLW  05
1912:  MOVWF  FF7
1914:  CALL   0918
....................       } 
....................      #endif 
....................       else 
1918:  BRA    19F2
....................       { 
....................          if (g_UDPRXSocket == INVALID_UDP_SOCKET) 
191A:  MOVLB  1
191C:  INCFSZ x01,W
191E:  BRA    1932
....................             printf(lcd_putc,"\fRX: ERROR"); 
1920:  MOVLW  C8
1922:  MOVWF  FF6
1924:  MOVLW  05
1926:  MOVWF  FF7
1928:  MOVLB  0
192A:  CALL   0918
....................          else if (UDPRXPacket.isValid) 
192E:  BRA    19CA
1930:  MOVLB  1
1932:  BTFSS  x04.0
1934:  BRA    1958
....................          { 
....................             printf(lcd_putc, "\fRX: ADC=%X", UDPRXPacket.adc); 
1936:  MOVLW  D4
1938:  MOVWF  FF6
193A:  MOVLW  05
193C:  MOVWF  FF7
193E:  MOVLW  09
1940:  MOVWF  x20
1942:  MOVLB  0
1944:  BRA    1768
1946:  MOVFF  102,120
194A:  MOVLW  37
194C:  MOVLB  1
194E:  MOVWF  x21
1950:  MOVLB  0
1952:  BRA    1794
....................          } 
....................          else 
1954:  BRA    19CA
1956:  MOVLB  1
....................          { 
....................             printf(lcd_putc,"\f%u.%u.%u.%u\n", MY_IP_BYTE1, MY_IP_BYTE2, 
....................                   MY_IP_BYTE3, MY_IP_BYTE4); 
1958:  MOVLW  0C
195A:  MOVWF  x23
195C:  MOVLB  0
195E:  CALL   08BC
1962:  MOVFF  16,120
1966:  MOVLW  1B
1968:  MOVLB  1
196A:  MOVWF  x21
196C:  MOVLB  0
196E:  RCALL  17E0
1970:  MOVLW  2E
1972:  MOVLB  1
1974:  MOVWF  x23
1976:  MOVLB  0
1978:  CALL   08BC
197C:  MOVFF  17,120
1980:  MOVLW  1B
1982:  MOVLB  1
1984:  MOVWF  x21
1986:  MOVLB  0
1988:  RCALL  17E0
198A:  MOVLW  2E
198C:  MOVLB  1
198E:  MOVWF  x23
1990:  MOVLB  0
1992:  CALL   08BC
1996:  MOVFF  18,120
199A:  MOVLW  1B
199C:  MOVLB  1
199E:  MOVWF  x21
19A0:  MOVLB  0
19A2:  RCALL  17E0
19A4:  MOVLW  2E
19A6:  MOVLB  1
19A8:  MOVWF  x23
19AA:  MOVLB  0
19AC:  CALL   08BC
19B0:  MOVFF  19,120
19B4:  MOVLW  1B
19B6:  MOVLB  1
19B8:  MOVWF  x21
19BA:  MOVLB  0
19BC:  RCALL  17E0
19BE:  MOVLW  0A
19C0:  MOVLB  1
19C2:  MOVWF  x23
19C4:  MOVLB  0
19C6:  CALL   08BC
....................          } 
....................  
....................          if (ge_UDPTXSM == UDP_TX_SM_CONNECTED) 
19CA:  MOVLB  1
19CC:  MOVF   x00,W
19CE:  SUBLW  03
19D0:  BNZ   19E4
....................             printf(lcd_putc,"\nTX: CONNECTED"); 
19D2:  MOVLW  E0
19D4:  MOVWF  FF6
19D6:  MOVLW  05
19D8:  MOVWF  FF7
19DA:  MOVLB  0
19DC:  CALL   0918
....................          else 
19E0:  BRA    19F2
19E2:  MOVLB  1
....................             printf(lcd_putc,"\nTX: CONNECTING"); 
19E4:  MOVLW  F0
19E6:  MOVWF  FF6
19E8:  MOVLW  05
19EA:  MOVWF  FF7
19EC:  MOVLB  0
19EE:  CALL   0918
19F2:  MOVLB  1
....................       } 
....................    } 
.................... #endif    
.................... } 
19F4:  MOVLB  0
19F6:  RETLW  00
....................  
.................... void MyUDPTXTask(void) 
.................... { 
....................    static UDP_SOCKET socket; 
....................    static NODE_INFO remote; 
....................    static TICKTYPE lastTick; 
....................    TICKTYPE currTick; 
....................  
....................    currTick=TickGet(); 
*
57E0:  CALL   1730
57E4:  MOVFF  02,121
57E8:  MOVFF  01,120
....................  
....................    switch (ge_UDPTXSM) 
....................    { 
57EC:  MOVLB  1
57EE:  MOVF   x00,W
57F0:  XORLW  00
57F2:  MOVLB  0
57F4:  BZ    580E
57F6:  XORLW  01
57F8:  BZ    5856
57FA:  XORLW  03
57FC:  BTFSC  FD8.2
57FE:  BRA    58D2
5800:  XORLW  01
5802:  BTFSC  FD8.2
5804:  BRA    5960
5806:  XORLW  07
5808:  BTFSC  FD8.2
580A:  BRA    5A10
580C:  BRA    580E
....................       default: 
....................       case UDP_TX_SM_ARP_REQ: 
....................          read_ext_eeprom_ip(EE_UDP_DEST_IP, &remote.IPAddr); 
580E:  MOVLW  02
5810:  MOVLB  1
5812:  MOVWF  x2D
5814:  MOVLW  19
5816:  MOVWF  x2C
5818:  MOVLW  01
581A:  MOVWF  x2F
581C:  MOVLW  0E
581E:  MOVWF  x2E
5820:  MOVLB  0
5822:  CALL   0B28
....................      #if STACK_USE_ARP 
....................          if (ARPIsTxReady()) 
5826:  MOVLW  01
5828:  MOVLB  1
582A:  MOVWF  x46
582C:  MOVLB  0
582E:  CALL   426A
5832:  MOVF   01,F
5834:  BZ    5854
....................          { 
....................             ARPResolve(&remote.IPAddr); 
5836:  MOVLW  01
5838:  MOVLB  1
583A:  MOVWF  x23
583C:  MOVLW  0E
583E:  MOVWF  x22
5840:  MOVLB  0
5842:  BRA    5720
....................             lastTick=currTick; 
5844:  MOVFF  121,113
5848:  MOVFF  120,112
....................             ge_UDPTXSM=UDP_TX_SM_ARP_RES; 
584C:  MOVLW  01
584E:  MOVLB  1
5850:  MOVWF  x00
5852:  MOVLB  0
....................          } 
....................          break; 
5854:  BRA    5A6A
....................  
....................       case UDP_TX_SM_ARP_RES: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) 
5856:  MOVLW  01
5858:  MOVLB  1
585A:  MOVWF  x23
585C:  MOVLW  0E
585E:  MOVWF  x22
5860:  MOVLW  01
5862:  MOVWF  x25
5864:  MOVLW  08
5866:  MOVWF  x24
5868:  MOVLB  0
586A:  BRA    5760
586C:  MOVF   01,F
586E:  BZ    5878
....................             ge_UDPTXSM=UDP_TX_SM_CONNECT; 
5870:  MOVLW  02
5872:  MOVLB  1
5874:  MOVWF  x00
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) 
5876:  BRA    58CE
5878:  MOVLB  1
587A:  MOVF   x21,W
587C:  SUBWF  x13,W
587E:  BNC   5888
5880:  BNZ   588C
5882:  MOVF   x12,W
5884:  SUBWF  x20,W
5886:  BNC   588C
5888:  MOVLW  00
588A:  BRA    588E
588C:  MOVLW  01
588E:  CLRF   03
5890:  IORWF  03,W
5892:  BZ    58BA
5894:  MOVLW  FF
5896:  BSF    FD8.0
5898:  SUBFWB x12,W
589A:  MOVWF  x22
589C:  MOVLW  FF
589E:  SUBFWB x13,W
58A0:  MOVWF  x23
58A2:  MOVF   x20,W
58A4:  ADDWF  x22,F
58A6:  MOVF   x21,W
58A8:  ADDWFC x23,F
58AA:  MOVLW  01
58AC:  ADDWF  x22,W
58AE:  MOVWF  01
58B0:  MOVLW  00
58B2:  ADDWFC x23,W
58B4:  MOVWF  03
58B6:  MOVF   01,W
58B8:  BRA    58C8
58BA:  MOVF   x12,W
58BC:  SUBWF  x20,W
58BE:  MOVWF  00
58C0:  MOVF   x13,W
58C2:  SUBWFB x21,W
58C4:  MOVWF  03
58C6:  MOVF   00,W
58C8:  SUBLW  14
58CA:  BC    58CE
....................             ge_UDPTXSM=UDP_TX_SM_ARP_REQ; 
58CC:  CLRF   x00
....................          break; 
58CE:  MOVLB  0
58D0:  BRA    5A6A
....................    #endif 
....................  
....................       case UDP_TX_SM_CONNECT: 
....................          socket=UDPOpen( 
....................                read_ext_eeprom16(EE_UDP_DEST_PORT)+read_ext_eeprom16(EE_UDP_SRC_PORT), //the source port, not important for the TX task.  just make it different 
....................                &remote, 
....................                read_ext_eeprom16(EE_UDP_DEST_PORT) 
....................             ); 
58D2:  MOVLW  02
58D4:  MOVLB  1
58D6:  MOVWF  x27
58D8:  MOVLW  1D
58DA:  MOVWF  x26
58DC:  MOVLB  0
58DE:  CALL   142A
58E2:  MOVFF  02,123
58E6:  MOVFF  01,122
58EA:  MOVLW  02
58EC:  MOVLB  1
58EE:  MOVWF  x27
58F0:  MOVLW  1F
58F2:  MOVWF  x26
58F4:  MOVLB  0
58F6:  CALL   142A
58FA:  MOVFF  02,03
58FE:  MOVF   01,W
5900:  MOVLB  1
5902:  ADDWF  x22,F
5904:  MOVF   02,W
5906:  ADDWFC x23,F
5908:  MOVLW  02
590A:  MOVWF  x27
590C:  MOVLW  1D
590E:  MOVWF  x26
5910:  MOVLB  0
5912:  CALL   142A
5916:  MOVFF  02,125
591A:  MOVFF  01,124
591E:  MOVFF  123,134
5922:  MOVFF  122,133
5926:  MOVLW  01
5928:  MOVLB  1
592A:  MOVWF  x36
592C:  MOVLW  08
592E:  MOVWF  x35
5930:  MOVFF  02,138
5934:  MOVFF  01,137
5938:  MOVLB  0
593A:  CALL   45AA
593E:  MOVFF  01,107
....................          lastTick = currTick; 
5942:  MOVFF  121,113
5946:  MOVFF  120,112
....................          if (socket != INVALID_UDP_SOCKET) 
594A:  MOVLB  1
594C:  INCFSZ x07,W
594E:  BRA    5952
5950:  BRA    5958
....................             ge_UDPTXSM = UDP_TX_SM_CONNECTED; 
5952:  MOVLW  03
5954:  MOVWF  x00
....................          else 
5956:  BRA    595C
....................             ge_UDPTXSM = UDP_TX_SM_5S_DELAY; 
5958:  MOVLW  04
595A:  MOVWF  x00
....................          break; 
595C:  MOVLB  0
595E:  BRA    5A6A
....................  
....................       case UDP_TX_SM_CONNECTED: 
....................          if (TickGetDiff(currTick, lastTick) >= (TICKS_PER_SECOND / 3)) 
5960:  MOVLB  1
5962:  MOVF   x21,W
5964:  SUBWF  x13,W
5966:  BNC   5970
5968:  BNZ   5974
596A:  MOVF   x12,W
596C:  SUBWF  x20,W
596E:  BNC   5974
5970:  MOVLW  00
5972:  BRA    5976
5974:  MOVLW  01
5976:  CLRF   03
5978:  IORWF  03,W
597A:  BZ    59A2
597C:  MOVLW  FF
597E:  BSF    FD8.0
5980:  SUBFWB x12,W
5982:  MOVWF  x22
5984:  MOVLW  FF
5986:  SUBFWB x13,W
5988:  MOVWF  x23
598A:  MOVF   x20,W
598C:  ADDWF  x22,F
598E:  MOVF   x21,W
5990:  ADDWFC x23,F
5992:  MOVLW  01
5994:  ADDWF  x22,W
5996:  MOVWF  01
5998:  MOVLW  00
599A:  ADDWFC x23,W
599C:  MOVWF  03
599E:  MOVF   01,W
59A0:  BRA    59B0
59A2:  MOVF   x12,W
59A4:  SUBWF  x20,W
59A6:  MOVWF  00
59A8:  MOVF   x13,W
59AA:  SUBWFB x21,W
59AC:  MOVWF  03
59AE:  MOVF   00,W
59B0:  SUBLW  02
59B2:  BC    59F4
....................          { 
....................             if (UDPIsPutReady(socket)) 
59B4:  MOVFF  107,133
59B8:  MOVLB  0
59BA:  CALL   4670
59BE:  MOVF   01,F
59C0:  BZ    59F4
....................             { 
....................                lastTick = currTick; 
59C2:  MOVFF  121,113
59C6:  MOVFF  120,112
....................                UDPPut(read_adc()); 
59CA:  BSF    FC2.2
59CC:  BTFSC  FC2.2
59CE:  BRA    59CC
59D0:  MOVFF  FC4,122
59D4:  MOVFF  FC4,135
59D8:  MOVLB  0
59DA:  CALL   47D0
.................... #if defined(USER_BUTTON1)                
....................                UDPPut(input(USER_BUTTON1)); 
59DE:  MOVLW  00
59E0:  BTFSC  F80.4
59E2:  MOVLW  01
59E4:  MOVLB  1
59E6:  MOVWF  x22
59E8:  MOVWF  x35
59EA:  MOVLB  0
59EC:  CALL   47D0
.................... #else 
....................                UDPPut(1); 
.................... #endif                
....................                UDPFlush(); 
59F0:  CALL   4682
....................             } 
....................          } 
....................          if (!MACIsLinked()) 
59F4:  MOVLB  0
59F6:  CALL   174A
59FA:  MOVF   01,F
59FC:  BNZ   5A0E
....................          { 
....................             UDPClose(socket); 
59FE:  MOVFF  107,133
5A02:  CALL   1096
....................             ge_UDPTXSM = UDP_TX_SM_5S_DELAY; 
5A06:  MOVLW  04
5A08:  MOVLB  1
5A0A:  MOVWF  x00
5A0C:  MOVLB  0
....................          } 
....................          break; 
5A0E:  BRA    5A6A
....................  
....................       case UDP_TX_SM_5S_DELAY: 
....................          if (TickGetDiff(currTick,lastTick) >= (5 * TICKS_PER_SECOND)) 
5A10:  MOVLB  1
5A12:  MOVF   x21,W
5A14:  SUBWF  x13,W
5A16:  BNC   5A20
5A18:  BNZ   5A24
5A1A:  MOVF   x12,W
5A1C:  SUBWF  x20,W
5A1E:  BNC   5A24
5A20:  MOVLW  00
5A22:  BRA    5A26
5A24:  MOVLW  01
5A26:  CLRF   03
5A28:  IORWF  03,W
5A2A:  BZ    5A52
5A2C:  MOVLW  FF
5A2E:  BSF    FD8.0
5A30:  SUBFWB x12,W
5A32:  MOVWF  x22
5A34:  MOVLW  FF
5A36:  SUBFWB x13,W
5A38:  MOVWF  x23
5A3A:  MOVF   x20,W
5A3C:  ADDWF  x22,F
5A3E:  MOVF   x21,W
5A40:  ADDWFC x23,F
5A42:  MOVLW  01
5A44:  ADDWF  x22,W
5A46:  MOVWF  01
5A48:  MOVLW  00
5A4A:  ADDWFC x23,W
5A4C:  MOVWF  03
5A4E:  MOVF   01,W
5A50:  BRA    5A60
5A52:  MOVF   x12,W
5A54:  SUBWF  x20,W
5A56:  MOVWF  00
5A58:  MOVF   x13,W
5A5A:  SUBWFB x21,W
5A5C:  MOVWF  03
5A5E:  MOVF   00,W
5A60:  SUBLW  31
5A62:  BC    5A66
....................             ge_UDPTXSM = UDP_TX_SM_ARP_REQ; 
5A64:  CLRF   x00
....................          break; 
5A66:  MOVLB  0
5A68:  BRA    5A6A
....................    } 
.................... } 
5A6A:  GOTO   5C94 (RETURN)
....................  
.................... void MyUDPRXTask(void) 
.................... { 
....................    static NODE_INFO remote; 
....................    static TICKTYPE lastTick; 
....................    TICKTYPE currTick; 
....................  
....................    currTick=TickGet(); 
5A6E:  CALL   1730
5A72:  MOVFF  02,121
5A76:  MOVFF  01,120
....................  
....................    if (g_UDPRXSocket == INVALID_UDP_SOCKET) 
5A7A:  MOVLB  1
5A7C:  INCFSZ x01,W
5A7E:  BRA    5AB6
....................       g_UDPRXSocket = UDPOpen(read_ext_eeprom16(EE_UDP_SRC_PORT),NULL,INVALID_UDP_SOCKET); 
5A80:  MOVLW  02
5A82:  MOVWF  x27
5A84:  MOVLW  1F
5A86:  MOVWF  x26
5A88:  MOVLB  0
5A8A:  CALL   142A
5A8E:  MOVFF  02,123
5A92:  MOVFF  01,122
5A96:  MOVFF  02,134
5A9A:  MOVFF  01,133
5A9E:  MOVLB  1
5AA0:  CLRF   x36
5AA2:  CLRF   x35
5AA4:  CLRF   x38
5AA6:  MOVLW  FF
5AA8:  MOVWF  x37
5AAA:  MOVLB  0
5AAC:  CALL   45AA
5AB0:  MOVFF  01,101
....................    else if (UDPIsGetReady(g_UDPRXSocket)) 
5AB4:  BRA    5AEE
5AB6:  MOVFF  101,133
5ABA:  MOVLB  0
5ABC:  CALL   4AFE
5AC0:  MOVF   01,F
5AC2:  BZ    5AEE
....................    { 
....................       UDPGet(&UDPRXPacket.adc); 
5AC4:  MOVLW  01
5AC6:  MOVLB  1
5AC8:  MOVWF  x3D
5ACA:  MOVLW  02
5ACC:  MOVWF  x3C
5ACE:  MOVLB  0
5AD0:  CALL   4B44
....................       UDPGet(&UDPRXPacket.button); 
5AD4:  MOVLW  01
5AD6:  MOVLB  1
5AD8:  MOVWF  x3D
5ADA:  MOVLW  03
5ADC:  MOVWF  x3C
5ADE:  MOVLB  0
5AE0:  CALL   4B44
....................       UDPRXPacket.isValid = TRUE; 
5AE4:  MOVLB  1
5AE6:  BSF    x04.0
....................       UDPDiscard(); 
5AE8:  MOVLB  0
5AEA:  CALL   4C5E
....................    } 
.................... } 
5AEE:  GOTO   5C96 (RETURN)
....................  
.................... void splash(void) 
.................... { 
....................    printf("\r\n\n\nEX_ST_UDP.C - UDP Transmit/Receive Example\r\n\n"); 
*
19F8:  MOVLW  00
19FA:  MOVWF  FF6
19FC:  MOVLW  06
19FE:  MOVWF  FF7
1A00:  CALL   0928
....................  
....................    UDPRXPacket.isValid = FALSE; 
1A04:  MOVLB  1
1A06:  BCF    x04.0
....................  
....................    ui_settings(); 
1A08:  MOVLB  0
1A0A:  RCALL  1516
....................    ui_menu(); 
1A0C:  RCALL  16FE
....................  
....................    LCDTask(); 
1A0E:  RCALL  1862
.................... } 
1A10:  GOTO   5C68 (RETURN)
....................  
.................... void main(void) { 
*
5AF2:  CLRF   FF8
5AF4:  BCF    FD0.7
5AF6:  BSF    07.7
5AF8:  CLRF   FEA
5AFA:  CLRF   FE9
5AFC:  MOVLW  81
5AFE:  MOVWF  FAF
5B00:  MOVLW  A6
5B02:  MOVWF  FAC
5B04:  MOVLW  90
5B06:  MOVWF  FAB
5B08:  MOVLW  81
5B0A:  MOVWF  FAF
5B0C:  MOVLW  A6
5B0E:  MOVWF  FAC
5B10:  MOVLW  90
5B12:  MOVWF  FAB
5B14:  MOVLW  81
5B16:  MOVWF  FAF
5B18:  MOVLW  A6
5B1A:  MOVWF  FAC
5B1C:  MOVLW  90
5B1E:  MOVWF  FAB
5B20:  BSF    FC1.0
5B22:  BSF    FC1.1
5B24:  BSF    FC1.2
5B26:  BCF    FC1.3
5B28:  MOVLW  07
5B2A:  MOVWF  FB4
5B2C:  CLRF   47
5B2E:  CLRF   48
5B30:  CLRF   4E
5B32:  CLRF   4F
5B34:  CLRF   50
5B36:  CLRF   51
5B38:  CLRF   x85
5B3A:  CLRF   x86
5B3C:  CLRF   x87
5B3E:  CLRF   x88
5B40:  CLRF   x89
5B42:  MOVLW  FF
5B44:  MOVWF  x8A
5B46:  CLRF   x8B
5B48:  CLRF   x8C
5B4A:  CLRF   x8D
5B4C:  CLRF   x8E
5B4E:  CLRF   x8F
5B50:  CLRF   x90
5B52:  CLRF   x91
5B54:  CLRF   x92
5B56:  CLRF   x93
5B58:  CLRF   x94
5B5A:  CLRF   x95
5B5C:  CLRF   x96
5B5E:  CLRF   x97
5B60:  CLRF   x98
5B62:  CLRF   x99
5B64:  CLRF   x9A
5B66:  CLRF   x9B
5B68:  CLRF   x9C
5B6A:  CLRF   x9D
5B6C:  CLRF   x9E
5B6E:  CLRF   x9F
5B70:  CLRF   xA0
5B72:  CLRF   xA1
5B74:  CLRF   xA2
5B76:  BCF    56.1
5B78:  CLRF   xA3
5B7A:  CLRF   xA4
5B7C:  CLRF   xA5
5B7E:  CLRF   xA6
5B80:  CLRF   xA7
5B82:  CLRF   xA8
5B84:  CLRF   xA9
5B86:  CLRF   xAA
5B88:  CLRF   xAB
5B8A:  CLRF   xAC
5B8C:  CLRF   xB8
5B8E:  CLRF   xB9
5B90:  CLRF   xBA
5B92:  CLRF   xBB
5B94:  CLRF   xBC
5B96:  CLRF   xBD
5B98:  CLRF   xBE
5B9A:  CLRF   xBF
5B9C:  CLRF   xC0
5B9E:  CLRF   xC1
5BA0:  CLRF   xC2
5BA2:  CLRF   xC3
5BA4:  CLRF   xC4
5BA6:  CLRF   xC5
5BA8:  CLRF   xC6
5BAA:  CLRF   xC7
5BAC:  CLRF   xC8
5BAE:  CLRF   xC9
5BB0:  CLRF   xCA
5BB2:  CLRF   xCB
5BB4:  CLRF   xCC
5BB6:  CLRF   xCD
5BB8:  CLRF   xCE
5BBA:  CLRF   xCF
5BBC:  CLRF   xD0
5BBE:  CLRF   xD1
5BC0:  CLRF   xD2
5BC2:  CLRF   xD3
5BC4:  CLRF   xD4
5BC6:  CLRF   xD5
5BC8:  CLRF   xD6
5BCA:  CLRF   xD7
5BCC:  CLRF   xD8
5BCE:  CLRF   xD9
5BD0:  CLRF   xDA
5BD2:  CLRF   xDB
5BD4:  CLRF   xDC
5BD6:  CLRF   xDD
5BD8:  CLRF   xDE
5BDA:  CLRF   xDF
5BDC:  CLRF   xE0
5BDE:  CLRF   xE1
5BE0:  CLRF   xE2
5BE2:  CLRF   xE3
5BE4:  CLRF   xE4
5BE6:  CLRF   xE5
5BE8:  CLRF   xE6
5BEA:  CLRF   xE7
5BEC:  CLRF   xE8
5BEE:  CLRF   xE9
5BF0:  CLRF   xEA
5BF2:  CLRF   xEB
5BF4:  CLRF   xEC
5BF6:  CLRF   xED
5BF8:  CLRF   xEE
5BFA:  CLRF   xEF
5BFC:  CLRF   xF0
5BFE:  CLRF   xF1
5C00:  CLRF   xF2
5C02:  CLRF   xF3
5C04:  CLRF   xF4
5C06:  CLRF   xF5
5C08:  CLRF   xF6
5C0A:  CLRF   xF7
5C0C:  CLRF   xF8
5C0E:  CLRF   xF9
5C10:  CLRF   xFA
5C12:  CLRF   xFB
5C14:  CLRF   xFC
5C16:  CLRF   xFD
5C18:  CLRF   xFE
5C1A:  CLRF   xFF
5C1C:  MOVLB  1
5C1E:  CLRF   x00
5C20:  MOVWF  x01
5C22:  CLRF   x02
5C24:  CLRF   x03
5C26:  CLRF   x04
5C28:  CLRF   x05
5C2A:  CLRF   x06
5C2C:  CLRF   x07
5C2E:  CLRF   x08
5C30:  CLRF   x09
5C32:  CLRF   x0A
5C34:  CLRF   x0B
5C36:  CLRF   x0C
5C38:  CLRF   x0D
5C3A:  CLRF   x0E
5C3C:  CLRF   x0F
5C3E:  CLRF   x10
5C40:  CLRF   x11
5C42:  CLRF   x12
5C44:  CLRF   x13
5C46:  CLRF   x14
5C48:  CLRF   x15
5C4A:  CLRF   x16
5C4C:  CLRF   x17
5C4E:  CLRF   x18
5C50:  CLRF   x19
5C52:  CLRF   x1A
5C54:  CLRF   x1B
5C56:  CLRF   x1C
5C58:  CLRF   x1D
5C5A:  CLRF   x1E
5C5C:  CLRF   x1F
....................    init(); 
5C5E:  MOVLB  0
5C60:  GOTO   1164
....................    splash(); 
5C64:  GOTO   19F8
....................  
....................    while(TRUE) { 
....................       restart_wdt(); 
5C68:  CLRWDT
....................  
....................       //every second: refresh current IP, blink LED 
....................       if (second_counter>=1) { 
5C6A:  MOVF   50,W
5C6C:  SUBLW  00
5C6E:  BC    5C74
.................... #if defined(USER_LED1)          
....................          output_toggle(USER_LED1); 
5C70:  BTG    F89.5
.................... #endif 
....................          second_counter=0; 
5C72:  CLRF   50
....................       } 
....................  
.................... #if defined(USER_LED2) 
....................       if (UDPRXPacket.isValid) 
5C74:  MOVLB  1
5C76:  BTFSS  x04.0
5C78:  BRA    5C84
....................       { 
....................          if (UDPRXPacket.button) 
5C7A:  MOVF   x03,F
5C7C:  BZ    5C82
....................             output_high(USER_LED2); 
5C7E:  BSF    F8A.4
....................          else 
5C80:  BRA    5C84
....................             output_low(USER_LED2); 
5C82:  BCF    F8A.4
....................       } 
.................... #endif 
....................  
....................       if (kbhit(USER)) 
5C84:  BTFSS  F9E.5
5C86:  BRA    5C8E
....................          ui_handle(); 
5C88:  MOVLB  0
5C8A:  GOTO   2C8C
....................  
....................       #if STACK_USE_PPP 
....................       if (ppp_is_connected()) 
....................       { 
....................       #endif 
....................          StackTask(); 
5C8E:  MOVLB  0
5C90:  BRA    5538
....................          MyUDPTXTask(); 
5C92:  BRA    57E0
....................          MyUDPRXTask(); 
5C94:  BRA    5A6E
....................          LCDTask(); 
5C96:  CALL   1862
....................       #if STACK_USE_PPP 
....................       } 
....................       #endif 
....................    } 
5C9A:  BRA    5C68
.................... } 
....................  
5C9C:  SLEEP 

Configuration Fuses:
   Word  1: 2700   RC_IO NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0080   NOSTVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: A000   WRT NOWRTD WRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
